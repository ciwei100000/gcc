# DP: updates from the 8 branch upto 20190817 (r274599).

last_update()
{
	cat > ${dir}LAST_UPDATED <EOF
Sat Aug 17 10:58:23 CEST 2019
Sat Aug 17 08:58:23 UTC 2019 (revision 274599)
EOF
}

LANG=C svn diff svn://gcc.gnu.org/svn/gcc/tags/gcc_8_3_0_release svn://gcc.gnu.org/svn/gcc/branches/gcc-8-branch \
	| sed -r 's,^--- (\S+)\t(\S+)(.*)$,--- a/src/\1\t\2,;s,^\+\+\+ (\S+)\t(\S+)(.*)$,+++ b/src/\1\t\2,' \
	| awk '/^Index:.*\.(class|texi)/ {skip=1; next} /^Index:/ { skip=0 } skip==0'

Index: libgomp/ChangeLog
===================================================================
--- a/src/libgomp/ChangeLog	(.../tags/gcc_8_3_0_release)
+++ b/src/libgomp/ChangeLog	(.../branches/gcc-8-branch)
@@ -1,3 +1,8 @@
+2019-06-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/90811
+	* testsuite/libgomp.c/pr90811.c: New test.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: libgomp/testsuite/libgomp.c/pr90811.c
===================================================================
--- a/src/libgomp/testsuite/libgomp.c/pr90811.c	(.../tags/gcc_8_3_0_release)
+++ b/src/libgomp/testsuite/libgomp.c/pr90811.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,29 @@
+/* PR target/90811 */
+
+int
+main ()
+{
+  long long a[100], b[100];
+  int i;
+  for (i = 0; i < 100; i++)
+    {
+      a[i] = i;
+      b[i] = i % 10;
+    }
+  #pragma omp target teams distribute parallel for simd map(tofrom: a[:100], b[:100])
+  for (i = 0; i < 100; i++)
+    {
+      long long c = 0;
+      const long long d[] = { 1, 3, 5, 7, 9 };
+      for (int j = 4; j >= 0; j--)
+         c = d[j] + b[i] * c;
+      a[i] += c;
+    }
+  for (i = 0; i < 100; i++)
+    {
+      const long long r[] = { 1, 26, 229, 976, 2849, 6646, 13381, 24284, 40801, 64594 };
+      if (a[i] != r[i % 10] + (i / 10 * 10))
+	__builtin_abort ();
+    }
+  return 0;
+}
Index: libstdc++-v3/configure
===================================================================
--- a/src/libstdc++-v3/configure	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/configure	(.../branches/gcc-8-branch)
@@ -638,6 +638,7 @@
 XSL_STYLE_DIR
 XMLLINT
 XSLTPROC
+XMLCATALOG
 DOT
 DOXYGEN
 BUILD_INFO_FALSE
@@ -11608,7 +11609,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11611 "configure"
+#line 11612 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11714,7 +11715,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11717 "configure"
+#line 11718 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -15400,7 +15401,7 @@
   # Fake what AC_TRY_COMPILE does.
 
     cat > conftest.$ac_ext << EOF
-#line 15403 "configure"
+#line 15404 "configure"
 int main()
 {
   typedef bool atomic_type;
@@ -15435,7 +15436,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15438 "configure"
+#line 15439 "configure"
 int main()
 {
   typedef short atomic_type;
@@ -15470,7 +15471,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15473 "configure"
+#line 15474 "configure"
 int main()
 {
   // NB: _Atomic_word not necessarily int.
@@ -15506,7 +15507,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15509 "configure"
+#line 15510 "configure"
 int main()
 {
   typedef long long atomic_type;
@@ -15587,7 +15588,7 @@
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15590 "configure"
+#line 15591 "configure"
 int main()
 {
   _Decimal32 d1;
@@ -15629,7 +15630,7 @@
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15632 "configure"
+#line 15633 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -15663,7 +15664,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15666 "configure"
+#line 15667 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -80857,6 +80858,44 @@
 
 
 # Check for docbook
+# Extract the first word of "xmlcatalog", so it can be a program name with args.
+set dummy xmlcatalog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_XMLCATALOG+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$XMLCATALOG"; then
+  ac_cv_prog_XMLCATALOG="$XMLCATALOG" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_XMLCATALOG="yes"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_prog_XMLCATALOG" && ac_cv_prog_XMLCATALOG="no"
+fi
+fi
+XMLCATALOG=$ac_cv_prog_XMLCATALOG
+if test -n "$XMLCATALOG"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $XMLCATALOG" >&5
+$as_echo "$XMLCATALOG" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
 # Extract the first word of "xsltproc", so it can be a program name with args.
 set dummy xsltproc; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
@@ -80935,31 +80974,28 @@
 
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for docbook stylesheets for documentation creation" >&5
-$as_echo_n "checking for docbook stylesheets for documentation creation... " >&6; }
-glibcxx_stylesheets=no
-if test x${XSLTPROC} = xyes && echo '<title/>' | xsltproc --noout --nonet --xinclude http://docbook.sourceforge.net/release/xsl-ns/current/xhtml-1_1/docbook.xsl - 2>/dev/null; then
-  glibcxx_stylesheets=yes
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_stylesheets" >&5
-$as_echo "$glibcxx_stylesheets" >&6; }
+glibcxx_docbook_url=http://docbook.sourceforge.net/release/xsl-ns/current/
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for local stylesheet directory" >&5
 $as_echo_n "checking for local stylesheet directory... " >&6; }
 glibcxx_local_stylesheets=no
-if test x"$glibcxx_stylesheets" = x"yes"; then
-  if test -d /usr/share/sgml/docbook/xsl-ns-stylesheets; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/sgml/docbook/xsl-ns-stylesheets
-  fi
-  if test -d /usr/share/xml/docbook/stylesheet/docbook-xsl-ns; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/xml/docbook/stylesheet/docbook-xsl-ns
-  fi
-  if test -d /usr/share/xml/docbook/stylesheet/nwalsh5/current; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/xml/docbook/stylesheet/nwalsh5/current
-  fi
+if test x${XMLCATALOG} = xyes && xsl_style_dir=`xmlcatalog "" $glibcxx_docbook_url 2>/dev/null`
+then
+  XSL_STYLE_DIR=`echo $xsl_style_dir | sed -n 's;^file://;;p'`
+  glibcxx_local_stylesheets=yes
+else
+  for dir in \
+    /usr/share/sgml/docbook/xsl-ns-stylesheets \
+    /usr/share/xml/docbook/stylesheet/docbook-xsl-ns \
+    /usr/share/xml/docbook/stylesheet/nwalsh5/current \
+    /usr/share/xml/docbook/stylesheet/nwalsh/current
+  do
+    if test -d $dir; then
+      glibcxx_local_stylesheets=yes
+      XSL_STYLE_DIR=$dir
+      break
+    fi
+  done
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_local_stylesheets" >&5
 $as_echo "$glibcxx_local_stylesheets" >&6; }
@@ -80968,6 +81004,18 @@
 
   { $as_echo "$as_me:${as_lineno-$LINENO}: $XSL_STYLE_DIR" >&5
 $as_echo "$as_me: $XSL_STYLE_DIR" >&6;}
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for docbook stylesheets for documentation creation" >&5
+$as_echo_n "checking for docbook stylesheets for documentation creation... " >&6; }
+  glibcxx_stylesheets=no
+  if test x${XMLCATALOG} = xno || xmlcatalog "" $glibcxx_docbook_url/xhtml/docbook.xsl >/dev/null 2>&1; then
+    if test x${XSLTPROC} = xyes && echo '<title/>' | xsltproc --noout --nonet --xinclude $glibcxx_docbook_url/xhtml/docbook.xsl - 2>/dev/null; then
+      glibcxx_stylesheets=yes
+    fi
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_stylesheets" >&5
+$as_echo "$glibcxx_stylesheets" >&6; }
+
 else
   glibcxx_stylesheets=no
 fi
Index: libstdc++-v3/python/Makefile.in
===================================================================
--- a/src/libstdc++-v3/python/Makefile.in	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/python/Makefile.in	(.../branches/gcc-8-branch)
@@ -235,6 +235,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/Makefile.in
===================================================================
--- a/src/libstdc++-v3/Makefile.in	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/Makefile.in	(.../branches/gcc-8-branch)
@@ -233,6 +233,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/src/c++17/Makefile.in
===================================================================
--- a/src/libstdc++-v3/src/c++17/Makefile.in	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/src/c++17/Makefile.in	(.../branches/gcc-8-branch)
@@ -0,0 +1,754 @@
+# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+subdir = src/c++17
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \
+	$(top_srcdir)/../config/enable.m4 \
+	$(top_srcdir)/../config/futex.m4 \
+	$(top_srcdir)/../config/hwcaps.m4 \
+	$(top_srcdir)/../config/iconv.m4 \
+	$(top_srcdir)/../config/lead-dot.m4 \
+	$(top_srcdir)/../config/lib-ld.m4 \
+	$(top_srcdir)/../config/lib-link.m4 \
+	$(top_srcdir)/../config/lib-prefix.m4 \
+	$(top_srcdir)/../config/lthostflags.m4 \
+	$(top_srcdir)/../config/multi.m4 \
+	$(top_srcdir)/../config/no-executables.m4 \
+	$(top_srcdir)/../config/override.m4 \
+	$(top_srcdir)/../config/stdint.m4 \
+	$(top_srcdir)/../config/unwind_ipinfo.m4 \
+	$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \
+	$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \
+	$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/crossconfig.m4 \
+	$(top_srcdir)/linkage.m4 $(top_srcdir)/acinclude.m4 \
+	$(top_srcdir)/../config/gc++filt.m4 \
+	$(top_srcdir)/../config/tls.m4 $(top_srcdir)/../config/gthr.m4 \
+	$(top_srcdir)/../config/cet.m4 $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libc__17convenience_la_LIBADD =
+@ENABLE_DUAL_ABI_TRUE@am__objects_1 = cow-fs_dir.lo cow-fs_ops.lo \
+@ENABLE_DUAL_ABI_TRUE@	cow-fs_path.lo
+am__objects_2 = fs_dir.lo fs_ops.lo fs_path.lo memory_resource.lo \
+	$(am__objects_1)
+@ENABLE_DUAL_ABI_TRUE@am__objects_3 = cow-string-inst.lo
+@ENABLE_EXTERN_TEMPLATE_TRUE@am__objects_4 = ostream-inst.lo \
+@ENABLE_EXTERN_TEMPLATE_TRUE@	string-inst.lo $(am__objects_3)
+am_libc__17convenience_la_OBJECTS = $(am__objects_2) $(am__objects_4)
+libc__17convenience_la_OBJECTS = $(am_libc__17convenience_la_OBJECTS)
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+AM_V_CXX = $(am__v_CXX_@AM_V@)
+am__v_CXX_ = $(am__v_CXX_@AM_DEFAULT_V@)
+am__v_CXX_0 = @echo "  CXX     " $@;
+am__v_CXX_1 = 
+CXXLD = $(CXX)
+AM_V_CXXLD = $(am__v_CXXLD_@AM_V@)
+am__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)
+am__v_CXXLD_0 = @echo "  CXXLD   " $@;
+am__v_CXXLD_1 = 
+SOURCES = $(libc__17convenience_la_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
+ETAGS = etags
+CTAGS = ctags
+ABI_TWEAKS_SRCDIR = @ABI_TWEAKS_SRCDIR@
+ACLOCAL = @ACLOCAL@
+ALLOCATOR_H = @ALLOCATOR_H@
+ALLOCATOR_NAME = @ALLOCATOR_NAME@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+AR = @AR@
+AS = @AS@
+ATOMICITY_SRCDIR = @ATOMICITY_SRCDIR@
+ATOMIC_FLAGS = @ATOMIC_FLAGS@
+ATOMIC_WORD_SRCDIR = @ATOMIC_WORD_SRCDIR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+BASIC_FILE_CC = @BASIC_FILE_CC@
+BASIC_FILE_H = @BASIC_FILE_H@
+CC = @CC@
+CCODECVT_CC = @CCODECVT_CC@
+CCOLLATE_CC = @CCOLLATE_CC@
+CCTYPE_CC = @CCTYPE_CC@
+CFLAGS = @CFLAGS@
+CLOCALE_CC = @CLOCALE_CC@
+CLOCALE_H = @CLOCALE_H@
+CLOCALE_INTERNAL_H = @CLOCALE_INTERNAL_H@
+CMESSAGES_CC = @CMESSAGES_CC@
+CMESSAGES_H = @CMESSAGES_H@
+CMONEY_CC = @CMONEY_CC@
+CNUMERIC_CC = @CNUMERIC_CC@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPU_DEFINES_SRCDIR = @CPU_DEFINES_SRCDIR@
+CPU_OPT_BITS_RANDOM = @CPU_OPT_BITS_RANDOM@
+CPU_OPT_EXT_RANDOM = @CPU_OPT_EXT_RANDOM@
+CSTDIO_H = @CSTDIO_H@
+CTIME_CC = @CTIME_CC@
+CTIME_H = @CTIME_H@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXFILT = @CXXFILT@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+C_INCLUDE_DIR = @C_INCLUDE_DIR@
+DBLATEX = @DBLATEX@
+DEBUG_FLAGS = @DEBUG_FLAGS@
+DEFS = @DEFS@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+ERROR_CONSTANTS_SRCDIR = @ERROR_CONSTANTS_SRCDIR@
+EXEEXT = @EXEEXT@
+EXTRA_CFLAGS = @EXTRA_CFLAGS@
+EXTRA_CXX_FLAGS = @EXTRA_CXX_FLAGS@
+FGREP = @FGREP@
+GLIBCXX_INCLUDES = @GLIBCXX_INCLUDES@
+GLIBCXX_LIBS = @GLIBCXX_LIBS@
+GREP = @GREP@
+HWCAP_CFLAGS = @HWCAP_CFLAGS@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LONG_DOUBLE_COMPAT_FLAGS = @LONG_DOUBLE_COMPAT_FLAGS@
+LTLIBICONV = @LTLIBICONV@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OPTIMIZE_CXXFLAGS = @OPTIMIZE_CXXFLAGS@
+OPT_LDFLAGS = @OPT_LDFLAGS@
+OS_INC_SRCDIR = @OS_INC_SRCDIR@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PDFLATEX = @PDFLATEX@
+RANLIB = @RANLIB@
+SECTION_FLAGS = @SECTION_FLAGS@
+SECTION_LDFLAGS = @SECTION_LDFLAGS@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+SYMVER_FILE = @SYMVER_FILE@
+TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@
+USE_NLS = @USE_NLS@
+VERSION = @VERSION@
+VTV_CXXFLAGS = @VTV_CXXFLAGS@
+VTV_CXXLINKFLAGS = @VTV_CXXLINKFLAGS@
+VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
+WARN_FLAGS = @WARN_FLAGS@
+XMLCATALOG = @XMLCATALOG@
+XMLLINT = @XMLLINT@
+XSLTPROC = @XSLTPROC@
+XSL_STYLE_DIR = @XSL_STYLE_DIR@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__leading_dot = @am__leading_dot@
+am__tar = @am__tar@
+am__untar = @am__untar@
+baseline_dir = @baseline_dir@
+baseline_subdir_switch = @baseline_subdir_switch@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+check_msgfmt = @check_msgfmt@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_shared = @enable_shared@
+enable_static = @enable_static@
+exec_prefix = @exec_prefix@
+get_gcc_base_ver = @get_gcc_base_ver@
+glibcxx_MOFILES = @glibcxx_MOFILES@
+glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
+glibcxx_POFILES = @glibcxx_POFILES@
+glibcxx_builddir = @glibcxx_builddir@
+glibcxx_compiler_pic_flag = @glibcxx_compiler_pic_flag@
+glibcxx_compiler_shared_flag = @glibcxx_compiler_shared_flag@
+glibcxx_cxx98_abi = @glibcxx_cxx98_abi@
+glibcxx_localedir = @glibcxx_localedir@
+glibcxx_lt_pic_flag = @glibcxx_lt_pic_flag@
+glibcxx_prefixdir = @glibcxx_prefixdir@
+glibcxx_srcdir = @glibcxx_srcdir@
+glibcxx_toolexecdir = @glibcxx_toolexecdir@
+glibcxx_toolexeclibdir = @glibcxx_toolexeclibdir@
+gxx_include_dir = @gxx_include_dir@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+libtool_VERSION = @libtool_VERSION@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_host_flags = @lt_host_flags@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+multi_basedir = @multi_basedir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+port_specific_symbol_files = @port_specific_symbol_files@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+python_mod_dir = @python_mod_dir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+thread_header = @thread_header@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+toplevel_builddir = @toplevel_builddir@
+toplevel_srcdir = @toplevel_srcdir@
+
+# May be used by various substitution variables.
+gcc_version := $(shell @get_gcc_base_ver@ $(top_srcdir)/../gcc/BASE-VER)
+MAINT_CHARSET = latin1
+mkinstalldirs = $(SHELL) $(toplevel_srcdir)/mkinstalldirs
+PWD_COMMAND = $${PWDCMD-pwd}
+STAMP = echo timestamp >
+toolexecdir = $(glibcxx_toolexecdir)
+toolexeclibdir = $(glibcxx_toolexeclibdir)
+@ENABLE_WERROR_FALSE@WERROR_FLAG = 
+@ENABLE_WERROR_TRUE@WERROR_FLAG = -Werror
+@ENABLE_EXTERN_TEMPLATE_FALSE@XTEMPLATE_FLAGS = 
+@ENABLE_EXTERN_TEMPLATE_TRUE@XTEMPLATE_FLAGS = -fno-implicit-templates
+
+# These bits are all figured out from configure.  Look in acinclude.m4
+# or configure.ac to see how they are set.  See GLIBCXX_EXPORT_FLAGS.
+CONFIG_CXXFLAGS = \
+	$(SECTION_FLAGS) $(HWCAP_CFLAGS) -frandom-seed=$@
+
+WARN_CXXFLAGS = \
+	$(WARN_FLAGS) $(WERROR_FLAG) -fdiagnostics-show-location=once 
+
+
+# -I/-D flags to pass when compiling.
+AM_CPPFLAGS = $(GLIBCXX_INCLUDES) $(CPPFLAGS)
+
+# Convenience library for C++17 runtime.
+noinst_LTLIBRARIES = libc++17convenience.la
+headers = 
+@ENABLE_DUAL_ABI_FALSE@extra_string_inst_sources = 
+@ENABLE_DUAL_ABI_TRUE@extra_string_inst_sources = cow-string-inst.cc
+@ENABLE_DUAL_ABI_FALSE@extra_fs_sources = 
+@ENABLE_DUAL_ABI_TRUE@extra_fs_sources = \
+@ENABLE_DUAL_ABI_TRUE@	cow-fs_dir.cc \
+@ENABLE_DUAL_ABI_TRUE@	cow-fs_ops.cc \
+@ENABLE_DUAL_ABI_TRUE@	cow-fs_path.cc
+
+# XTEMPLATE_FLAGS =
+@ENABLE_EXTERN_TEMPLATE_FALSE@inst_sources = 
+
+# XTEMPLATE_FLAGS = -fno-implicit-templates
+@ENABLE_EXTERN_TEMPLATE_TRUE@inst_sources = \
+@ENABLE_EXTERN_TEMPLATE_TRUE@	ostream-inst.cc \
+@ENABLE_EXTERN_TEMPLATE_TRUE@	string-inst.cc \
+@ENABLE_EXTERN_TEMPLATE_TRUE@	$(extra_string_inst_sources)
+
+sources = \
+	fs_dir.cc \
+	fs_ops.cc \
+	fs_path.cc \
+	memory_resource.cc \
+	$(extra_fs_sources)
+
+libc__17convenience_la_SOURCES = $(sources)  $(inst_sources)
+
+# AM_CXXFLAGS needs to be in each subdirectory so that it can be
+# modified in a per-library or per-sub-library way.  Need to manually
+# set this option because CONFIG_CXXFLAGS has to be after
+# OPTIMIZE_CXXFLAGS on the compile line so that -O2 can be overridden
+# as the occasion calls for it.
+AM_CXXFLAGS = \
+	-std=gnu++17 \
+	$(glibcxx_lt_pic_flag) $(glibcxx_compiler_shared_flag) \
+	$(XTEMPLATE_FLAGS) $(VTV_CXXFLAGS) \
+	$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS) $(CONFIG_CXXFLAGS) \
+	-fimplicit-templates
+
+AM_MAKEFLAGS = \
+	"gxx_include_dir=$(gxx_include_dir)"
+
+
+# Libtool notes
+
+# 1) In general, libtool expects an argument such as `--tag=CXX' when
+# using the C++ compiler, because that will enable the settings
+# detected when C++ support was being configured.  However, when no
+# such flag is given in the command line, libtool attempts to figure
+# it out by matching the compiler name in each configuration section
+# against a prefix of the command line.  The problem is that, if the
+# compiler name and its initial flags stored in the libtool
+# configuration file don't match those in the command line, libtool
+# can't decide which configuration to use, and it gives up.  The
+# correct solution is to add `--tag CXX' to LTCXXCOMPILE and maybe
+# CXXLINK, just after $(LIBTOOL), so that libtool doesn't have to
+# attempt to infer which configuration to use.
+#
+# The second tag argument, `--tag disable-shared` means that libtool
+# only compiles each source once, for static objects. In actuality,
+# glibcxx_lt_pic_flag and glibcxx_compiler_shared_flag are added to
+# the libtool command that is used create the object, which is
+# suitable for shared libraries.  The `--tag disable-shared` must be
+# placed after --tag CXX lest things CXX undo the affect of
+# disable-shared.
+
+# 2) Need to explicitly set LTCXXCOMPILE so that EXTRA_CXX_FLAGS is
+# last. (That way, things like -O2 passed down from the toplevel can
+# be overridden by --enable-debug.)
+LTCXXCOMPILE = \
+	$(LIBTOOL) --tag CXX --tag disable-shared \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CXX) $(TOPLEVEL_INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) $(EXTRA_CXX_FLAGS)
+
+LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))
+
+# 3) We'd have a problem when building the shared libstdc++ object if
+# the rules automake generates would be used.  We cannot allow g++ to
+# be used since this would add -lstdc++ to the link line which of
+# course is problematic at this point.  So, we get the top-level
+# directory to configure libstdc++-v3 to use gcc as the C++
+# compilation driver.
+CXXLINK = \
+	$(LIBTOOL) --tag CXX --tag disable-shared \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CXX) \
+	$(VTV_CXXLINKFLAGS) \
+	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .cc .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/fragment.am $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign --ignore-deps src/c++17/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign --ignore-deps src/c++17/Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+$(top_srcdir)/fragment.am $(am__empty):
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; \
+	locs=`for p in $$list; do echo $$p; done | \
+	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
+	      sort -u`; \
+	test -z "$$locs" || { \
+	  echo rm -f $${locs}; \
+	  rm -f $${locs}; \
+	}
+
+libc++17convenience.la: $(libc__17convenience_la_OBJECTS) $(libc__17convenience_la_DEPENDENCIES) $(EXTRA_libc__17convenience_la_DEPENDENCIES) 
+	$(AM_V_CXXLD)$(CXXLINK)  $(libc__17convenience_la_OBJECTS) $(libc__17convenience_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+.cc.o:
+	$(AM_V_CXX)$(CXXCOMPILE) -c -o $@ $<
+
+.cc.obj:
+	$(AM_V_CXX)$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+.cc.lo:
+	$(AM_V_CXX)$(LTCXXCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
+
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	set x; \
+	here=`pwd`; \
+	$(am__define_uniq_tagged_files); \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES cscopelist-am ctags \
+	ctags-am distclean distclean-compile distclean-generic \
+	distclean-libtool distclean-tags dvi dvi-am html html-am info \
+	info-am install install-am install-data install-data-am \
+	install-dvi install-dvi-am install-exec install-exec-am \
+	install-html install-html-am install-info install-info-am \
+	install-man install-pdf install-pdf-am install-ps \
+	install-ps-am install-strip installcheck installcheck-am \
+	installdirs maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
+	uninstall-am
+
+.PRECIOUS: Makefile
+
+
+vpath % $(top_srcdir)/src/c++17
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: libstdc++-v3/src/Makefile.in
===================================================================
--- a/src/libstdc++-v3/src/Makefile.in	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/src/Makefile.in	(.../branches/gcc-8-branch)
@@ -268,6 +268,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/src/filesystem/path.cc
===================================================================
--- a/src/libstdc++-v3/src/filesystem/path.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/src/filesystem/path.cc	(.../branches/gcc-8-branch)
@@ -334,6 +334,28 @@
   if (_M_pathname.empty())
     return;
 
+  {
+    // Approximate count of components, to reserve space in _M_cmpts vector:
+    int count = 1;
+    bool saw_sep_last = _S_is_dir_sep(_M_pathname[0]);
+    bool saw_non_sep = !saw_sep_last;
+    for (value_type c : _M_pathname)
+      {
+	if (_S_is_dir_sep(c))
+	  saw_sep_last = true;
+	else if (saw_sep_last)
+	  {
+	    ++count;
+	    saw_sep_last = false;
+	    saw_non_sep = true;
+	  }
+      }
+    if (saw_non_sep && saw_sep_last)
+      ++count; // empty filename after trailing slash
+    if (count > 1)
+      _M_cmpts.reserve(count);
+  }
+
   size_t pos = 0;
   const size_t len = _M_pathname.size();
 
@@ -356,9 +378,13 @@
 	      pos = 3;
 	      while (pos < len && !_S_is_dir_sep(_M_pathname[pos]))
 		++pos;
+	      if (pos == len)
+		{
+		  _M_type = _Type::_Root_name;
+		  return;
+		}
 	      _M_add_root_name(pos);
-	      if (pos < len) // also got root directory
-		_M_add_root_dir(pos);
+	      _M_add_root_dir(pos);
 	    }
 	  else
 	    {
@@ -367,6 +393,11 @@
 	      _M_add_root_dir(0);
 	    }
 	}
+      else if (len == 1) // got root directory only
+	{
+	  _M_type = _Type::_Root_dir;
+	  return;
+	}
       else // got root directory
 	_M_add_root_dir(0);
       ++pos;
@@ -375,6 +406,11 @@
   else if (len > 1 && _M_pathname[1] == L':')
     {
       // got disk designator
+      if (len == 2)
+	{
+	  _M_type = _Type::_Root_name;
+	  return;
+	}
       _M_add_root_name(2);
       if (len > 2 && _S_is_dir_sep(_M_pathname[2]))
 	_M_add_root_dir(2);
@@ -381,6 +417,17 @@
       pos = 2;
     }
 #endif
+  else
+    {
+      size_t n = 1;
+      for (; n < _M_pathname.size() && !_S_is_dir_sep(_M_pathname[n]); ++n)
+	{ }
+      if (n == _M_pathname.size())
+	{
+	  _M_type = _Type::_Filename;
+	  return;
+	}
+    }
 
   size_t back = pos;
   while (pos < len)
Index: libstdc++-v3/src/filesystem/Makefile.in
===================================================================
--- a/src/libstdc++-v3/src/filesystem/Makefile.in	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/src/filesystem/Makefile.in	(.../branches/gcc-8-branch)
@@ -249,6 +249,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/src/filesystem/std-dir.cc
===================================================================
--- a/src/libstdc++-v3/src/filesystem/std-dir.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/src/filesystem/std-dir.cc	(.../branches/gcc-8-branch)
@@ -57,7 +57,13 @@
   {
     if (const auto entp = _Dir_base::advance(skip_permission_denied, ec))
       {
-	entry = fs::directory_entry{path / entp->d_name, get_file_type(*entp)};
+	file_type type = file_type::none;
+#ifdef _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE
+	// Even if the OS supports dirent::d_type the filesystem might not:
+	if (entp->d_type != DT_UNKNOWN)
+	  type = get_file_type(*entp);
+#endif
+	entry = fs::directory_entry{path / entp->d_name, type};
 	return true;
       }
     else if (!ec)
Index: libstdc++-v3/src/filesystem/std-path.cc
===================================================================
--- a/src/libstdc++-v3/src/filesystem/std-path.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/src/filesystem/std-path.cc	(.../branches/gcc-8-branch)
@@ -539,6 +539,28 @@
     }
   _M_type = _Type::_Multi;
 
+  {
+    // Approximate count of components, to reserve space in _M_cmpts vector:
+    int count = 1;
+    bool saw_sep_last = _S_is_dir_sep(_M_pathname[0]);
+    bool saw_non_sep = !saw_sep_last;
+    for (value_type c : _M_pathname)
+      {
+	if (_S_is_dir_sep(c))
+	  saw_sep_last = true;
+	else if (saw_sep_last)
+	  {
+	    ++count;
+	    saw_sep_last = false;
+	    saw_non_sep = true;
+	  }
+      }
+    if (saw_non_sep && saw_sep_last)
+      ++count; // empty filename after trailing slash
+    if (count > 1)
+      _M_cmpts.reserve(count);
+  }
+
   size_t pos = 0;
   const size_t len = _M_pathname.size();
 
@@ -555,9 +577,13 @@
 	      pos = 3;
 	      while (pos < len && !_S_is_dir_sep(_M_pathname[pos]))
 		++pos;
+	      if (pos == len)
+		{
+		  _M_type = _Type::_Root_name;
+		  return;
+		}
 	      _M_add_root_name(pos);
-	      if (pos < len) // also got root directory
-		_M_add_root_dir(pos);
+	      _M_add_root_dir(pos);
 	    }
 	  else
 	    {
@@ -584,6 +610,11 @@
   else if (len > 1 && _M_pathname[1] == L':')
     {
       // got disk designator
+      if (len == 2)
+	{
+	  _M_type = _Type::_Root_name;
+	  return;
+	}
       _M_add_root_name(2);
       if (len > 2 && _S_is_dir_sep(_M_pathname[2]))
 	_M_add_root_dir(2);
@@ -590,6 +621,17 @@
       pos = 2;
     }
 #endif
+  else
+    {
+      size_t n = 1;
+      for (; n < _M_pathname.size() && !_S_is_dir_sep(_M_pathname[n]); ++n)
+	{ }
+      if (n == _M_pathname.size())
+	{
+	  _M_type = _Type::_Filename;
+	  return;
+	}
+    }
 
   size_t back = pos;
   while (pos < len)
Index: libstdc++-v3/src/filesystem/std-ops.cc
===================================================================
--- a/src/libstdc++-v3/src/filesystem/std-ops.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/src/filesystem/std-ops.cc	(.../branches/gcc-8-branch)
@@ -77,6 +77,9 @@
 	std::make_error_code(errc::not_supported)));
   return ret;
 #else
+  if (p.empty())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot make absolute path", p,
+	  make_error_code(std::errc::invalid_argument)));
   return current_path() / p;
 #endif
 }
@@ -87,7 +90,7 @@
   path ret;
   if (p.empty())
     {
-      ec = make_error_code(std::errc::no_such_file_or_directory);
+      ec = make_error_code(std::errc::invalid_argument);
       return ret;
     }
   if (p.is_absolute())
Index: libstdc++-v3/src/c++98/Makefile.in
===================================================================
--- a/src/libstdc++-v3/src/c++98/Makefile.in	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/src/c++98/Makefile.in	(.../branches/gcc-8-branch)
@@ -239,6 +239,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/src/c++11/Makefile.in
===================================================================
--- a/src/libstdc++-v3/src/c++11/Makefile.in	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/src/c++11/Makefile.in	(.../branches/gcc-8-branch)
@@ -243,6 +243,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/configure.ac
===================================================================
--- a/src/libstdc++-v3/configure.ac	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/configure.ac	(.../branches/gcc-8-branch)
@@ -442,6 +442,7 @@
 AC_CHECK_PROG([DOT], dot, yes, no)
 
 # Check for docbook
+AC_CHECK_PROG([XMLCATALOG], xmlcatalog, yes, no)
 AC_CHECK_PROG([XSLTPROC], xsltproc, yes, no)
 AC_CHECK_PROG([XMLLINT], xmllint, yes, no)
 GLIBCXX_CONFIGURE_DOCBOOK
Index: libstdc++-v3/doc/xml/faq.xml
===================================================================
--- a/src/libstdc++-v3/doc/xml/faq.xml	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/doc/xml/faq.xml	(.../branches/gcc-8-branch)
@@ -1001,21 +1001,31 @@
 <qandaentry xml:id="faq.memory_leaks">
   <question xml:id="q-memory_leaks">
     <para>
-      <quote>Memory leaks</quote> in containers
+      <quote>Memory leaks</quote> in libstdc++
     </para>
   </question>
   <answer xml:id="a-memory_leaks">
-    <note>
-      <para>This answer is old and probably no longer be relevant.</para>
-    </note>
     <para>
-    A few people have reported that the standard containers appear
+    Since GCC 5.1.0, libstdc++ automatically allocates a pool
+    of a few dozen kilobytes on startup. This pool is used to ensure it's
+    possible to throw exceptions (such as <classname>bad_alloc</classname>)
+    even when <code>malloc</code> is unable to allocate any more memory.
+    With some versions of <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://valgrind.org/"><command>valgrind</command></link>
+    this pool will be shown as "still reachable" when the process exits, e.g.
+    <code>still reachable: 72,704 bytes in 1 blocks</code>.
+    This memory is not a leak, because it's still in use by libstdc++,
+    and the memory will be returned to the OS when the process exits.
+    Later versions of <command>valgrind</command> know how to free this
+    pool as the process exits, and so won't show any "still reachable" memory.
+    </para>
+    <para>
+    In the past, a few people reported that the standard containers appear
     to leak memory when tested with memory checkers such as
     <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://valgrind.org/"><command>valgrind</command></link>.
     Under some (non-default) configurations the library's allocators keep
     free memory in a
-    pool for later reuse, rather than returning it to the OS.  Although
-    this memory is always reachable by the library and is never
+    pool for later reuse, rather than deallocating it with <code>delete</code>
+    Although this memory is always reachable by the library and is never
     lost, memory debugging tools can report it as a leak.  If you
     want to test the library for memory leaks please read
     <link linkend="debug.memory">Tips for memory leak hunting</link>
Index: libstdc++-v3/doc/xml/manual/intro.xml
===================================================================
--- a/src/libstdc++-v3/doc/xml/manual/intro.xml	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/doc/xml/manual/intro.xml	(.../branches/gcc-8-branch)
@@ -1105,6 +1105,14 @@
     ill-formed.
     </para></listitem></varlistentry>
 
+    <varlistentry xml:id="manual.bugs.dr2537"><term><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="&DR;#2537">2537</link>:
+       <emphasis>Constructors for <code>priority_queue</code> taking allocators
+	 should call <code>make_heap</code>
+       </emphasis>
+    </term>
+    <listitem><para>Call <code>make_heap</code>.
+    </para></listitem></varlistentry>
+
     <varlistentry xml:id="manual.bugs.dr2583"><term><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="&DR;#2583">2583</link>:
        <emphasis>There is no way to supply an allocator for <code>basic_string(str, pos)</code>
        </emphasis>
@@ -1112,6 +1120,14 @@
     <listitem><para>Add new constructor
     </para></listitem></varlistentry>
 
+    <varlistentry xml:id="manual.bugs.dr2586"><term><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="&DR;#2586">2586</link>:
+       <emphasis>Wrong value category used in <code>scoped_allocator_adaptor::construct()</code>
+       </emphasis>
+    </term>
+    <listitem><para>Change internal helper for uses-allocator construction
+      to always check using const lvalue allocators.
+    </para></listitem></varlistentry>
+
     <varlistentry xml:id="manual.bugs.dr2684"><term><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="&DR;#2684">2684</link>:
        <emphasis><code>priority_queue</code> lacking comparator typedef
        </emphasis>
Index: libstdc++-v3/doc/xml/manual/status_cxx2017.xml
===================================================================
--- a/src/libstdc++-v3/doc/xml/manual/status_cxx2017.xml	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/doc/xml/manual/status_cxx2017.xml	(.../branches/gcc-8-branch)
@@ -382,7 +382,7 @@
 	</link>
       </entry>
       <entry align="center"> 7.1 </entry>
-      <entry><code> </code></entry>
+      <entry><code>__cpp_lib_raw_memory_algorithms &gt;= 201606L</code></entry>
     </row>
 
     <row>
@@ -788,7 +788,32 @@
              <code> __cpp_lib_to_chars >= 201611 </code></entry>
     </row>
 
+    <row>
+      <entry> Homogeneous interface for variant, any and optional </entry>
+      <entry>
+	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0032r3.pdf">
+	P0032R3
+	</link>
+      </entry>
+      <entry align="center"> 7.1  </entry>
+      <entry>
+             <code> __cpp_lib_any >= 201606 </code>,
+             <code> __cpp_lib_optional >= 201606 </code>,
+             <code> __cpp_lib_variant >= 201606 </code>
+      </entry>
+    </row>
 
+    <row>
+      <entry> Making Optional Greater Equal Again </entry>
+      <entry>
+	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0307r2.pdf">
+	P0307R2
+	</link>
+      </entry>
+      <entry align="center"> 7.1  </entry>
+      <entry> <code> __cpp_lib_optional >= 201606 </code> </entry>
+    </row>
+
   </tbody>
 </tgroup>
 </table>
@@ -1049,7 +1074,7 @@
    <para>
       <emphasis>30.10.2.1 [fs.conform.9945]</emphasis>
       The behavior of the filesystem library implementation will depend on
-      the target operating system. Some features will not be not supported
+      the target operating system. Some features will not be supported
       on some targets.
    </para>
 
Index: libstdc++-v3/doc/xml/manual/evolution.xml
===================================================================
--- a/src/libstdc++-v3/doc/xml/manual/evolution.xml	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/doc/xml/manual/evolution.xml	(.../branches/gcc-8-branch)
@@ -80,11 +80,12 @@
 
    <para> For GCC releases from 2.95 through the 3.1 series, defining
    <literal>__USE_MALLOC</literal> on the gcc command line would change the
-   default allocation strategy to instead use <code> malloc</code> and
-   <function>free</function>. For the 3.2 and 3.3 release series the same
+   default allocation strategy to instead use <code>malloc</code> and
+   <code>free</code>. For the 3.2 and 3.3 release series the same
    functionality was spelled <literal>_GLIBCXX_FORCE_NEW</literal>. From
-   GCC 3.4 onwards the functionality is enabled by setting
-   <literal>GLIBCXX_FORCE_NEW</literal> in the environment, see
+   GCC 3.4 onwards the default allocator uses <code>new</code> anyway,
+   but for the optional pooling allocators the functionality is enabled by
+   setting <literal>GLIBCXX_FORCE_NEW</literal> in the environment, see
    <link linkend="manual.ext.allocator.mt">the mt allocator chapter</link>
    for details.
    </para>
Index: libstdc++-v3/doc/xml/manual/using.xml
===================================================================
--- a/src/libstdc++-v3/doc/xml/manual/using.xml	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/doc/xml/manual/using.xml	(.../branches/gcc-8-branch)
@@ -1130,8 +1130,8 @@
         enabled for
         <classname>std::vector&lt;T, std::allocator&lt;T&gt;&gt;</classname>
         and only when <classname>std::allocator</classname> is derived from
-        <xref linkend="allocator.impl"><classname>new_allocator</classname>
-        or <classname>malloc_allocator</classname></xref>. The annotations
+        <link linkend="allocator.impl"><classname>new_allocator</classname>
+        or <classname>malloc_allocator</classname></link>. The annotations
         must be present on all vector operations or none, so this macro must
         be defined to the same value for all translation units that create,
         destroy or modify vectors.
Index: libstdc++-v3/doc/xml/manual/debug.xml
===================================================================
--- a/src/libstdc++-v3/doc/xml/manual/debug.xml	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/doc/xml/manual/debug.xml	(.../branches/gcc-8-branch)
@@ -94,50 +94,35 @@
 
 <section xml:id="debug.memory"><info><title>Memory Leak Hunting</title></info>
 
+<para>
+  On many targets GCC supports AddressSanitizer, a fast memory error detector,
+  which is enabled by the <option>-fsanitize=address</option> option.
+</para>
 
 <para>
-  There are various third party memory tracing and debug utilities
+  There are also various third party memory tracing and debug utilities
   that can be used to provide detailed memory allocation information
   about C++ code. An exhaustive list of tools is not going to be
   attempted, but includes <code>mtrace</code>, <code>valgrind</code>,
-  <code>mudflap</code>, and the non-free commercial product
-  <code>purify</code>. In addition, <code>libcwd</code> has a
-  replacement for the global new and delete operators that can track
-  memory allocation and deallocation and provide useful memory
-  statistics.
+  <code>mudflap</code> (no longer supported since GCC 4.9.0), ElectricFence,
+  and the non-free commercial product <code>purify</code>.
+  In addition, <code>libcwd</code>, jemalloc and TCMalloc have replacements
+  for the global <code>new</code> and <code>delete</code> operators
+  that can track memory allocation and deallocation and provide useful
+  memory statistics.
 </para>
 
 <para>
-  Regardless of the memory debugging tool being used, there is one
-  thing of great importance to keep in mind when debugging C++ code
-  that uses <code>new</code> and <code>delete</code>: there are
-  different kinds of allocation schemes that can be used by <code>
-  std::allocator</code>. For implementation details, see the <link linkend="manual.ext.allocator.mt">mt allocator</link> documentation and
-  look specifically for <code>GLIBCXX_FORCE_NEW</code>.
-</para>
-
-<para>
-  In a nutshell, the optional <classname>mt_allocator</classname>
-  is a high-performance pool allocator, and can
-  give the mistaken impression that in a suspect executable, memory is
-  being leaked, when in reality the memory "leak" is a pool being used
-  by the library's allocator and is reclaimed after program
-  termination.
-</para>
-
-<para>
   For valgrind, there are some specific items to keep in mind. First
   of all, use a version of valgrind that will work with current GNU
   C++ tools: the first that can do this is valgrind 1.0.4, but later
-  versions should work at least as well. Second of all, use a
-  completely unoptimized build to avoid confusing valgrind. Third, use
-  GLIBCXX_FORCE_NEW to keep extraneous pool allocation noise from
-  cluttering debug information.
+  versions should work better. Second, using an unoptimized build
+  might avoid confusing valgrind.
 </para>
 
 <para>
-  Fourth, it may be necessary to force deallocation in other libraries
-  as well, namely the "C" library. On linux, this can be accomplished
+  Third, it may be necessary to force deallocation in other libraries
+  as well, namely the "C" library. On GNU/Linux, this can be accomplished
   with the appropriate use of the <code>__cxa_atexit</code> or
   <code>atexit</code> functions.
 </para>
@@ -157,7 +142,6 @@
    }
 </programlisting>
 
-
 <para>or, using <code>__cxa_atexit</code>:</para>
 
 <programlisting>
@@ -184,8 +168,41 @@
    valgrind -v --num-callers=20 --leak-check=yes --leak-resolution=high --show-reachable=yes a.out
 </programlisting>
 
+<section xml:id="debug.memory.mtalloc">
+<info><title>Non-memory leaks in Pool and MT allocators</title></info>
+
+<para>
+  There are different kinds of allocation schemes that can be used by
+  <code>std::allocator</code>. Prior to GCC 3.4.0 the default was to use
+  a pooling allocator, <classname>pool_allocator</classname>,
+  which is still available as the optional
+  <classname>__pool_alloc</classname> extension.
+  Another optional extension, <classname>__mt_alloc</classname>,
+  is a high-performance pool allocator.
+</para>
+
+<para>
+  In a suspect executable these pooling allocators can give
+  the mistaken impression that memory is being leaked,
+  when in reality the memory "leak" is a pool being used
+  by the library's allocator and is reclaimed after program
+  termination.
+</para>
+
+<para>
+  If you're using memory debugging tools on a program that uses
+  one of these pooling allocators, you can set the environment variable
+  <literal>GLIBCXX_FORCE_NEW</literal> to keep extraneous pool allocation
+  noise from cluttering debug information.
+  For more details, see the
+  <link linkend="manual.ext.allocator.mt">mt allocator</link>
+  documentation and look specifically for <code>GLIBCXX_FORCE_NEW</code>.
+</para>
+
 </section>
 
+</section>
+
 <section xml:id="debug.races"><info><title>Data Race Hunting</title></info>
 <para>
   All synchronization primitives used in the library internals need to be
Index: libstdc++-v3/doc/Makefile.in
===================================================================
--- a/src/libstdc++-v3/doc/Makefile.in	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/doc/Makefile.in	(.../branches/gcc-8-branch)
@@ -205,6 +205,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 
 # Validate existing XML structure.
 XMLLINT = xmllint
Index: libstdc++-v3/doc/html/faq.html
===================================================================
--- a/src/libstdc++-v3/doc/html/faq.html	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/doc/html/faq.html	(.../branches/gcc-8-branch)
@@ -70,7 +70,7 @@
       Program crashes when using library code in a
       dynamically-loaded library
     </a></dt><dt>6.7. <a href="faq.html#faq.memory_leaks">
-      Memory leaks in containers
+      Memory leaks in libstdc++
     </a></dt><dt>6.8. <a href="faq.html#faq.list_size_on">
       list::size() is O(n)!
     </a></dt><dt>6.9. <a href="faq.html#faq.easy_to_fix">
@@ -593,7 +593,7 @@
       Program crashes when using library code in a
       dynamically-loaded library
     </a></dt><dt>6.7. <a href="faq.html#faq.memory_leaks">
-      Memory leaks in containers
+      Memory leaks in libstdc++
     </a></dt><dt>6.8. <a href="faq.html#faq.list_size_on">
       list::size() is O(n)!
     </a></dt><dt>6.9. <a href="faq.html#faq.easy_to_fix">
@@ -708,15 +708,27 @@
 Linktheexecutable:<br />
 <span class="command"><strong>g++-fPIC-rdynamic-ofoo...-L.-lfoo-ldl</strong></span><br />
 </p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="faq.memory_leaks"></a><a id="q-memory_leaks"></a><p><strong>6.7.</strong></p></td><td align="left" valign="top"><p>
-      <span class="quote"><span class="quote">Memory leaks</span></span> in containers
-    </p></td></tr><tr class="answer"><td align="left" valign="top"><a id="a-memory_leaks"></a></td><td align="left" valign="top"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This answer is old and probably no longer be relevant.</p></div><p>
-    A few people have reported that the standard containers appear
+      <span class="quote"><span class="quote">Memory leaks</span></span> in libstdc++
+    </p></td></tr><tr class="answer"><td align="left" valign="top"><a id="a-memory_leaks"></a></td><td align="left" valign="top"><p>
+    Since GCC 5.1.0, libstdc++ automatically allocates a pool
+    of a few dozen kilobytes on startup. This pool is used to ensure it's
+    possible to throw exceptions (such as <code class="classname">bad_alloc</code>)
+    even when <code class="code">malloc</code> is unable to allocate any more memory.
+    With some versions of <a class="link" href="http://valgrind.org/" target="_top"><span class="command"><strong>valgrind</strong></span></a>
+    this pool will be shown as "still reachable" when the process exits, e.g.
+    <code class="code">still reachable: 72,704 bytes in 1 blocks</code>.
+    This memory is not a leak, because it's still in use by libstdc++,
+    and the memory will be returned to the OS when the process exits.
+    Later versions of <span class="command"><strong>valgrind</strong></span> know how to free this
+    pool as the process exits, and so won't show any "still reachable" memory.
+    </p><p>
+    In the past, a few people reported that the standard containers appear
     to leak memory when tested with memory checkers such as
     <a class="link" href="http://valgrind.org/" target="_top"><span class="command"><strong>valgrind</strong></span></a>.
     Under some (non-default) configurations the library's allocators keep
     free memory in a
-    pool for later reuse, rather than returning it to the OS.  Although
-    this memory is always reachable by the library and is never
+    pool for later reuse, rather than deallocating it with <code class="code">delete</code>
+    Although this memory is always reachable by the library and is never
     lost, memory debugging tools can report it as a leak.  If you
     want to test the library for memory leaks please read
     <a class="link" href="manual/debug.html#debug.memory" title="Memory Leak Hunting">Tips for memory leak hunting</a>
Index: libstdc++-v3/doc/html/index.html
===================================================================
--- a/src/libstdc++-v3/doc/html/index.html	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/doc/html/index.html	(.../branches/gcc-8-branch)
@@ -23,7 +23,7 @@
     </p></div></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="book"><a href="manual/index.html">The GNU C++ Library Manual</a></span></dt><dd><dl><dt><span class="part"><a href="manual/intro.html">I. 
   Introduction
   
-</a></span></dt><dd><dl><dt><span class="chapter"><a href="manual/status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="manual/status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2014">C++ 2014</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="manual/bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="manual/setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="manual/setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/configure.html">Configure</a></span></dt><dt><span class="section"><a href="manual/make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="manual/using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="manual/using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="manual/using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="manual/debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="manual/std_contents.html">II. 
+</a></span></dt><dd><dl><dt><span class="chapter"><a href="manual/status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="manual/status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2014">C++ 2014</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="manual/bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="manual/setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="manual/setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/configure.html">Configure</a></span></dt><dt><span class="section"><a href="manual/make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="manual/using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="manual/using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="manual/using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="manual/debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="manual/debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="manual/debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="manual/std_contents.html">II. 
     Standard Contents
   </a></span></dt><dd><dl><dt><span class="chapter"><a href="manual/support.html">4. 
   Support
Index: libstdc++-v3/doc/html/manual/status.html
===================================================================
--- a/src/libstdc++-v3/doc/html/manual/status.html	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/doc/html/manual/status.html	(.../branches/gcc-8-branch)
@@ -665,7 +665,7 @@
 	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0040r3.html" target="_top">
 	P0040R3
 	</a>
-      </td><td align="center"> 7.1 </td><td align="left"><code class="code"> </code></td></tr><tr><td align="left"> <code class="code">shared_ptr::weak_type</code></td><td align="left">
+      </td><td align="center"> 7.1 </td><td align="left"><code class="code">__cpp_lib_raw_memory_algorithms &gt;= 201606L</code></td></tr><tr><td align="left"> <code class="code">shared_ptr::weak_type</code></td><td align="left">
 	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0163r0.html" target="_top">
 	P0163R0
 	</a>
@@ -821,7 +821,19 @@
 	P0067R5
 	</a>
       </td><td align="center"> 8 (only integral types supported) </td><td align="left"><code class="code"> __has_include(&lt;charconv&gt;) </code>
-             <code class="code"> __cpp_lib_to_chars &gt;= 201611 </code></td></tr></tbody></table></div></div><br class="table-break" /><p>
+             <code class="code"> __cpp_lib_to_chars &gt;= 201611 </code></td></tr><tr><td align="left"> Homogeneous interface for variant, any and optional </td><td align="left">
+	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0032r3.pdf" target="_top">
+	P0032R3
+	</a>
+      </td><td align="center"> 7.1  </td><td align="left">
+             <code class="code"> __cpp_lib_any &gt;= 201606 </code>,
+             <code class="code"> __cpp_lib_optional &gt;= 201606 </code>,
+             <code class="code"> __cpp_lib_variant &gt;= 201606 </code>
+      </td></tr><tr><td align="left"> Making Optional Greater Equal Again </td><td align="left">
+	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0307r2.pdf" target="_top">
+	P0307R2
+	</a>
+      </td><td align="center"> 7.1  </td><td align="left"> <code class="code"> __cpp_lib_optional &gt;= 201606 </code> </td></tr></tbody></table></div></div><br class="table-break" /><p>
 Note 1: This feature is supported in GCC 7.1 and 7.2 but before GCC 7.3 the
 <code class="code">__cpp_lib</code> macro is not defined, and compilation will fail if the
 header is included without using <code class="option">-std</code> to enable C++17 support.
@@ -939,7 +951,7 @@
    </p><p>
       <span class="emphasis"><em>30.10.2.1 [fs.conform.9945]</em></span>
       The behavior of the filesystem library implementation will depend on
-      the target operating system. Some features will not be not supported
+      the target operating system. Some features will not be supported
       on some targets.
    </p><p>
       <span class="emphasis"><em>30.10.5 [fs.filesystem.syn]</em></span>
Index: libstdc++-v3/doc/html/manual/using.html
===================================================================
--- a/src/libstdc++-v3/doc/html/manual/using.html	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/doc/html/manual/using.html	(.../branches/gcc-8-branch)
@@ -2,7 +2,7 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter3.Using</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, library" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="intro.html" title="PartI. Introduction" /><link rel="prev" href="make.html" title="Make" /><link rel="next" href="using_headers.html" title="Headers" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter3.Using</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="make.html">Prev</a></td><th width="60%" align="center">PartI.
   Introduction
   
-</th><td width="20%" align="right"><a accesskey="n" href="using_headers.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="manual.intro.using"></a>Chapter3.Using</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="manual.intro.using.flags"></a>Command Options</h2></div></div></div><p>
+</th><td width="20%" align="right"><a accesskey="n" href="using_headers.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="manual.intro.using"></a>Chapter3.Using</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="manual.intro.using.flags"></a>Command Options</h2></div></div></div><p>
       The set of features available in the GNU C++ library is shaped by
       several <a class="link" href="http://gcc.gnu.org/onlinedocs/gcc-4.3.2/gcc/Invoking-GCC.html" target="_top">GCC
       Command Options</a>. Options that impact libstdc++ are
Index: libstdc++-v3/doc/html/manual/using_macros.html
===================================================================
--- a/src/libstdc++-v3/doc/html/manual/using_macros.html	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/doc/html/manual/using_macros.html	(.../branches/gcc-8-branch)
@@ -116,7 +116,8 @@
         enabled for
         <code class="classname">std::vector&lt;T, std::allocator&lt;T&gt;&gt;</code>
         and only when <code class="classname">std::allocator</code> is derived from
-        <a class="xref" href="memory.html#allocator.impl" title="Implementation">the section called Implementation</a>. The annotations
+        <a class="link" href="memory.html#allocator.impl" title="Implementation"><code class="classname">new_allocator</code>
+        or <code class="classname">malloc_allocator</code></a>. The annotations
         must be present on all vector operations or none, so this macro must
         be defined to the same value for all translation units that create,
         destroy or modify vectors.
Index: libstdc++-v3/doc/html/manual/intro.html
===================================================================
--- a/src/libstdc++-v3/doc/html/manual/intro.html	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/doc/html/manual/intro.html	(.../branches/gcc-8-branch)
@@ -5,4 +5,4 @@
 </th></tr><tr><td width="20%" align="left"><a accesskey="p" href="index.html">Prev</a></td><th width="60%" align="center">The GNU C++ Library Manual</th><td width="20%" align="right"><a accesskey="n" href="status.html">Next</a></td></tr></table><hr /></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="manual.intro"></a>PartI.
   Introduction
   <a id="id-1.3.3.1.1.1" class="indexterm"></a>
-</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Prev</a></td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"><a accesskey="n" href="status.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">The GNU C++ Library Manual</td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top">Chapter1.Status</td></tr></table></div></body></html>
\ No newline at end of file
+</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Prev</a></td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"><a accesskey="n" href="status.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">The GNU C++ Library Manual</td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top">Chapter1.Status</td></tr></table></div></body></html>
\ No newline at end of file
Index: libstdc++-v3/doc/html/manual/bugs.html
===================================================================
--- a/src/libstdc++-v3/doc/html/manual/bugs.html	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/doc/html/manual/bugs.html	(.../branches/gcc-8-branch)
@@ -492,10 +492,20 @@
        </em></span>
     </span></dt><dd><p>Avoid using <code class="code">dynamic_cast</code> when it would be
     ill-formed.
+    </p></dd><dt><a id="manual.bugs.dr2537"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2537" target="_top">2537</a>:
+       <span class="emphasis"><em>Constructors for <code class="code">priority_queue</code> taking allocators
+	 should call <code class="code">make_heap</code>
+       </em></span>
+    </span></dt><dd><p>Call <code class="code">make_heap</code>.
     </p></dd><dt><a id="manual.bugs.dr2583"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2583" target="_top">2583</a>:
        <span class="emphasis"><em>There is no way to supply an allocator for <code class="code">basic_string(str, pos)</code>
        </em></span>
     </span></dt><dd><p>Add new constructor
+    </p></dd><dt><a id="manual.bugs.dr2586"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2586" target="_top">2586</a>:
+       <span class="emphasis"><em>Wrong value category used in <code class="code">scoped_allocator_adaptor::construct()</code>
+       </em></span>
+    </span></dt><dd><p>Change internal helper for uses-allocator construction
+      to always check using const lvalue allocators.
     </p></dd><dt><a id="manual.bugs.dr2684"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2684" target="_top">2684</a>:
        <span class="emphasis"><em><code class="code">priority_queue</code> lacking comparator typedef
        </em></span>
Index: libstdc++-v3/doc/html/manual/api.html
===================================================================
--- a/src/libstdc++-v3/doc/html/manual/api.html	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/doc/html/manual/api.html	(.../branches/gcc-8-branch)
@@ -28,11 +28,12 @@
 </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="api.rel_320"></a><code class="constant">3.2</code></h3></div></div></div><p>
   </p><p>Symbol versioning introduced for shared library.</p><p>Removal of include <code class="filename">backward/strstream.h</code>.</p><p>Allocator changes. Change <code class="code">__malloc_alloc</code> to <code class="code">malloc_allocator</code> and <code class="code">__new_alloc</code> to <code class="code">new_allocator</code>. </p><p> For GCC releases from 2.95 through the 3.1 series, defining
    <code class="literal">__USE_MALLOC</code> on the gcc command line would change the
-   default allocation strategy to instead use <code class="code"> malloc</code> and
-   <code class="function">free</code>. For the 3.2 and 3.3 release series the same
+   default allocation strategy to instead use <code class="code">malloc</code> and
+   <code class="code">free</code>. For the 3.2 and 3.3 release series the same
    functionality was spelled <code class="literal">_GLIBCXX_FORCE_NEW</code>. From
-   GCC 3.4 onwards the functionality is enabled by setting
-   <code class="literal">GLIBCXX_FORCE_NEW</code> in the environment, see
+   GCC 3.4 onwards the default allocator uses <code class="code">new</code> anyway,
+   but for the optional pooling allocators the functionality is enabled by
+   setting <code class="literal">GLIBCXX_FORCE_NEW</code> in the environment, see
    <a class="link" href="mt_allocator.html" title="Chapter20.The mt_allocator">the mt allocator chapter</a>
    for details.
    </p><p>Error handling in iostreams cleaned up, made consistent. </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="api.rel_330"></a><code class="constant">3.3</code></h3></div></div></div><p>
Index: libstdc++-v3/doc/html/manual/debug.html
===================================================================
--- a/src/libstdc++-v3/doc/html/manual/debug.html	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/doc/html/manual/debug.html	(.../branches/gcc-8-branch)
@@ -53,40 +53,28 @@
   This quick and dirty approach is often sufficient for quick
   debugging tasks, when you cannot or don't want to recompile your
   application to use the <a class="link" href="debug_mode.html" title="Chapter17.Debug Mode">debug mode</a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="debug.memory"></a>Memory Leak Hunting</h3></div></div></div><p>
-  There are various third party memory tracing and debug utilities
+  On many targets GCC supports AddressSanitizer, a fast memory error detector,
+  which is enabled by the <code class="option">-fsanitize=address</code> option.
+</p><p>
+  There are also various third party memory tracing and debug utilities
   that can be used to provide detailed memory allocation information
   about C++ code. An exhaustive list of tools is not going to be
   attempted, but includes <code class="code">mtrace</code>, <code class="code">valgrind</code>,
-  <code class="code">mudflap</code>, and the non-free commercial product
-  <code class="code">purify</code>. In addition, <code class="code">libcwd</code> has a
-  replacement for the global new and delete operators that can track
-  memory allocation and deallocation and provide useful memory
-  statistics.
+  <code class="code">mudflap</code> (no longer supported since GCC 4.9.0), ElectricFence,
+  and the non-free commercial product <code class="code">purify</code>.
+  In addition, <code class="code">libcwd</code>, jemalloc and TCMalloc have replacements
+  for the global <code class="code">new</code> and <code class="code">delete</code> operators
+  that can track memory allocation and deallocation and provide useful
+  memory statistics.
 </p><p>
-  Regardless of the memory debugging tool being used, there is one
-  thing of great importance to keep in mind when debugging C++ code
-  that uses <code class="code">new</code> and <code class="code">delete</code>: there are
-  different kinds of allocation schemes that can be used by <code class="code">
-  std::allocator</code>. For implementation details, see the <a class="link" href="mt_allocator.html" title="Chapter20.The mt_allocator">mt allocator</a> documentation and
-  look specifically for <code class="code">GLIBCXX_FORCE_NEW</code>.
-</p><p>
-  In a nutshell, the optional <code class="classname">mt_allocator</code>
-  is a high-performance pool allocator, and can
-  give the mistaken impression that in a suspect executable, memory is
-  being leaked, when in reality the memory "leak" is a pool being used
-  by the library's allocator and is reclaimed after program
-  termination.
-</p><p>
   For valgrind, there are some specific items to keep in mind. First
   of all, use a version of valgrind that will work with current GNU
   C++ tools: the first that can do this is valgrind 1.0.4, but later
-  versions should work at least as well. Second of all, use a
-  completely unoptimized build to avoid confusing valgrind. Third, use
-  GLIBCXX_FORCE_NEW to keep extraneous pool allocation noise from
-  cluttering debug information.
+  versions should work better. Second, using an unoptimized build
+  might avoid confusing valgrind.
 </p><p>
-  Fourth, it may be necessary to force deallocation in other libraries
-  as well, namely the "C" library. On linux, this can be accomplished
+  Third, it may be necessary to force deallocation in other libraries
+  as well, namely the "C" library. On GNU/Linux, this can be accomplished
   with the appropriate use of the <code class="code">__cxa_atexit</code> or
   <code class="code">atexit</code> functions.
 </p><pre class="programlisting">
@@ -121,7 +109,29 @@
   up the runtime environment, library, and test file, might be:
 </p><pre class="programlisting">
    valgrind -v --num-callers=20 --leak-check=yes --leak-resolution=high --show-reachable=yes a.out
-</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="debug.races"></a>Data Race Hunting</h3></div></div></div><p>
+</pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="debug.memory.mtalloc"></a>Non-memory leaks in Pool and MT allocators</h4></div></div></div><p>
+  There are different kinds of allocation schemes that can be used by
+  <code class="code">std::allocator</code>. Prior to GCC 3.4.0 the default was to use
+  a pooling allocator, <code class="classname">pool_allocator</code>,
+  which is still available as the optional
+  <code class="classname">__pool_alloc</code> extension.
+  Another optional extension, <code class="classname">__mt_alloc</code>,
+  is a high-performance pool allocator.
+</p><p>
+  In a suspect executable these pooling allocators can give
+  the mistaken impression that memory is being leaked,
+  when in reality the memory "leak" is a pool being used
+  by the library's allocator and is reclaimed after program
+  termination.
+</p><p>
+  If you're using memory debugging tools on a program that uses
+  one of these pooling allocators, you can set the environment variable
+  <code class="literal">GLIBCXX_FORCE_NEW</code> to keep extraneous pool allocation
+  noise from cluttering debug information.
+  For more details, see the
+  <a class="link" href="mt_allocator.html" title="Chapter20.The mt_allocator">mt allocator</a>
+  documentation and look specifically for <code class="code">GLIBCXX_FORCE_NEW</code>.
+</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="debug.races"></a>Data Race Hunting</h3></div></div></div><p>
   All synchronization primitives used in the library internals need to be
   understood by race detectors so that they do not produce false reports.
 </p><p>
Index: libstdc++-v3/doc/html/manual/index.html
===================================================================
--- a/src/libstdc++-v3/doc/html/manual/index.html	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/doc/html/manual/index.html	(.../branches/gcc-8-branch)
@@ -4,7 +4,7 @@
     </p></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="part"><a href="intro.html">I. 
   Introduction
   
-</a></span></dt><dd><dl><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="std_contents.html">II. 
+</a></span></dt><dd><dl><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="std_contents.html">II. 
     Standard Contents
   </a></span></dt><dd><dl><dt><span class="chapter"><a href="support.html">4. 
   Support
Index: libstdc++-v3/po/Makefile.in
===================================================================
--- a/src/libstdc++-v3/po/Makefile.in	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/po/Makefile.in	(.../branches/gcc-8-branch)
@@ -205,6 +205,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/include/Makefile.in
===================================================================
--- a/src/libstdc++-v3/include/Makefile.in	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/include/Makefile.in	(.../branches/gcc-8-branch)
@@ -205,6 +205,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/include/std/optional
===================================================================
--- a/src/libstdc++-v3/include/std/optional	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/include/std/optional	(.../branches/gcc-8-branch)
@@ -51,7 +51,7 @@
    *  @{
    */
 
-#define __cpp_lib_optional 201603
+#define __cpp_lib_optional 201606L
 
   template<typename _Tp>
     class optional;
@@ -1256,7 +1256,7 @@
 	}
 
       template<typename _Up>
-	_Tp
+	constexpr _Tp
 	value_or(_Up&& __u) &&
 	{
 	  static_assert(is_move_constructible_v<_Tp>);
Index: libstdc++-v3/include/std/any
===================================================================
--- a/src/libstdc++-v3/include/std/any	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/include/std/any	(.../branches/gcc-8-branch)
@@ -66,7 +66,7 @@
 #endif
   }
 
-#define __cpp_lib_any 201603
+#define __cpp_lib_any 201606L
 
   /**
    *  @brief A type-safe container of any type.
@@ -503,20 +503,34 @@
     }
   // @}
 
+  /// @cond undocumented
   template<typename _Tp>
     void* __any_caster(const any* __any)
     {
-      if constexpr (is_copy_constructible_v<decay_t<_Tp>>)
+      // any_cast<T> returns non-null if __any->type() == typeid(T) and
+      // typeid(T) ignores cv-qualifiers so remove them:
+      using _Up = remove_cv_t<_Tp>;
+      // The contained value has a decayed type, so if decay_t<U> is not U,
+      // then it's not possible to have a contained value of type U:
+      if constexpr (!is_same_v<decay_t<_Up>, _Up>)
+	return nullptr;
+      // Only copy constructible types can be used for contained values:
+      else if constexpr (!is_copy_constructible_v<_Up>)
+	return nullptr;
+      // First try comparing function addresses, which works without RTTI
+      else if (__any->_M_manager == &any::_Manager<_Up>::_S_manage
+#if __cpp_rtti
+	  || __any->type() == typeid(_Tp)
+#endif
+	  )
 	{
-	  if (__any->_M_manager == &any::_Manager<decay_t<_Tp>>::_S_manage)
-	    {
-	      any::_Arg __arg;
-	      __any->_M_manager(any::_Op_access, __any, &__arg);
-	      return __arg._M_obj;
-	    }
+	  any::_Arg __arg;
+	  __any->_M_manager(any::_Op_access, __any, &__arg);
+	  return __arg._M_obj;
 	}
       return nullptr;
     }
+  /// @endcond
 
   /**
    * @brief Access the contained object.
@@ -532,8 +546,9 @@
   template<typename _ValueType>
     inline const _ValueType* any_cast(const any* __any) noexcept
     {
-      if (__any)
-	return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
+      if constexpr (is_object_v<_ValueType>)
+	if (__any)
+	  return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
       return nullptr;
     }
 
@@ -540,8 +555,9 @@
   template<typename _ValueType>
     inline _ValueType* any_cast(any* __any) noexcept
     {
-      if (__any)
-	return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
+      if constexpr (is_object_v<_ValueType>)
+	if (__any)
+	  return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
       return nullptr;
     }
   // @}
Index: libstdc++-v3/include/std/type_traits
===================================================================
--- a/src/libstdc++-v3/include/std/type_traits	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/include/std/type_traits	(.../branches/gcc-8-branch)
@@ -867,60 +867,18 @@
     : public __is_nt_destructible_safe<_Tp>::type
     { };
 
-  struct __do_is_default_constructible_impl
-  {
-    template<typename _Tp, typename = decltype(_Tp())>
-      static true_type __test(int);
-
-    template<typename>
-      static false_type __test(...);
-  };
-
-  template<typename _Tp>
-    struct __is_default_constructible_impl
-    : public __do_is_default_constructible_impl
-    {
-      typedef decltype(__test<_Tp>(0)) type;
-    };
-
-  template<typename _Tp>
-    struct __is_default_constructible_atom
-    : public __and_<__not_<is_void<_Tp>>,
-                    __is_default_constructible_impl<_Tp>>
+  /// is_constructible
+  template<typename _Tp, typename... _Args>
+    struct is_constructible
+      : public __bool_constant<__is_constructible(_Tp, _Args...)>
     { };
 
-  template<typename _Tp, bool = is_array<_Tp>::value>
-    struct __is_default_constructible_safe;
-
-  // The following technique is a workaround for a current core language
-  // restriction, which does not allow for array types to occur in
-  // functional casts of the form T().  Complete arrays can be default-
-  // constructed, if the element type is default-constructible, but
-  // arrays with unknown bounds are not.
-  template<typename _Tp>
-    struct __is_default_constructible_safe<_Tp, true>
-    : public __and_<__is_array_known_bounds<_Tp>,
-		    __is_default_constructible_atom<typename
-                      remove_all_extents<_Tp>::type>>
-    { };
-
-  template<typename _Tp>
-    struct __is_default_constructible_safe<_Tp, false>
-    : public __is_default_constructible_atom<_Tp>::type
-    { };
-
   /// is_default_constructible
   template<typename _Tp>
     struct is_default_constructible
-    : public __is_default_constructible_safe<_Tp>::type
+    : public is_constructible<_Tp>::type
     { };
 
-  /// is_constructible
-  template<typename _Tp, typename... _Args>
-    struct is_constructible
-      : public __bool_constant<__is_constructible(_Tp, _Args...)>
-    { };
-
   template<typename _Tp, bool = __is_referenceable<_Tp>::value>
     struct __is_copy_constructible_impl;
 
@@ -2024,9 +1982,14 @@
     struct __expanded_common_type_wrapper<__failure_type, _Args...>
     { typedef __failure_type type; };
 
+  template<>
+    struct common_type<>
+    { };
+
   template<typename _Tp>
     struct common_type<_Tp>
-    { typedef typename decay<_Tp>::type type; };
+    : common_type<_Tp, _Tp>
+    { };
 
   template<typename _Tp, typename _Up>
     struct common_type<_Tp, _Up>
Index: libstdc++-v3/include/std/variant
===================================================================
--- a/src/libstdc++-v3/include/std/variant	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/include/std/variant	(.../branches/gcc-8-branch)
@@ -68,7 +68,7 @@
 } // namespace __variant
 } // namespace __detail
 
-#define __cpp_lib_variant 201603
+#define __cpp_lib_variant 201606L
 
   template<typename... _Types> class tuple;
   template<typename... _Types> class variant;
@@ -1076,6 +1076,17 @@
 
       using _Traits = __detail::__variant::_Traits<_Types...>;
 
+      template<typename _Tp>
+	struct __is_in_place_tag : false_type { };
+      template<typename _Tp>
+	struct __is_in_place_tag<in_place_type_t<_Tp>> : true_type { };
+      template<size_t _Np>
+	struct __is_in_place_tag<in_place_index_t<_Np>> : true_type { };
+
+      template<typename _Tp>
+	static constexpr bool __not_in_place_tag
+	  = !__is_in_place_tag<decay_t<_Tp>>::value;
+
     public:
       variant() = default;
       variant(const variant& __rhs) = default;
@@ -1087,6 +1098,7 @@
       template<typename _Tp,
 	       typename = enable_if_t<!is_same_v<decay_t<_Tp>, variant>>,
 	       typename = enable_if_t<(sizeof...(_Types)>0)>,
+	       typename = enable_if_t<__not_in_place_tag<_Tp>>,
 	       typename = enable_if_t<__exactly_once<__accepted_type<_Tp&&>>
 			  && is_constructible_v<__accepted_type<_Tp&&>, _Tp&&>>>
 	constexpr
Index: libstdc++-v3/include/experimental/any
===================================================================
--- a/src/libstdc++-v3/include/experimental/any	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/include/experimental/any	(.../branches/gcc-8-branch)
@@ -300,7 +300,8 @@
     _Storage _M_storage;
 
     template<typename _Tp>
-      friend void* __any_caster(const any* __any);
+      friend enable_if_t<is_object<_Tp>::value, void*>
+      __any_caster(const any* __any);
 
     // Manage in-place contained object.
     template<typename _Tp>
@@ -410,19 +411,45 @@
     }
   // @}
 
+  /// @cond undocumented
   template<typename _Tp>
-    void* __any_caster(const any* __any)
+    enable_if_t<is_object<_Tp>::value, void*>
+    __any_caster(const any* __any)
     {
-      struct _None { };
-      using _Up = decay_t<_Tp>;
-      using _Vp = conditional_t<is_copy_constructible<_Up>::value, _Up, _None>;
-      if (__any->_M_manager != &any::_Manager<_Vp>::_S_manage)
-	return nullptr;
-      any::_Arg __arg;
-      __any->_M_manager(any::_Op_access, __any, &__arg);
-      return __arg._M_obj;
+      // any_cast<T> returns non-null if __any->type() == typeid(T) and
+      // typeid(T) ignores cv-qualifiers so remove them:
+      using _Up = remove_cv_t<_Tp>;
+      // The contained value has a decayed type, so if decay_t<U> is not U,
+      // then it's not possible to have a contained value of type U.
+      using __does_not_decay = is_same<decay_t<_Up>, _Up>;
+      // Only copy constructible types can be used for contained values.
+      using __is_copyable = is_copy_constructible<_Up>;
+      // If the type _Tp could never be stored in an any we don't want to
+      // instantiate _Manager<_Tp>, so use _Manager<any::_Op> instead, which
+      // is explicitly specialized and has a no-op _S_manage function.
+      using _Vp = conditional_t<__and_<__does_not_decay, __is_copyable>::value,
+				_Up, any::_Op>;
+      // First try comparing function addresses, which works without RTTI
+      if (__any->_M_manager == &any::_Manager<_Vp>::_S_manage
+#if __cpp_rtti
+	  || __any->type() == typeid(_Tp)
+#endif
+	  )
+	{
+	  any::_Arg __arg;
+	  __any->_M_manager(any::_Op_access, __any, &__arg);
+	  return __arg._M_obj;
+	}
+      return nullptr;
     }
 
+  // This overload exists so that std::any_cast<void(*)()>(a) is well-formed.
+  template<typename _Tp>
+    enable_if_t<!is_object<_Tp>::value, _Tp*>
+    __any_caster(const any*) noexcept
+    { return nullptr; }
+  /// @endcond
+
   /**
    * @brief Access the contained object.
    *
@@ -517,6 +544,14 @@
       }
     }
 
+  // Dummy specialization used by __any_caster.
+  template<>
+    struct any::_Manager_internal<any::_Op>
+    {
+      static void
+      _S_manage(_Op, const any*, _Arg*) { }
+    };
+
   // @} group any
 } // namespace fundamentals_v1
 } // namespace experimental
Index: libstdc++-v3/include/experimental/bits/fs_path.h
===================================================================
--- a/src/libstdc++-v3/include/experimental/bits/fs_path.h	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/include/experimental/bits/fs_path.h	(.../branches/gcc-8-branch)
@@ -120,11 +120,12 @@
       : decltype(__is_path_src(std::declval<_Source>(), 0))
       { };
 
-    template<typename _Tp1, typename _Tp2 = void>
+    template<typename _Tp1, typename _Tp2 = void,
+	     typename _Tp1_nocv = typename remove_cv<_Tp1>::type,
+	     typename _Tp1_noptr = typename remove_pointer<_Tp1>::type>
       using _Path = typename
-	std::enable_if<__and_<__not_<is_same<typename remove_cv<_Tp1>::type,
-					     path>>,
-			      __not_<is_void<_Tp1>>,
+	std::enable_if<__and_<__not_<is_same<_Tp1_nocv, path>>,
+			      __not_<is_void<_Tp1_noptr>>,
 			      __constructible_from<_Tp1, _Tp2>>::value,
 		       path>::type;
 
@@ -185,7 +186,8 @@
     path(path&& __p) noexcept
     : _M_pathname(std::move(__p._M_pathname)), _M_type(__p._M_type)
     {
-      _M_split_cmpts();
+      if (_M_type == _Type::_Multi)
+	_M_split_cmpts();
       __p.clear();
     }
 
@@ -459,7 +461,7 @@
 	return _S_convert_loc(__tmp.data(), __tmp.data()+__tmp.size(), __loc);
       }
 
-    bool _S_is_dir_sep(value_type __ch)
+    static bool _S_is_dir_sep(value_type __ch)
     {
 #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
       return __ch == L'/' || __ch == preferred_separator;
Index: libstdc++-v3/include/bits/hashtable.h
===================================================================
--- a/src/libstdc++-v3/include/bits/hashtable.h	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/include/bits/hashtable.h	(.../branches/gcc-8-branch)
@@ -192,11 +192,6 @@
       static_assert(is_same<typename _Alloc::value_type, _Value>{},
 	  "unordered container must have the same value_type as its allocator");
 #endif
-      static_assert(__is_invocable<const _H1&, const _Key&>{},
-	  "hash function must be invocable with an argument of key type");
-      static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
-	  "key equality predicate must be invocable with two arguments of "
-	  "key type");
 
       using __traits_type = _Traits;
       using __hash_cached = typename __traits_type::__hash_cached;
@@ -1373,6 +1368,12 @@
     {
       clear();
       _M_deallocate_buckets();
+
+      static_assert(__is_invocable<const _H1&, const _Key&>{},
+	  "hash function must be invocable with an argument of key type");
+      static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
+	  "key equality predicate must be invocable with two arguments of "
+	  "key type");
     }
 
   template<typename _Key, typename _Value,
Index: libstdc++-v3/include/bits/stl_queue.h
===================================================================
--- a/src/libstdc++-v3/include/bits/stl_queue.h	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/include/bits/stl_queue.h	(.../branches/gcc-8-branch)
@@ -504,14 +504,18 @@
 	priority_queue(const _Compare& __x, const _Alloc& __a)
 	: c(__a), comp(__x) { }
 
+      // _GLIBCXX_RESOLVE_LIB_DEFECTS
+      // 2537. Constructors [...] taking allocators should call make_heap
       template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 	priority_queue(const _Compare& __x, const _Sequence& __c,
 		       const _Alloc& __a)
-	: c(__c, __a), comp(__x) { }
+	: c(__c, __a), comp(__x)
+	{ std::make_heap(c.begin(), c.end(), comp); }
 
       template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 	priority_queue(const _Compare& __x, _Sequence&& __c, const _Alloc& __a)
-	: c(std::move(__c), __a), comp(__x) { }
+	: c(std::move(__c), __a), comp(__x)
+	{ std::make_heap(c.begin(), c.end(), comp); }
 
       template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 	priority_queue(const priority_queue& __q, const _Alloc& __a)
Index: libstdc++-v3/include/bits/fs_path.h
===================================================================
--- a/src/libstdc++-v3/include/bits/fs_path.h	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/include/bits/fs_path.h	(.../branches/gcc-8-branch)
@@ -107,7 +107,7 @@
     template<typename _Tp1, typename _Tp2 = void>
       using _Path = typename
 	std::enable_if<__and_<__not_<is_same<remove_cv_t<_Tp1>, path>>,
-			      __not_<is_void<_Tp1>>,
+			      __not_<is_void<remove_pointer_t<_Tp1>>>,
 			      __constructible_from<_Tp1, _Tp2>>::value,
 		       path>::type;
 
@@ -168,7 +168,8 @@
     path(path&& __p) noexcept
     : _M_pathname(std::move(__p._M_pathname)), _M_type(__p._M_type)
     {
-      _M_split_cmpts();
+      if (_M_type == _Type::_Multi)
+	_M_split_cmpts();
       __p.clear();
     }
 
@@ -478,7 +479,7 @@
       static basic_string<_CharT, _Traits, _Allocator>
       _S_str_convert(const string_type&, const _Allocator& __a);
 
-    bool _S_is_dir_sep(value_type __ch)
+    static bool _S_is_dir_sep(value_type __ch)
     {
 #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
       return __ch == L'/' || __ch == preferred_separator;
@@ -789,6 +790,9 @@
   inline path&
   path::operator=(path&& __p) noexcept
   {
+    if (&__p == this)
+      return *this;
+
     _M_pathname = std::move(__p._M_pathname);
     _M_cmpts = std::move(__p._M_cmpts);
     _M_type = __p._M_type;
Index: libstdc++-v3/include/bits/stl_uninitialized.h
===================================================================
--- a/src/libstdc++-v3/include/bits/stl_uninitialized.h	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/include/bits/stl_uninitialized.h	(.../branches/gcc-8-branch)
@@ -826,7 +826,9 @@
 
 #endif
 
-#if __cplusplus > 201402L
+#if __cplusplus >= 201703L
+# define __cpp_lib_raw_memory_algorithms 201606L
+
   template <typename _ForwardIterator>
     inline void
     uninitialized_default_construct(_ForwardIterator __first,
@@ -877,7 +879,7 @@
 	 __count, __result);
       return {__res.first.base(), __res.second};
     }
-#endif
+#endif // C++17
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
Index: libstdc++-v3/include/bits/char_traits.h
===================================================================
--- a/src/libstdc++-v3/include/bits/char_traits.h	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/include/bits/char_traits.h	(.../branches/gcc-8-branch)
@@ -248,7 +248,7 @@
     __constant_char_array_p(const _CharT* __a, size_t __n)
     {
       size_t __i = 0;
-      while (__builtin_constant_p(__a[__i]) && __i < __n)
+      while (__i < __n && __builtin_constant_p(__a[__i]))
 	__i++;
       return __i == __n;
     }
Index: libstdc++-v3/include/bits/forward_list.tcc
===================================================================
--- a/src/libstdc++-v3/include/bits/forward_list.tcc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/include/bits/forward_list.tcc	(.../branches/gcc-8-branch)
@@ -375,7 +375,7 @@
       auto __iy = __ly.cbegin();
       while (__ix != __lx.cend() && __iy != __ly.cend())
 	{
-	  if (*__ix != *__iy)
+	  if (!(*__ix == *__iy))
 	    return false;
 	  ++__ix;
 	  ++__iy;
@@ -445,9 +445,9 @@
 			__p = static_cast<_Node*>(__p->_M_next);
 			--__psize;
 		      }
-		    else if (__comp(*__p->_M_valptr(), *__q->_M_valptr()))
+		    else if (!__comp(*__q->_M_valptr(), *__p->_M_valptr()))
 		      {
-			// First node of p is lower; e must come from p.
+			// First node of q is not lower; e must come from p.
 			__e = __p;
 			__p = static_cast<_Node*>(__p->_M_next);
 			--__psize;
Index: libstdc++-v3/include/bits/uses_allocator.h
===================================================================
--- a/src/libstdc++-v3/include/bits/uses_allocator.h	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/include/bits/uses_allocator.h	(.../branches/gcc-8-branch)
@@ -83,14 +83,17 @@
   template<typename _Tp, typename _Alloc, typename... _Args>
     struct __uses_alloc<true, _Tp, _Alloc, _Args...>
     : conditional<
-        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value,
+        is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>::value,
         __uses_alloc1<_Alloc>,
        	__uses_alloc2<_Alloc>>::type
     {
+      // _GLIBCXX_RESOLVE_LIB_DEFECTS
+      // 2586. Wrong value category used in scoped_allocator_adaptor::construct
       static_assert(__or_<
-	  is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>,
-	  is_constructible<_Tp, _Args..., _Alloc>>::value, "construction with"
-	  " an allocator must be possible if uses_allocator is true");
+	  is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>,
+	  is_constructible<_Tp, _Args..., const _Alloc&>>::value,
+	  "construction with an allocator must be possible"
+	  " if uses_allocator is true");
     };
 
   template<typename _Tp, typename _Alloc, typename... _Args>
Index: libstdc++-v3/include/bits/stl_tree.h
===================================================================
--- a/src/libstdc++-v3/include/bits/stl_tree.h	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/include/bits/stl_tree.h	(.../branches/gcc-8-branch)
@@ -448,17 +448,6 @@
 
       typedef __gnu_cxx::__alloc_traits<_Node_allocator> _Alloc_traits;
 
-#if __cplusplus >= 201103L
-      static_assert(__is_invocable<_Compare&, const _Key&, const _Key&>{},
-	  "comparison object must be invocable with two arguments of key type");
-# if __cplusplus >= 201703L
-      // _GLIBCXX_RESOLVE_LIB_DEFECTS
-      // 2542. Missing const requirements for associative containers
-      static_assert(is_invocable_v<const _Compare&, const _Key&, const _Key&>,
-	  "comparison object must be invocable as const");
-# endif // C++17
-#endif // C++11
-
     protected:
       typedef _Rb_tree_node_base* 		_Base_ptr;
       typedef const _Rb_tree_node_base* 	_Const_Base_ptr;
@@ -962,8 +951,22 @@
 #endif
 
       ~_Rb_tree() _GLIBCXX_NOEXCEPT
-      { _M_erase(_M_begin()); }
+      {
+	_M_erase(_M_begin());
 
+#if __cplusplus >= 201103L
+	static_assert(__is_invocable<_Compare&, const _Key&, const _Key&>{},
+		      "comparison object must be invocable "
+		      "with two arguments of key type");
+# if __cplusplus >= 201703L
+      // _GLIBCXX_RESOLVE_LIB_DEFECTS
+      // 2542. Missing const requirements for associative containers
+	static_assert(is_invocable_v<const _Compare&, const _Key&, const _Key&>,
+		      "comparison object must be invocable as const");
+# endif // C++17
+#endif // C++11
+      }
+
       _Rb_tree&
       operator=(const _Rb_tree& __x);
 
Index: libstdc++-v3/libsupc++/Makefile.in
===================================================================
--- a/src/libstdc++-v3/libsupc++/Makefile.in	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/libsupc++/Makefile.in	(.../branches/gcc-8-branch)
@@ -278,6 +278,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/libsupc++/hash_bytes.cc
===================================================================
--- a/src/libstdc++-v3/libsupc++/hash_bytes.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/libsupc++/hash_bytes.cc	(.../branches/gcc-8-branch)
@@ -139,7 +139,7 @@
 
     // Remove the bytes not divisible by the sizeof(size_t).  This
     // allows the main loop to process the data as 64-bit integers.
-    const int len_aligned = len & ~0x7;
+    const size_t len_aligned = len & ~(size_t)0x7;
     const char* const end = buf + len_aligned;
     size_t hash = seed ^ (len * mul);
     for (const char* p = buf; p != end; p += 8)
Index: libstdc++-v3/libsupc++/exception
===================================================================
--- a/src/libstdc++-v3/libsupc++/exception	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/libsupc++/exception	(.../branches/gcc-8-branch)
@@ -101,8 +101,8 @@
   _GLIBCXX17_DEPRECATED
   bool uncaught_exception() _GLIBCXX_USE_NOEXCEPT __attribute__ ((__pure__));
 
-#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++17 or gnu++98
-#define __cpp_lib_uncaught_exceptions 201411
+#if __cplusplus >= 201703L || !defined(__STRICT_ANSI__) // c++17 or gnu++98
+#define __cpp_lib_uncaught_exceptions 201411L
   /// The number of uncaught exceptions.
   int uncaught_exceptions() _GLIBCXX_USE_NOEXCEPT __attribute__ ((__pure__));
 #endif
Index: libstdc++-v3/ChangeLog
===================================================================
--- a/src/libstdc++-v3/ChangeLog	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/ChangeLog	(.../branches/gcc-8-branch)
@@ -1,3 +1,325 @@
+2019-06-01   Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-12-22 Iain Sandoe <iain@sandoe.co.uk>
+
+	* /config/os/bsd/darwin/ppc-extra.ver: Append long double symbols.
+
+2019-05-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/status_cxx2017.xml: Fix typo in documentation of
+	implementation-defined support for [fs.conform.9945].
+	* doc/html/*: Regenerate.
+
+2019-05-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90634
+	* src/filesystem/path.cc (path::_M_split_cmpts()): Fix check for "/".
+	* testsuite/27_io/filesystem/path/construct/90634.cc: New test.
+	* testsuite/experimental/filesystem/path/construct/90634.cc: New test.
+
+	PR libstdc++/90634
+	* include/bits/fs_path.h (path::path(path&&)): Only call
+	_M_split_cmpts() for a path with multiple components.
+	(path::_S_is_dir_sep()): Add missing 'static' keyword to function.
+	* include/experimental/bits/fs_path.h: Likewise.
+	* src/filesystem/path.cc (path::_M_split_cmpts()): Count number of
+	components and reserve space in vector. Return early when there is
+	only one component.
+	* src/filesystem/std-path.cc (path::_M_split_cmpts()): Likewise.
+
+2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-02-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/89466
+	* acinclude.m4 (GLIBCXX_CONFIGURE_DOCBOOK): Reorder check for local
+	stylesheet directories before check for xsltproc. Try to use
+	xmlcatalog to find local stylesheet directory before trying hardcoded
+	paths. Add path used by suse to hardcoded paths. Adjust xsltproc
+	check to look for the same stylesheet as doc/Makefile.am uses. Don't
+	use xsltproc if xmlcatalog fails to find a local stylesheet.
+	* configure.ac: Check for xmlcatalog.
+	* Makefile.in: Regenerate.
+	* configure: Likewise.
+	* doc/Makefile.in: Likewise.
+	* include/Makefile.in: Likewise.
+	* libsupc++/Makefile.in: Likewise.
+	* po/Makefile.in: Likewise.
+	* python/Makefile.in: Likewise.
+	* src/Makefile.in: Likewise.
+	* src/c++11/Makefile.in: Likewise.
+	* src/c++17/Makefile.in: Likewise.
+	* src/c++98/Makefile.in: Likewise.
+	* src/filesystem/Makefile.in: Likewise.
+	* testsuite/Makefile.in: Likewise.
+
+2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/html/*: Regenerate.
+
+2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/experimental/any (__any_caster): Use RTTI if comparing
+	addresses fails, to support non-unique addresses in shared libraries.
+	* include/std/any (__any_caster): Likewise.
+	* testsuite/experimental/any/misc/any_cast_neg.cc: Use 0 for dg-error
+	line number.
+
+2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90220
+	* include/experimental/any (__any_caster): Constrain to only be
+	callable for object types. Use remove_cv_t instead of decay_t.
+	If the type decays or isn't copy constructible, compare the manager
+	function to a dummy specialization.
+	(__any_caster): Add overload constrained for non-object types.
+	(any::_Manager_internal<_Op>): Add dummy specialization.
+	* testsuite/experimental/any/misc/any_cast.cc: Test function types
+	and array types.
+
+	Backport from mainline
+	2019-04-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90220
+	* include/std/any (__any_caster): Use remove_cv_t instead of decay_t.
+	Avoid a runtime check for types that can never be stored in std::any.
+	* testsuite/20_util/any/misc/any_cast.cc: Test std::any_cast with
+	array types.
+
+	Backport from mainline
+	2019-04-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90220 (partial)
+	* include/std/any (any_cast<T>(any*), any_cast<T>(const any*)): Do
+	not attempt ill-formed static_cast to pointers to non-object types.
+	* testsuite/20_util/any/misc/any_cast.cc: Test std::any_cast with
+	function types.
+
+2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from mainline
+	2019-01-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/status_cxx2017.xml: Document P0032R3 and P0307R2
+	status.
+	* include/bits/stl_uninitialized.h (__cpp_lib_raw_memory_algorithms):
+	Define.
+	* include/std/any (__cpp_lib_any): Define as 201606L, because P0032R3
+	changes are supported.
+	* include/std/optional (__cpp_lib_optional): Likewise.
+	* include/std/variant (__cpp_lib_variant): Likewise.
+	* libsupc++/exception (__cpp_lib_uncaught_exceptions): Define as long
+	integer.
+
+2019-05-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from mainline
+	2019-05-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/90532 Ensure __is_constructible(T[]) is false
+	* include/std/type_traits (__do_is_default_constructible_impl)
+	(__is_default_constructible_atom, __is_default_constructible_safe):
+	Remove.
+	(is_default_constructible): Use is_constructible.
+	* testsuite/20_util/is_constructible/value.cc: Check int[] case.
+	* testsuite/20_util/is_default_constructible/value.cc: Likewise.
+	* testsuite/20_util/is_trivially_constructible/value.cc: Likewise.
+	* testsuite/20_util/is_trivially_default_constructible/value.cc:
+	Likewise.
+
+2019-05-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-05-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90299
+	* src/filesystem/std-ops.cc (absolute(const path&)): Report an error
+	if the argument is an empty path.
+	(absolute(const path&, error_code&)): Use invalid_argument as error
+	code instead of no_such_file_or_directory.
+	* testsuite/27_io/filesystem/operations/absolute.cc: Check handling
+	of non-existent paths and empty paths with both overloads of absolute.
+
+2019-05-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-04-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/27_io/filesystem/path/decompose/root_path.cc: Remove
+	macros accidentally left in.
+
+	Backport from mainline
+	2019-05-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90454.cc path construction from void*
+	* include/bits/fs_path.h (path::_Path): Use remove_pointer so that
+	pointers to void are rejected as well as void.
+	* include/experimental/bits/fs_path.h (path::_Path): Likewise.
+	* testsuite/27_io/filesystem/path/construct/80762.cc: Also check
+	pointers to void.
+	* testsuite/experimental/filesystem/path/construct/80762.cc: Likewise.
+
+2019-05-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-05-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/81266
+	* testsuite/util/thread/all.h: Do not use remove_pointer for
+	std::thread::native_handle_type.
+
+2019-05-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-02-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/89102 (partial)
+	* include/std/type_traits (common_type<>): Define.
+	(common_type<T>): Derive from common_type<T, T>.
+	* testsuite/20_util/common_type/requirements/explicit_instantiation.cc:
+	Test zero-length template argument list.
+	* testsuite/20_util/common_type/requirements/sfinae_friendly_1.cc:
+	Test additional single argument cases.
+	* testsuite/20_util/common_type/requirements/sfinae_friendly_2.cc:
+	Adjust expected error.
+
+	Backport from mainline
+	2019-01-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/88740
+	* testsuite/util/testsuite_hooks.h [stderr] (VERIFY): Use fprintf to
+	write to stderr instead of using printf.
+
+	Backport from mainline
+	2019-04-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90165
+	* include/std/variant (variant::__is_in_place_tag)
+	(variant::__not_in_place_tag): New helpers for variant(T&&)
+	constructor constraint.
+	(variant::variant(T&&)): Use __not_in_place_tag in constraints.
+	* testsuite/20_util/variant/compile.cc: Check variant(T&&) constructor
+	isn't used for in_place_type or in_place_index arguments.
+
+	Backport from mainline
+	2019-04-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90105
+	* include/bits/forward_list.tcc (operator==): Do not use operator!= to
+	compare elements.
+	(forward_list<T, A>::sort(Comp)): When elements are equal take the one
+	earlier in the list, so that sort is stable.
+	* testsuite/23_containers/forward_list/operations/90105.cc: New test.
+	* testsuite/23_containers/forward_list/comparable.cc: Test with
+	types that meet the minimum EqualityComparable and LessThanComparable
+	requirements. Remove irrelevant comment.
+
+	Backport from mainline
+	2019-04-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/optional (optional::value_or(U&&) &&): Add missing
+	constexpr specifier.
+	* testsuite/20_util/optional/constexpr/observers/4.cc: Check value_or
+	for disengaged optionals and rvalue optionals.
+	* testsuite/20_util/optional/observers/4.cc: Likewise.
+
+	Backport from mainline
+	2019-04-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/faq.xml: Add information about emergency EH pool.
+	* doc/xml/manual/debug.xml: Update list of memory debugging tools.
+	Move outdated information on mt_allocator to a separate section.
+	* doc/xml/manual/evolution.xml: Clarify that GLIBCXX_FORCE_NEW
+	doesn't affect the default allocator.
+
+	Backport from mainline
+	2019-04-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/filesystem/std-dir.cc (_Dir::advance(bool, error_code&)): Handle
+	d_type == DT_UNKNOWN immediately.
+	(_Dir::should_recurse(bool, error_code&)): Remove file_type::unknown
+	handling here.
+	* testsuite/27_io/filesystem/iterators/caching.cc: New test.
+
+	Backport from mainline
+	2019-04-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/fs_path.h (path::operator=(path&&)): Check for self
+	assignment.
+	* testsuite/27_io/filesystem/path/assign/copy.cc: Test self
+	assignment.
+
+	Backport from mainline
+	2019-03-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/85965
+	* include/bits/hashtable.h (_Hashtable): Move static assertions to
+	destructor so they are not evaluated until the _Key type is complete.
+	* include/bits/stl_tree.h (_Rb_tree): Likewise.
+	* testsuite/23_containers/set/85965.cc: New test.
+	* testsuite/23_containers/unordered_set/85965.cc: New test.
+	* testsuite/23_containers/map/48101_neg.cc: Replace "here" errors
+	with regexp matching the corresponding _Rb_tree specialization.
+	* testsuite/23_containers/multimap/48101_neg.cc: Likewise.
+	* testsuite/23_containers/multiset/48101_neg.cc: Remove "here" error.
+	* testsuite/23_containers/set/48101_neg.cc: Likewise.
+	* testsuite/23_containers/unordered_map/48101_neg.cc: Likewise.
+	* testsuite/23_containers/unordered_multimap/48101_neg.cc: Likewise.
+	* testsuite/23_containers/unordered_multiset/48101_neg.cc: Likewise.
+	* testsuite/23_containers/unordered_set/48101_neg.cc: Likewise.
+
+	Backport from mainline
+	2019-03-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/89629
+	* libsupc++/hash_bytes.cc [__SIZEOF_SIZE_T__ == 8] (_Hash_bytes):
+	Use correct type for len_aligned.
+	* testsuite/20_util/hash/89629.cc: New test.
+
+	Backport from mainline
+	2019-03-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/using.xml: Use link element instead of xref.
+
+	Backport from mainline
+	2019-02-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/intro.xml: Document LWG 2586 status.
+	* include/bits/uses_allocator.h (__uses_alloc): Use const lvalue
+	allocator type in is_constructible checks.
+	* testsuite/20_util/scoped_allocator/69293_neg.cc: Adjust dg-error.
+	* testsuite/20_util/scoped_allocator/dr2586.cc: New test.
+	* testsuite/20_util/tuple/cons/allocators.cc: Add test using
+	problematic type from LWG 2586 discussion.
+	* testsuite/20_util/uses_allocator/69293_neg.cc: Adjust dg-error.
+	* testsuite/20_util/uses_allocator/cons_neg.cc: Likewise.
+
+	Backport from mainline
+	2019-02-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/intro.xml: Document LWG 2537 status.
+	* include/bits/stl_queue.h
+	(priority_queue(const Compare&, const Container&, const Alloc&))
+	(priority_queue(const Compare&, Container&&, const Alloc&)): Call
+	make_heap.
+	* testsuite/23_containers/priority_queue/dr2537.cc: New test.
+
+2019-02-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/89446
+	* include/bits/char_traits.h (__constant_char_array): Check index is
+	in range before dereferencing.
+	* testsuite/21_strings/basic_string_view/operators/char/89446.cc:
+	New test.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: libstdc++-v3/testsuite/Makefile.in
===================================================================
--- a/src/libstdc++-v3/testsuite/Makefile.in	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/Makefile.in	(.../branches/gcc-8-branch)
@@ -205,6 +205,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/testsuite/23_containers/unordered_map/48101_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/unordered_map/48101_neg.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/unordered_map/48101_neg.cc	(.../branches/gcc-8-branch)
@@ -23,7 +23,7 @@
 test01()
 {
   using namespace std;
-  unordered_map<int, int, equal_to<int>, hash<int>> c2;  // { dg-error "here" }
+  unordered_map<int, int, equal_to<int>, hash<int>> c2;
 }
 
 // { dg-error "hash function must be invocable" "" { target *-*-* } 0 }
Index: libstdc++-v3/testsuite/23_containers/priority_queue/dr2537.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/priority_queue/dr2537.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/priority_queue/dr2537.cc	(.../branches/gcc-8-branch)
@@ -0,0 +1,50 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <queue>
+#include <testsuite_hooks.h>
+
+struct Q : std::priority_queue<int>
+{
+  using priority_queue::priority_queue;
+
+  bool is_heap() const
+  { return std::is_heap(c.begin(), c.end()); }
+};
+
+void
+test01()
+{
+  const Q::value_compare cmp;
+  const Q::container_type c{ 2, 3, 5, 7, 11, 13, 17, 19, 23 };
+  const Q::container_type::allocator_type a;
+
+  Q q1(cmp, c, a);
+  VERIFY( q1.is_heap() );
+
+  auto c2 = c;
+  Q q2(cmp, std::move(c2), a);
+  VERIFY( q2.is_heap() );
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/23_containers/multimap/48101_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/multimap/48101_neg.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/multimap/48101_neg.cc	(.../branches/gcc-8-branch)
@@ -23,8 +23,10 @@
 void
 test01()
 {
-  std::multimap<int, int, std::less<int*>> c;      // { dg-error "here" }
-  std::multimap<int, int, std::allocator<int>> c2; // { dg-error "here" }
+  std::multimap<int, int, std::less<int*>> c;
+  std::multimap<int, int, std::allocator<int>> c2;
 }
 
+// { dg-error "_Compare = std::less<int.>" "" { target *-*-* } 0 }
+// { dg-error "_Compare = std::allocator<int>" "" { target *-*-* } 0 }
 // { dg-error "comparison object must be invocable" "" { target *-*-* } 0 }
Index: libstdc++-v3/testsuite/23_containers/set/85965.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/set/85965.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/set/85965.cc	(.../branches/gcc-8-branch)
@@ -0,0 +1,29 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <set>
+
+struct Base { };
+struct Derived; // derives from Base, but incomplete at this point
+
+struct Foo
+{
+  // PR libstdc++/85965
+  std::set<Derived*, std::less<Base*>> s;
+};
Index: libstdc++-v3/testsuite/23_containers/set/48101_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/set/48101_neg.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/set/48101_neg.cc	(.../branches/gcc-8-branch)
@@ -23,7 +23,7 @@
 test01()
 {
   std::set<const int> c;	      // { dg-error "here" }
-  std::set<int, std::less<long*>> c2; // { dg-error "here" }
+  std::set<int, std::less<long*>> c2;
 }
 
 // { dg-error "non-const, non-volatile value_type" "" { target *-*-* } 0 }
Index: libstdc++-v3/testsuite/23_containers/forward_list/operations/90105.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/forward_list/operations/90105.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/forward_list/operations/90105.cc	(.../branches/gcc-8-branch)
@@ -0,0 +1,60 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <forward_list>
+#include <testsuite_hooks.h>
+
+// PR libstdc++/90105 - std::forward_list::sort() is not "stable"
+
+struct X
+{
+  int key;
+  int val;
+};
+
+bool operator<(const X& l, const X& r)
+{ return l.key < r.key; }
+
+bool operator==(const X& l, const X& r)
+{ return l.key == r.key && l.val == r.val; }
+
+void
+test01()
+{
+  std::forward_list<X> l{ {1, 1}, {2, 2}, {1, 3}, {0, 4}, {2, 5}, {0, 6} };
+  l.sort();
+  std::forward_list<X> exp{ {0, 4}, {0, 6}, {1, 1}, {1, 3}, {2, 2}, {2, 5} };
+  VERIFY( l == exp );
+}
+
+void
+test02()
+{
+  std::forward_list<X> l{ {1, 1}, {1, 2}, {1, 3}, {1, 4}, {1, 5}, {1, 6} };
+  const std::forward_list<X> exp = l;
+  l.sort();
+  VERIFY( l == exp );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
Index: libstdc++-v3/testsuite/23_containers/forward_list/comparable.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/forward_list/comparable.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/forward_list/comparable.cc	(.../branches/gcc-8-branch)
@@ -17,15 +17,11 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-
-// NOTE: This makes use of the fact that we know how moveable
-// is implemented on list (via swap). If the implementation changed
-// this test may begin to fail.
-
 #include <forward_list>
 #include <testsuite_hooks.h>
 
-int main()
+void
+test01()
 {
   std::forward_list<double> a = {0.0, 1.0, 2.0, 3.0, 4.0};
   std::forward_list<double> b = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0};
@@ -43,6 +39,40 @@
   VERIFY((b >  a) == true);
   VERIFY((b >= a) == true);
   VERIFY((b <= a) == false);
+}
 
-  return 0;
+void
+test02()
+{
+  // The EqualityComparable requirements only require ==
+  struct X {
+    bool operator==(const X&) const { return true; }
+  };
+
+  std::forward_list<X> a(2);
+  const auto b = a;
+  VERIFY( a == b );
 }
+
+void
+test03()
+{
+  // The LessThanComparable requirements only require <
+  struct X {
+    bool operator<(const X&) const { return false; }
+  };
+
+  std::forward_list<X> a(2);
+  const auto b = a;
+  VERIFY( !(a < b) );
+  VERIFY( !(a > b) );
+  VERIFY( a <= b );
+  VERIFY( a >= b );
+}
+
+int main()
+{
+  test01();
+  test02();
+  test03();
+}
Index: libstdc++-v3/testsuite/23_containers/unordered_multimap/48101_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/unordered_multimap/48101_neg.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/unordered_multimap/48101_neg.cc	(.../branches/gcc-8-branch)
@@ -23,7 +23,7 @@
 test01()
 {
   using namespace std;
-  unordered_multimap<int, int, equal_to<int>, hash<int>> c2; // { dg-error "here" }
+  unordered_multimap<int, int, equal_to<int>, hash<int>> c2;
 }
 
 // { dg-error "hash function must be invocable" "" { target *-*-* } 0 }
Index: libstdc++-v3/testsuite/23_containers/unordered_set/85965.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/unordered_set/85965.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/unordered_set/85965.cc	(.../branches/gcc-8-branch)
@@ -0,0 +1,29 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <unordered_set>
+
+struct Base { };
+struct Derived; // derives from Base, but incomplete at this point
+
+struct Foo
+{
+  // PR libstdc++/85965
+  std::unordered_set<Derived*, std::equal_to<Base*>, std::hash<Base*>> u;
+};
Index: libstdc++-v3/testsuite/23_containers/unordered_set/48101_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/unordered_set/48101_neg.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/unordered_set/48101_neg.cc	(.../branches/gcc-8-branch)
@@ -24,7 +24,7 @@
 {
   using namespace std;
   unordered_set<const int, hash<int>> c;	    // { dg-error "here" }
-  unordered_set<int, equal_to<int>, hash<int>> c2;  // { dg-error "here" }
+  unordered_set<int, equal_to<int>, hash<int>> c2;
 }
 
 // { dg-error "non-const, non-volatile value_type" "" { target *-*-* } 0 }
Index: libstdc++-v3/testsuite/23_containers/multiset/48101_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/multiset/48101_neg.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/multiset/48101_neg.cc	(.../branches/gcc-8-branch)
@@ -23,7 +23,7 @@
 test01()
 {
   std::multiset<const int> c;		   // { dg-error "here" }
-  std::multiset<int, std::less<long*>> c2; // { dg-error "here" }
+  std::multiset<int, std::less<long*>> c2;
 }
 
 // { dg-error "non-const, non-volatile value_type" "" { target *-*-* } 0 }
Index: libstdc++-v3/testsuite/23_containers/unordered_multiset/48101_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/unordered_multiset/48101_neg.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/unordered_multiset/48101_neg.cc	(.../branches/gcc-8-branch)
@@ -24,7 +24,7 @@
 {
   using namespace std;
   unordered_multiset<const int, hash<int>> c;		// { dg-error "here" }
-  unordered_multiset<int, equal_to<int>, hash<int>> c2; // { dg-error "here" }
+  unordered_multiset<int, equal_to<int>, hash<int>> c2;
 }
 
 // { dg-error "non-const, non-volatile value_type" "" { target *-*-* } 0 }
Index: libstdc++-v3/testsuite/23_containers/map/48101_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/23_containers/map/48101_neg.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/23_containers/map/48101_neg.cc	(.../branches/gcc-8-branch)
@@ -23,8 +23,10 @@
 void
 test01()
 {
-  std::map<int, int, std::less<int*>> c;      // { dg-error "here" }
-  std::map<int, int, std::allocator<int>> c2; // { dg-error "here" }
+  std::map<int, int, std::less<int*>> c;
+  std::map<int, int, std::allocator<int>> c2;
 }
 
+// { dg-error "_Compare = std::less<int.>" "" { target *-*-* } 0 }
+// { dg-error "_Compare = std::allocator<int>" "" { target *-*-* } 0 }
 // { dg-error "comparison object must be invocable" "" { target *-*-* } 0 }
Index: libstdc++-v3/testsuite/27_io/filesystem/operations/absolute.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/27_io/filesystem/operations/absolute.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/27_io/filesystem/operations/absolute.cc	(.../branches/gcc-8-branch)
@@ -50,9 +50,37 @@
   VERIFY( absolute(p3) == (std::filesystem::current_path()/p3) );
 }
 
+void
+test03()
+{
+  // PR libstdc++/90299
+  const path p = __gnu_test::nonexistent_path();
+  std::error_code ec;
+  const path pabs = absolute(p, ec);
+  VERIFY( !ec );
+  VERIFY( pabs.is_absolute() );
+
+  const path pabs2 = absolute(p);
+  VERIFY( pabs2 == pabs );
+
+  const path eabs = absolute(path{}, ec);
+  VERIFY( ec == std::errc::invalid_argument );
+  VERIFY( eabs.empty() );
+
+  try {
+    absolute(path{});
+    VERIFY( false );
+  } catch (const std::filesystem::filesystem_error& e) {
+    VERIFY( e.code() == std::errc::invalid_argument );
+    VERIFY( e.path1().empty() );
+    VERIFY( e.path2().empty() );
+  }
+}
+
 int
 main()
 {
   test01();
   test02();
+  test03();
 }
Index: libstdc++-v3/testsuite/27_io/filesystem/iterators/caching.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/27_io/filesystem/iterators/caching.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/27_io/filesystem/iterators/caching.cc	(.../branches/gcc-8-branch)
@@ -0,0 +1,76 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17 -lstdc++fs" }
+// { dg-do run { target c++17 } }
+// { dg-require-filesystem-ts "" }
+
+#include <filesystem>
+#include <testsuite_fs.h>
+#include <testsuite_hooks.h>
+
+namespace fs = std::filesystem;
+
+__gnu_test::scoped_file
+create_dir(fs::path dir = __gnu_test::nonexistent_path())
+{
+  fs::create_directory(dir);
+  return { dir, __gnu_test::scoped_file::adopt_file };
+}
+
+void
+test01()
+{
+  auto testdir = create_dir();
+  __gnu_test::scoped_file file1(testdir.path/"file1");
+  __gnu_test::scoped_file file2(testdir.path/"file2");
+
+  fs::directory_iterator it(testdir.path);
+  VERIFY( it->is_regular_file() );
+  ++it;
+  VERIFY( it->is_regular_file() );
+  ++it;
+  VERIFY( it == fs::directory_iterator{} );
+}
+
+void
+test02()
+{
+  auto testdir = create_dir();
+  const auto sub1 = create_dir(testdir.path/"sub1");
+  __gnu_test::scoped_file file1(sub1.path / "file");
+  const auto sub2 = create_dir(testdir.path/"sub2");
+  __gnu_test::scoped_file file2(sub2.path / "file");
+
+  fs::recursive_directory_iterator it(testdir.path);
+  VERIFY( it->is_directory() );
+  ++it;
+  VERIFY( it->is_regular_file() );
+  ++it;
+  VERIFY( it->is_directory() );
+  ++it;
+  VERIFY( it->is_regular_file() );
+  ++it;
+  VERIFY( it == fs::recursive_directory_iterator{} );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
Index: libstdc++-v3/testsuite/27_io/filesystem/path/assign/copy.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/27_io/filesystem/path/assign/copy.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/27_io/filesystem/path/assign/copy.cc	(.../branches/gcc-8-branch)
@@ -21,6 +21,7 @@
 
 #include <filesystem>
 #include <testsuite_fs.h>
+#include <testsuite_hooks.h>
 
 using std::filesystem::path;
 using __gnu_test::compare_paths;
@@ -48,9 +49,26 @@
   }
 }
 
+void
+test03()
+{
+  // self assignment should have no effect
+  const path orig = "foo/bar/baz";
+  path p = orig;
+  const auto ptr1 = p.c_str();
+  const auto ptr2 = p.begin()->c_str();
+  p = std::move(p);
+  __gnu_test::compare_paths(p, orig);
+  p = p;
+  __gnu_test::compare_paths(p, orig);
+  VERIFY( ptr1 == p.c_str() );
+  VERIFY( ptr2 == p.begin()->c_str() );
+}
+
 int
 main()
 {
   test01();
   test02();
+  test03();
 }
Index: libstdc++-v3/testsuite/27_io/filesystem/path/construct/90634.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/27_io/filesystem/path/construct/90634.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/27_io/filesystem/path/construct/90634.cc	(.../branches/gcc-8-branch)
@@ -0,0 +1,70 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17 -lstdc++fs" }
+// { dg-do run { target c++17 } }
+// { dg-require-filesystem-ts "" }
+
+#include <filesystem>
+#include <cstdlib>
+#include <testsuite_hooks.h>
+
+std::size_t bytes_allocated = 0;
+
+void* operator new(std::size_t n)
+{
+  bytes_allocated += n;
+  return std::malloc(n);
+}
+
+void operator delete(void* p) noexcept { std::free(p); }
+#if __cpp_sized_deallocation
+void operator delete(void* p, std::size_t) noexcept { std::free(p); }
+#endif
+
+void
+test01()
+{
+  std::string s0;
+  std::string s1 = "/";
+  std::string s2 = "///";
+  std::string s3 = "filename";
+  std::string s4 = "C:";
+  std::string s5 = "\\";
+
+  using std::filesystem::path;
+
+  bytes_allocated = 0;
+  path p0 = std::move(s0);
+  VERIFY( bytes_allocated == 0 );
+  path p1 = std::move(s1);
+  VERIFY( bytes_allocated == 0 );
+  path p2 = std::move(s2);
+  VERIFY( bytes_allocated == 0 );
+  path p3 = std::move(s3);
+  VERIFY( bytes_allocated == 0 );
+  path p4 = std::move(s4);
+  VERIFY( bytes_allocated == 0 );
+  path p5 = std::move(s5);
+  VERIFY( bytes_allocated == 0 );
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/27_io/filesystem/path/construct/80762.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/27_io/filesystem/path/construct/80762.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/27_io/filesystem/path/construct/80762.cc	(.../branches/gcc-8-branch)
@@ -22,8 +22,18 @@
 
 using std::filesystem::path;
 
+// PR libstdc++/80762.cc
 static_assert( !std::is_constructible_v<path, void> );
 static_assert( !std::is_constructible_v<path, volatile path> );
 static_assert( !std::is_constructible_v<path, volatile path&> );
 static_assert( !std::is_constructible_v<path, const volatile path> );
 static_assert( !std::is_constructible_v<path, const volatile path&> );
+
+// PR libstdc++/90454.cc
+static_assert( !std::is_constructible_v<path, void*> );
+static_assert( !std::is_constructible_v<path, const void*> );
+static_assert( !std::is_constructible_v<path, volatile void*> );
+static_assert( !std::is_constructible_v<path, const volatile void*> );
+static_assert( !std::is_constructible_v<path, void*&> );
+static_assert( !std::is_constructible_v<path, void* const&> );
+static_assert( !std::is_constructible_v<path, const void* const&> );
Index: libstdc++-v3/testsuite/27_io/filesystem/path/decompose/root_path.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/27_io/filesystem/path/decompose/root_path.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/27_io/filesystem/path/decompose/root_path.cc	(.../branches/gcc-8-branch)
@@ -36,10 +36,6 @@
   VERIFY( p2.root_path() == path("/") );
 }
 
-#undef VERIFY
-#define VERIFY(X) do { if (!(X)) { __builtin_puts("FAIL: " #X); } } while(false)
-#define DUMP(X, Y, Z) do { if (!(Y == Z)) { __builtin_printf("%s %s %s\n", X.c_str(), Y.c_str(), Z.c_str()); } } while(false)
-
 void
 test02()
 {
@@ -49,7 +45,6 @@
     path rootn = p.root_name();
     path rootd = p.root_directory();
     VERIFY( rootp == (rootn / rootd) );
-    DUMP(p,  rootp , (rootn / rootd) );
   }
 }
 
Index: libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/89446.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/89446.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/89446.cc	(.../branches/gcc-8-branch)
@@ -0,0 +1,28 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17 -fexceptions -fnon-call-exceptions -O1" }
+// { dg-do run { target { powerpc*-*-linux* i?86-*-linux* x86_64-*-linux* } } }
+// { dg-require-effective-target c++17 }
+
+#include <string_view>
+
+int main()
+{
+  std::string_view s1, s2;
+  return s1 != s2;
+}
Index: libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc	(.../branches/gcc-8-branch)
@@ -24,6 +24,7 @@
 
 using std::experimental::any;
 using std::experimental::any_cast;
+using std::experimental::bad_any_cast;
 
 void test01()
 {
@@ -56,7 +57,6 @@
 
 void test02()
 {
-  using std::experimental::bad_any_cast;
   any x(1);
   auto p = any_cast<double>(&x);
   VERIFY(p == nullptr);
@@ -105,7 +105,7 @@
   MoveDeleted&& md3 = any_cast<MoveDeleted&&>(any(std::move(md)));
 }
 
-void test04()
+void test05()
 {
   // PR libstdc++/69321
   struct noncopyable {
@@ -117,10 +117,60 @@
   VERIFY( p == nullptr );
 }
 
+void test06()
+{
+  // The contained value of a std::any is always an object type,
+  // but any_cast does not forbid checking for function types.
+
+  any a(1);
+  void (*p1)() = any_cast<void()>(&a);
+  VERIFY( p1 == nullptr );
+  int (*p2)(int) = any_cast<int(int)>(&a);
+  VERIFY( p2 == nullptr );
+  int (*p3)() = any_cast<int()>(&const_cast<const any&>(a));
+  VERIFY( p3 == nullptr );
+
+  try {
+    any_cast<int(&)()>(a);
+    VERIFY( false );
+  } catch (const bad_any_cast&) {
+  }
+
+  try {
+    any_cast<int(&)()>(std::move(a));
+    VERIFY( false );
+  } catch (const bad_any_cast&) {
+  }
+
+  try {
+    any_cast<int(&)()>(const_cast<const any&>(a));
+    VERIFY( false );
+  } catch (const bad_any_cast&) {
+  }
+}
+
+void test07()
+{
+  int arr[3];
+  any a(arr);
+  VERIFY( a.type() == typeid(int*) );	// contained value is decayed
+
+  int (*p1)[3] = any_cast<int[3]>(&a);
+  VERIFY( a.type() != typeid(int[3]) ); // so any_cast should return nullptr
+  VERIFY( p1 == nullptr );
+  int (*p2)[] = any_cast<int[]>(&a);
+  VERIFY( a.type() != typeid(int[]) );	// so any_cast should return nullptr
+  VERIFY( p2 == nullptr );
+  const int (*p3)[] = any_cast<int[]>(&const_cast<const any&>(a));
+  VERIFY( p3 == nullptr );
+}
+
 int main()
 {
   test01();
   test02();
   test03();
-  test04();
+  test05();
+  test06();
+  test07();
 }
Index: libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc	(.../branches/gcc-8-branch)
@@ -25,5 +25,5 @@
   using std::experimental::any_cast;
 
   const any y(1);
-  any_cast<int&>(y); // { dg-error "qualifiers" "" { target { *-*-* } } 357 }
+  any_cast<int&>(y); // { dg-error "qualifiers" "" { target { *-*-* } } 0 }
 }
Index: libstdc++-v3/testsuite/experimental/filesystem/path/construct/90634.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/filesystem/path/construct/90634.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/experimental/filesystem/path/construct/90634.cc	(.../branches/gcc-8-branch)
@@ -0,0 +1,67 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-DUSE_FILESYSTEM_TS -lstdc++fs" }
+// { dg-do run { target c++11 } }
+// { dg-require-filesystem-ts "" }
+
+#include <experimental/filesystem>
+#include <cstdlib>
+#include <testsuite_hooks.h>
+
+std::size_t bytes_allocated = 0;
+
+void* operator new(std::size_t n)
+{
+  bytes_allocated += n;
+  return std::malloc(n);
+}
+
+void operator delete(void* p) noexcept { std::free(p); }
+#if __cpp_sized_deallocation
+void operator delete(void* p, std::size_t) noexcept { std::free(p); }
+#endif
+
+void
+test01()
+{
+  std::string s0;
+  std::string s1 = "/";
+  std::string s2 = "filename";
+  std::string s3 = "C:";
+  std::string s4 = "\\";
+
+  using std::experimental::filesystem::path;
+
+  bytes_allocated = 0;
+  path p0 = std::move(s0);
+  VERIFY( bytes_allocated == 0 );
+  path p1 = std::move(s1);
+  VERIFY( bytes_allocated == 0 );
+  path p2 = std::move(s2);
+  VERIFY( bytes_allocated == 0 );
+  path p3 = std::move(s3);
+  VERIFY( bytes_allocated == 0 );
+  path p4 = std::move(s4);
+  VERIFY( bytes_allocated == 0 );
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/experimental/filesystem/path/construct/80762.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/filesystem/path/construct/80762.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/experimental/filesystem/path/construct/80762.cc	(.../branches/gcc-8-branch)
@@ -22,8 +22,18 @@
 
 using std::experimental::filesystem::path;
 
+// PR libstdc++/80762.cc
 static_assert( !std::is_constructible<path, void>::value, "" );
 static_assert( !std::is_constructible<path, volatile path>::value, "" );
 static_assert( !std::is_constructible<path, volatile path&>::value, "" );
 static_assert( !std::is_constructible<path, const volatile path>::value, "" );
 static_assert( !std::is_constructible<path, const volatile path&>::value, "" );
+
+// PR libstdc++/90454.cc
+static_assert( !std::is_constructible<path, void*>::value, "" );
+static_assert( !std::is_constructible<path, const void*>::value, "" );
+static_assert( !std::is_constructible<path, volatile void*>::value, "" );
+static_assert( !std::is_constructible<path, const volatile void*>::value, "" );
+static_assert( !std::is_constructible<path, void*&>::value, "" );
+static_assert( !std::is_constructible<path, void* const&>::value, "" );
+static_assert( !std::is_constructible<path, const void* const&>::value, "" );
Index: libstdc++-v3/testsuite/util/thread/all.h
===================================================================
--- a/src/libstdc++-v3/testsuite/util/thread/all.h	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/util/thread/all.h	(.../branches/gcc-8-branch)
@@ -25,6 +25,7 @@
 #include <sstream>
 #include <stdexcept>
 #include <type_traits>
+#include <thread>
 
 // C++11 only.
 namespace __gnu_test
@@ -39,7 +40,12 @@
 
       // Remove possible pointer type.
       typedef typename test_type::native_handle_type native_handle;
-      typedef typename std::remove_pointer<native_handle>::type native_type;
+      // For std::thread native_handle_type is the type of its data member,
+      // for other types it's a pointer to the type of the data member.
+      typedef typename std::conditional<
+	std::is_same<test_type, std::thread>::value,
+	native_handle,
+	typename std::remove_pointer<native_handle>::type>::type native_type;
 
       int st = sizeof(test_type);
       int snt = sizeof(native_type);
Index: libstdc++-v3/testsuite/util/testsuite_hooks.h
===================================================================
--- a/src/libstdc++-v3/testsuite/util/testsuite_hooks.h	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/util/testsuite_hooks.h	(.../branches/gcc-8-branch)
@@ -46,18 +46,25 @@
 #include <bits/c++config.h>
 #include <bits/functexcept.h>
 #include <ctime>
+#include <stdio.h>
 
 #ifdef _GLIBCXX_HAVE_SYS_STAT_H
 #include <sys/stat.h>
 #endif
 
+#ifdef stderr
+# define _VERIFY_PRINT(S, F, L, P, C) __builtin_fprintf(stderr, S, F, L, P, C)
+#else
+# define _VERIFY_PRINT(S, F, L, P, C) __builtin_printf(S, F, L, P, C)
+#endif
+
 #define VERIFY(fn)                                                      \
   do                                                                    \
   {                                                                     \
     if (! (fn))								\
       {									\
-	__builtin_printf("%s:%d: %s: Assertion '%s' failed.\n",		\
-			 __FILE__, __LINE__, __PRETTY_FUNCTION__, #fn); \
+	_VERIFY_PRINT("%s:%d: %s: Assertion '%s' failed.\n",		\
+		      __FILE__, __LINE__, __PRETTY_FUNCTION__, #fn);	\
 	__builtin_abort();						\
       }									\
   } while (false)
Index: libstdc++-v3/testsuite/20_util/scoped_allocator/69293_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/scoped_allocator/69293_neg.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/scoped_allocator/69293_neg.cc	(.../branches/gcc-8-branch)
@@ -46,5 +46,5 @@
   scoped_alloc sa;
   auto p = sa.allocate(1);
   sa.construct(p);  // this is required to be ill-formed
-  // { dg-error "static assertion failed" "" { target *-*-* } 90 }
+  // { dg-error "failed: .* uses_allocator is true" "" { target *-*-* } 0 }
 }
Index: libstdc++-v3/testsuite/20_util/scoped_allocator/dr2586.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/scoped_allocator/dr2586.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/scoped_allocator/dr2586.cc	(.../branches/gcc-8-branch)
@@ -0,0 +1,34 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <memory>
+#include <scoped_allocator>
+
+// DR 2586. Wrong value category used in scoped_allocator_adaptor::construct()
+
+struct X {
+  using allocator_type = std::allocator<X>;
+  X(std::allocator_arg_t, allocator_type&&) { }
+  X(const allocator_type&) { }
+};
+
+int main() {
+  std::scoped_allocator_adaptor<std::allocator<X>> sa;
+  sa.construct(sa.allocate(1));
+}
Index: libstdc++-v3/testsuite/20_util/hash/89629.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/hash/89629.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/hash/89629.cc	(.../branches/gcc-8-branch)
@@ -0,0 +1,43 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target { lp64 || llp64 } } }
+// { dg-require-effective-target c++11 }
+// { dg-require-effective-target run_expensive_tests }
+
+#include <functional>
+#include <string>
+
+void
+test01()
+{
+  const std::size_t big = std::size_t(1) << 31;
+  std::string s;
+  try {
+    s.resize(big, 'a');
+  } catch (const std::bad_alloc&) {
+    return; // try to avoid a FAIL if memory allocation fails
+  }
+  // PR libstdc++/89629
+  (void) std::hash<std::string>{}(s);
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/20_util/any/misc/any_cast.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/any/misc/any_cast.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/any/misc/any_cast.cc	(.../branches/gcc-8-branch)
@@ -20,6 +20,7 @@
 
 #include <any>
 #include <string>
+#include <utility>
 #include <cstring>
 #include <testsuite_hooks.h>
 
@@ -121,6 +122,54 @@
   VERIFY( p == nullptr );
 }
 
+void test06()
+{
+  // The contained value of a std::any is always an object type,
+  // but std::any_cast does not forbid checking for function types.
+
+  any a(1);
+  void (*p1)() = any_cast<void()>(&a);
+  VERIFY( p1 == nullptr );
+  int (*p2)(int) = any_cast<int(int)>(&a);
+  VERIFY( p2 == nullptr );
+  int (*p3)() = any_cast<int()>(&std::as_const(a));
+  VERIFY( p3 == nullptr );
+
+  try {
+    any_cast<int(&)()>(a);
+    VERIFY( false );
+  } catch (const std::bad_any_cast&) {
+  }
+
+  try {
+    any_cast<int(&)()>(std::move(a));
+    VERIFY( false );
+  } catch (const std::bad_any_cast&) {
+  }
+
+  try {
+    any_cast<int(&)()>(std::as_const(a));
+    VERIFY( false );
+  } catch (const std::bad_any_cast&) {
+  }
+}
+
+void test07()
+{
+  int arr[3];
+  any a(arr);
+  VERIFY( a.type() == typeid(int*) );	// contained value is decayed
+
+  int (*p1)[3] = any_cast<int[3]>(&a);
+  VERIFY( a.type() != typeid(int[3]) ); // so any_cast should return nullptr
+  VERIFY( p1 == nullptr );
+  int (*p2)[] = any_cast<int[]>(&a);
+  VERIFY( a.type() != typeid(int[]) );	// so any_cast should return nullptr
+  VERIFY( p2 == nullptr );
+  const int (*p3)[] = any_cast<int[]>(&std::as_const(a));
+  VERIFY( p3 == nullptr );
+}
+
 int main()
 {
   test01();
@@ -128,4 +177,6 @@
   test03();
   test04();
   test05();
+  test06();
+  test07();
 }
Index: libstdc++-v3/testsuite/20_util/variant/compile.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/variant/compile.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/variant/compile.cc	(.../branches/gcc-8-branch)
@@ -129,10 +129,15 @@
   static_assert(noexcept(variant<int, DefaultNoexcept>(DefaultNoexcept{})), "");
 }
 
+struct none { none() = delete; };
+struct any { template <typename T> any(T&&) {} };
+
 void in_place_index_ctor()
 {
   variant<string, string> a(in_place_index<0>, "a");
   variant<string, string> b(in_place_index<1>, {'a'});
+
+  static_assert(!is_constructible_v<variant<none, any>, std::in_place_index_t<0>>, "PR libstdc++/90165");
 }
 
 void in_place_type_ctor()
@@ -140,6 +145,7 @@
   variant<int, string, int> a(in_place_type<string>, "a");
   variant<int, string, int> b(in_place_type<string>, {'a'});
   static_assert(!is_constructible_v<variant<string, string>, in_place_type_t<string>, const char*>, "");
+  static_assert(!is_constructible_v<variant<none, any>, std::in_place_type_t<none>>, "PR libstdc++/90165");
 }
 
 void dtor()
Index: libstdc++-v3/testsuite/20_util/tuple/cons/allocators.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/tuple/cons/allocators.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/tuple/cons/allocators.cc	(.../branches/gcc-8-branch)
@@ -181,9 +181,23 @@
   test_type empty = make_tuple();
 }
 
+void test03()
+{
+  struct dr2586
+  {
+    using allocator_type = std::allocator<int>;
+    dr2586(std::allocator_arg_t, allocator_type&&) { }
+    dr2586(const allocator_type&) { }
+  };
+
+  const dr2586::allocator_type a;
+  std::tuple<dr2586> t{std::allocator_arg, a};
+}
+
 int main()
 {
   test01();
   test02();
+  test03();
   return 0;
 }
Index: libstdc++-v3/testsuite/20_util/is_trivially_default_constructible/value.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/is_trivially_default_constructible/value.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/is_trivially_default_constructible/value.cc	(.../branches/gcc-8-branch)
@@ -62,4 +62,13 @@
 		construct::Nontrivial>(false), "");
   static_assert(test_category<is_trivially_default_constructible, 
 		HasTemplateCtor>(true), "");
+
+  static_assert(test_category<is_trivially_default_constructible,
+		int[]>(false), "PR c++/90532");
+  struct A { };
+  static_assert(test_category<is_trivially_default_constructible,
+		A[]>(false), "PR c++/90532");
+  struct B { B() { } };
+  static_assert(test_category<is_trivially_default_constructible,
+		B[]>(false), "PR c++/90532");
 }
Index: libstdc++-v3/testsuite/20_util/uses_allocator/cons_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/uses_allocator/cons_neg.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/uses_allocator/cons_neg.cc	(.../branches/gcc-8-branch)
@@ -43,4 +43,4 @@
 
   tuple<Type> t(allocator_arg, a, 1);
 }
-// { dg-error "static assertion failed" "" { target *-*-* } 90 }
+// { dg-error "failed: .* uses_allocator is true" "" { target *-*-* } 0 }
Index: libstdc++-v3/testsuite/20_util/uses_allocator/69293_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/uses_allocator/69293_neg.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/uses_allocator/69293_neg.cc	(.../branches/gcc-8-branch)
@@ -44,5 +44,5 @@
 {
   alloc_type a;
   std::tuple<X> t(std::allocator_arg, a); // this is required to be ill-formed
-  // { dg-error "static assertion failed" "" { target *-*-* } 90 }
+  // { dg-error "failed: .* uses_allocator is true" "" { target *-*-* } 0 }
 }
Index: libstdc++-v3/testsuite/20_util/is_default_constructible/value.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/is_default_constructible/value.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/is_default_constructible/value.cc	(.../branches/gcc-8-branch)
@@ -138,3 +138,13 @@
 static_assert(!std::is_default_constructible<const DelCopy>::value, "Error");
 static_assert(!std::is_default_constructible<DelDtor>::value, "Error");
 static_assert(!std::is_default_constructible<const DelDtor>::value, "Error");
+
+static_assert(!std::is_default_constructible<int[]>::value, "PR c++/90532");
+static_assert(!std::is_default_constructible<Empty[]>::value, "PR c++/90532");
+static_assert(!std::is_default_constructible<B[]>::value, "PR c++/90532");
+static_assert(!std::is_default_constructible<D[]>::value, "PR c++/90532");
+static_assert(!std::is_default_constructible<U[]>::value, "PR c++/90532");
+static_assert(!std::is_default_constructible<Ukn[]>::value, "PR c++/90532");
+static_assert(!std::is_default_constructible<Ellipsis[]>::value, "PR c++/90532");
+static_assert(!std::is_default_constructible<Any[]>::value, "PR c++/90532");
+static_assert(!std::is_default_constructible<nAny[]>::value, "PR c++/90532");
Index: libstdc++-v3/testsuite/20_util/optional/constexpr/observers/4.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/optional/constexpr/observers/4.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/optional/constexpr/observers/4.cc	(.../branches/gcc-8-branch)
@@ -25,10 +25,42 @@
   int i;
 };
 
-int main()
+void test01()
 {
   constexpr std::optional<value_type> o { value_type { 51 } };
   constexpr value_type fallback { 3 };
-  static_assert( o.value_or(fallback).i == 51, "" );
-  static_assert( o.value_or(fallback).i == (*o).i, "" );
+  static_assert( o.value_or(fallback).i == 51 );
+  static_assert( o.value_or(fallback).i == (*o).i );
 }
+
+void test02()
+{
+  constexpr std::optional<value_type> o;
+  constexpr value_type fallback { 3 };
+  static_assert( o.value_or(fallback).i == 3 );
+}
+
+template<typename T>
+  constexpr std::optional<value_type>
+  make_rvalue(T t)
+  { return std::optional<value_type>{t}; }
+
+void test03()
+{
+  constexpr value_type fallback { 3 };
+  static_assert( make_rvalue(value_type{51}).value_or(fallback).i == 51 );
+}
+
+void test04()
+{
+  constexpr value_type fallback { 3 };
+  static_assert( make_rvalue(std::nullopt).value_or(fallback).i == 3 );
+}
+
+int main()
+{
+  test01();
+  test02();
+  test03();
+  test04();
+}
Index: libstdc++-v3/testsuite/20_util/optional/observers/4.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/optional/observers/4.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/optional/observers/4.cc	(.../branches/gcc-8-branch)
@@ -26,7 +26,7 @@
   int i;
 };
 
-int main()
+void test01()
 {
   std::optional<value_type> o { value_type { 51 } };
   value_type fallback { 3 };
@@ -33,3 +33,35 @@
   VERIFY( o.value_or(fallback).i == 51 );
   VERIFY( o.value_or(fallback).i == (*o).i );
 }
+
+void test02()
+{
+  std::optional<value_type> o;
+  value_type fallback { 3 };
+  VERIFY( o.value_or(fallback).i == 3 );
+}
+
+void test03()
+{
+  std::optional<value_type> o { value_type { 51 } };
+  value_type fallback { 3 };
+  VERIFY( std::move(o).value_or(fallback).i == 51 );
+  VERIFY( o.has_value() );
+  VERIFY( std::move(o).value_or(fallback).i == (*o).i );
+}
+
+void test04()
+{
+  std::optional<value_type> o;
+  value_type fallback { 3 };
+  VERIFY( std::move(o).value_or(fallback).i == 3 );
+  VERIFY( !o.has_value() );
+}
+
+int main()
+{
+  test01();
+  test02();
+  test03();
+  test04();
+}
Index: libstdc++-v3/testsuite/20_util/common_type/requirements/sfinae_friendly_1.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/common_type/requirements/sfinae_friendly_1.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/common_type/requirements/sfinae_friendly_1.cc	(.../branches/gcc-8-branch)
@@ -159,7 +159,10 @@
   };
 }
 
+static_assert(is_type<std::common_type<int>, int>(), "");
+static_assert(is_type<std::common_type<const int>, int>(), "");
 static_assert(is_type<std::common_type<int, int>, int>(), "");
+static_assert(is_type<std::common_type<const int, int>, int>(), "");
 static_assert(is_type<std::common_type<ScEn, ScEn>, ScEn>(), "");
 static_assert(is_type<std::common_type<UnscEn, UnscEn>, UnscEn>(), "");
 static_assert(is_type<std::common_type<UnscEn, int>, int>(), "");
@@ -180,6 +183,8 @@
 	      const volatile int*>(), "");
 static_assert(is_type<std::common_type<void*, const volatile int*>,
 	      const volatile void*>(), "");
+static_assert(is_type<std::common_type<void>, void>(), "");
+static_assert(is_type<std::common_type<const void>, void>(), "");
 static_assert(is_type<std::common_type<void, void>, void>(), "");
 static_assert(is_type<std::common_type<const void, const void>, void>(), "");
 static_assert(is_type<std::common_type<int&, int&&>, int>(), "");
@@ -316,6 +321,14 @@
 static_assert(!has_type<std::common_type<std::initializer_list<int>,
 					 std::initializer_list<long>>>(), "");
 
+// PR libstdc++/89102
+static_assert(!has_type<std::common_type<int() &>>(), "");
+static_assert(!has_type<std::common_type<int() & noexcept>>(), "");
+static_assert(!has_type<std::common_type<int() const>>(), "");
+static_assert(!has_type<std::common_type<int(...) &>>(), "");
+static_assert(!has_type<std::common_type<int(...) & noexcept>>(), "");
+static_assert(!has_type<std::common_type<int(...) const>>(), "");
+
 void test(int i)
 {
   auto local_lmd1 = [=](int, double) { return i + i; };
Index: libstdc++-v3/testsuite/20_util/common_type/requirements/sfinae_friendly_2.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/common_type/requirements/sfinae_friendly_2.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/common_type/requirements/sfinae_friendly_2.cc	(.../branches/gcc-8-branch)
@@ -25,7 +25,7 @@
 constexpr
 std::array<typename std::common_type<Args...>::type, 
   sizeof...(Args)>
-make_array(Args&&... args)  // { dg-error "invalid use" }
+make_array(Args&&... args)  // { dg-error "no type.*common_type<>" }
 {
   typedef typename std::common_type<Args...>::type CT;
   return std::array<CT, sizeof...(Args)>{static_cast<CT>
Index: libstdc++-v3/testsuite/20_util/common_type/requirements/explicit_instantiation.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/common_type/requirements/explicit_instantiation.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/common_type/requirements/explicit_instantiation.cc	(.../branches/gcc-8-branch)
@@ -30,6 +30,7 @@
   typedef void test_type5;
   typedef const void test_type6;  
 
+  template struct common_type<>;
   template struct common_type<test_type1>;
   template struct common_type<test_type1, test_type2>;
   template struct common_type<test_type1, test_type2, test_type3>;
Index: libstdc++-v3/testsuite/20_util/is_trivially_constructible/value.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/is_trivially_constructible/value.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/is_trivially_constructible/value.cc	(.../branches/gcc-8-branch)
@@ -180,4 +180,6 @@
 		MoveOnly, const MoveOnly&>(false), "");
   static_assert(test_property<is_trivially_constructible,
 		MoveOnly2>(false), "");
+  static_assert(test_property<is_trivially_constructible,
+		int[]>(false), "PR c++/90532");
 }
Index: libstdc++-v3/testsuite/20_util/is_constructible/value.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/is_constructible/value.cc	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/testsuite/20_util/is_constructible/value.cc	(.../branches/gcc-8-branch)
@@ -35,4 +35,11 @@
   static_assert(test_property<is_constructible, ExplicitClass>(false), "");
   static_assert(test_property<is_constructible, ExplicitClass,
 		int, double>(false), "");
+  static_assert(test_property<is_constructible, int[]>(false), "PR c++/90532");
+  static_assert(test_property<is_constructible,
+		__gnu_test::construct::Empty[]>(false), "PR c++/90532");
+  static_assert(test_property<is_constructible,
+		__gnu_test::construct::Ukn[]>(false), "PR c++/90532");
+  static_assert(test_property<is_constructible,
+		__gnu_test::construct::nAny[]>(false), "PR c++/90532");
 }
Index: libstdc++-v3/config/os/bsd/darwin/ppc-extra.ver
===================================================================
--- a/src/libstdc++-v3/config/os/bsd/darwin/ppc-extra.ver	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/config/os/bsd/darwin/ppc-extra.ver	(.../branches/gcc-8-branch)
@@ -1 +1,22 @@
   __eprintf;
+# 3.4
+  _ZNSt14numeric_limitsIgE*;
+  _ZNSirsERg;
+  _ZNSolsEg;
+  _ZNSt13basic_istreamIwSt11char_traitsIwEErsERg;
+  _ZNSt13basic_ostreamIwSt11char_traitsIwEElsEg;
+  _ZSt14__convert_to_vIgEvPKcRT_RSt12_Ios_IostateRKP*;
+  _ZStlsIg[cw]St11char_traitsI[cw]EERSt13basic_ostreamIT0_T1_ES6_RKSt7complexIT_E;
+  _ZStrsIg[cw]St11char_traitsI[cw]EERSt13basic_istreamIT0_T1_ES6_RSt7complexIT_E;
+# 3.4.7
+  _ZNSi10_M_extractIgEERSiRT_;
+  _ZNSt13basic_istreamIwSt11char_traitsIwEE10_M_extractIgEERS2_RT_;
+  _ZNSo9_M_insertIgEERSoT_;
+  _ZNSt13basic_ostreamIwSt11char_traitsIwEE9_M_insertIgEERS2_T_;
+# 3.4.10
+  _ZNKSt3tr14hashIgEclEg;
+  _ZNKSt4hashIgEclEg;
+# ldbl 1.3
+  _ZT[IS]g;
+  _ZT[IS]Pg;
+  _ZT[IS]PKg;
Index: libstdc++-v3/acinclude.m4
===================================================================
--- a/src/libstdc++-v3/acinclude.m4	(.../tags/gcc_8_3_0_release)
+++ b/src/libstdc++-v3/acinclude.m4	(.../branches/gcc-8-branch)
@@ -642,28 +642,27 @@
 dnl
 AC_DEFUN([GLIBCXX_CONFIGURE_DOCBOOK], [
 
-AC_MSG_CHECKING([for docbook stylesheets for documentation creation])
-glibcxx_stylesheets=no
-if test x${XSLTPROC} = xyes && echo '<title/>' | xsltproc --noout --nonet --xinclude http://docbook.sourceforge.net/release/xsl-ns/current/xhtml-1_1/docbook.xsl - 2>/dev/null; then
-  glibcxx_stylesheets=yes
-fi
-AC_MSG_RESULT($glibcxx_stylesheets)
+glibcxx_docbook_url=http://docbook.sourceforge.net/release/xsl-ns/current/
 
 AC_MSG_CHECKING([for local stylesheet directory])
 glibcxx_local_stylesheets=no
-if test x"$glibcxx_stylesheets" = x"yes"; then
-  if test -d /usr/share/sgml/docbook/xsl-ns-stylesheets; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/sgml/docbook/xsl-ns-stylesheets
-  fi
-  if test -d /usr/share/xml/docbook/stylesheet/docbook-xsl-ns; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/xml/docbook/stylesheet/docbook-xsl-ns
-  fi
-  if test -d /usr/share/xml/docbook/stylesheet/nwalsh5/current; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/xml/docbook/stylesheet/nwalsh5/current
-  fi
+if test x${XMLCATALOG} = xyes && xsl_style_dir=`xmlcatalog "" $glibcxx_docbook_url 2>/dev/null`
+then
+  XSL_STYLE_DIR=`echo $xsl_style_dir | sed -n 's;^file://;;p'`
+  glibcxx_local_stylesheets=yes
+else
+  for dir in \
+    /usr/share/sgml/docbook/xsl-ns-stylesheets \
+    /usr/share/xml/docbook/stylesheet/docbook-xsl-ns \
+    /usr/share/xml/docbook/stylesheet/nwalsh5/current \
+    /usr/share/xml/docbook/stylesheet/nwalsh/current
+  do
+    if test -d $dir; then
+      glibcxx_local_stylesheets=yes
+      XSL_STYLE_DIR=$dir
+      break
+    fi
+  done
 fi
 AC_MSG_RESULT($glibcxx_local_stylesheets)
 
@@ -670,6 +669,16 @@
 if test x"$glibcxx_local_stylesheets" = x"yes"; then
   AC_SUBST(XSL_STYLE_DIR)
   AC_MSG_NOTICE($XSL_STYLE_DIR)
+
+  AC_MSG_CHECKING([for docbook stylesheets for documentation creation])
+  glibcxx_stylesheets=no
+  if test x${XMLCATALOG} = xno || xmlcatalog "" $glibcxx_docbook_url/xhtml/docbook.xsl >/dev/null 2>&1; then
+    if test x${XSLTPROC} = xyes && echo '<title/>' | xsltproc --noout --nonet --xinclude $glibcxx_docbook_url/xhtml/docbook.xsl - 2>/dev/null; then
+      glibcxx_stylesheets=yes
+    fi
+  fi
+  AC_MSG_RESULT($glibcxx_stylesheets)
+
 else
   glibcxx_stylesheets=no
 fi
Index: include/ChangeLog
===================================================================
--- a/src/include/ChangeLog	(.../tags/gcc_8_3_0_release)
+++ b/src/include/ChangeLog	(.../branches/gcc-8-branch)
@@ -1,3 +1,11 @@
+2019-04-08  Claudiu Zissulescu  <claziss@synopsys.com>
+
+	backport mainline
+	Vineet Gupta  <vgupta@synopsys.com>
+	PR 89877
+	* longlong.h [__arc__] (add_ssaaaa): Add cc clobber.
+	(sub_ddmmss): Likewise.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: include/longlong.h
===================================================================
--- a/src/include/longlong.h	(.../tags/gcc_8_3_0_release)
+++ b/src/include/longlong.h	(.../branches/gcc-8-branch)
@@ -199,7 +199,8 @@
 	   : "%r" ((USItype) (ah)),					\
 	     "rICal" ((USItype) (bh)),					\
 	     "%r" ((USItype) (al)),					\
-	     "rICal" ((USItype) (bl)))
+	     "rICal" ((USItype) (bl))					\
+	   : "cc")
 #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
   __asm__ ("sub.f	%1, %4, %5\n\tsbc	%0, %2, %3"		\
 	   : "=r" ((USItype) (sh)),					\
@@ -207,7 +208,8 @@
 	   : "r" ((USItype) (ah)),					\
 	     "rICal" ((USItype) (bh)),					\
 	     "r" ((USItype) (al)),					\
-	     "rICal" ((USItype) (bl)))
+	     "rICal" ((USItype) (bl))					\
+	   : "cc")
 
 #define __umulsidi3(u,v) ((UDItype)(USItype)u*(USItype)v)
 #ifdef __ARC_NORM__
Index: libiberty/simple-object-elf.c
===================================================================
--- a/src/libiberty/simple-object-elf.c	(.../tags/gcc_8_3_0_release)
+++ b/src/libiberty/simple-object-elf.c	(.../branches/gcc-8-branch)
@@ -549,6 +549,14 @@
       return NULL;
     }
 
+  if (eor->shstrndx == 0)
+    {
+      *errmsg = "invalid ELF shstrndx == 0";
+      *err = 0;
+      XDELETE (eor);
+      return NULL;
+    }
+
   return (void *) eor;
 }
 
Index: libiberty/ChangeLog
===================================================================
--- a/src/libiberty/ChangeLog	(.../tags/gcc_8_3_0_release)
+++ b/src/libiberty/ChangeLog	(.../branches/gcc-8-branch)
@@ -1,3 +1,12 @@
+2019-07-25  Richard Biener  <rguenther@suse.de>
+
+	PR lto/90924
+	Backport from mainline
+	2019-07-12  Ren Kimura  <rkx1209dev@gmail.com>
+
+	* simple-object-elf.c (simple_object_elf_match): Check zero value
+	shstrndx.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: contrib/ChangeLog
===================================================================
--- a/src/contrib/ChangeLog	(.../tags/gcc_8_3_0_release)
+++ b/src/contrib/ChangeLog	(.../branches/gcc-8-branch)
@@ -1,3 +1,7 @@
+2019-08-16  Uros Bizjak  <ubizjak@gmail.com>
+
+	* test_summary: Do not escape "=".
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: contrib/test_summary
===================================================================
--- a/src/contrib/test_summary	(.../tags/gcc_8_3_0_release)
+++ b/src/contrib/test_summary	(.../branches/gcc-8-branch)
@@ -127,7 +127,7 @@
   if (lang == "") lang = " "$2" "; else lang = " ";
 }
 $2 == "version" { save = $0; $1 = ""; $2 = ""; version = $0; gsub(/^ */, "", version); gsub(/\r$/, "", version); $0 = save; }
-/\===.*Summary/ { print ""; print; blanks=1; }
+/===.*Summary/ { print ""; print; blanks=1; }
 /tests ===/ || /^(Target|Host|Native)/ || $2 == "version" { print; blanks=1; }
 /^(XPASS|FAIL|UNRESOLVED|WARNING|ERROR|# of )/ { sub ("\r", ""); print; }
 /^using:/ { print ""; print; print ""; }
Index: libatomic/ChangeLog
===================================================================
--- a/src/libatomic/ChangeLog	(.../tags/gcc_8_3_0_release)
+++ b/src/libatomic/ChangeLog	(.../branches/gcc-8-branch)
@@ -1,3 +1,18 @@
+2019-03-20  Florian Weimer  <fweimer@redhat.com>
+
+	PR libgcc/60790
+	x86: Do not assume ELF constructors run before IFUNC resolvers.
+	* config/x86/host-config.h (libat_feat1_ecx, libat_feat1_edx):
+	Remove declarations.
+	(__libat_feat1, __libat_feat1_init): Declare.
+	(FEAT1_REGISTER): Define.
+	(load_feat1): New function.
+	(IFUNC_COND_1): Adjust.
+	* config/x86/init.c (libat_feat1_ecx, libat_feat1_edx)
+	(init_cpuid): Remove definitions.
+	(__libat_feat1): New variable.
+	(__libat_feat1_init): New function.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: libatomic/config/x86/init.c
===================================================================
--- a/src/libatomic/config/x86/init.c	(.../tags/gcc_8_3_0_release)
+++ b/src/libatomic/config/x86/init.c	(.../branches/gcc-8-branch)
@@ -26,13 +26,17 @@
 
 #if HAVE_IFUNC
 
-unsigned int libat_feat1_ecx, libat_feat1_edx;
+unsigned int __libat_feat1;
 
-static void __attribute__((constructor))
-init_cpuid (void)
+unsigned int
+__libat_feat1_init (void)
 {
-  unsigned int eax, ebx;
-  __get_cpuid (1, &eax, &ebx, &libat_feat1_ecx, &libat_feat1_edx);
+  unsigned int eax, ebx, ecx, edx;
+  FEAT1_REGISTER = 0;
+  __get_cpuid (1, &eax, &ebx, &ecx, &edx);
+  /* See the load in load_feat1.  */
+  __atomic_store_n (&__libat_feat1, FEAT1_REGISTER, __ATOMIC_RELAXED);
+  return FEAT1_REGISTER;
 }
 
 #endif /* HAVE_IFUNC */
Index: libatomic/config/x86/host-config.h
===================================================================
--- a/src/libatomic/config/x86/host-config.h	(.../tags/gcc_8_3_0_release)
+++ b/src/libatomic/config/x86/host-config.h	(.../branches/gcc-8-branch)
@@ -25,13 +25,39 @@
 #if HAVE_IFUNC
 #include <cpuid.h>
 
-extern unsigned int libat_feat1_ecx HIDDEN;
-extern unsigned int libat_feat1_edx HIDDEN;
+#ifdef __x86_64__
+# define FEAT1_REGISTER ecx
+#else
+# define FEAT1_REGISTER edx
+#endif
 
+/* Value of the CPUID feature register FEAT1_REGISTER for the cmpxchg
+   bit for IFUNC_COND1 below.  */
+extern unsigned int __libat_feat1 HIDDEN;
+
+/* Initialize libat_feat1 and return its value.  */
+unsigned int __libat_feat1_init (void) HIDDEN;
+
+/* Return the value of the relevant feature register for the relevant
+   cmpxchg bit, or 0 if there is no CPUID support.  */
+static inline unsigned int
+__attribute__ ((const))
+load_feat1 (void)
+{
+  /* See the store in __libat_feat1_init.  */
+  unsigned int feat1 = __atomic_load_n (&__libat_feat1, __ATOMIC_RELAXED);
+  if (feat1 == 0)
+    /* Assume that initialization has not happened yet.  This may get
+       called repeatedly if the CPU does not have any feature bits at
+       all.  */
+    feat1 = __libat_feat1_init ();
+  return feat1;
+}
+
 #ifdef __x86_64__
-# define IFUNC_COND_1	(libat_feat1_ecx & bit_CMPXCHG16B)
+# define IFUNC_COND_1	(load_feat1 () & bit_CMPXCHG16B)
 #else
-# define IFUNC_COND_1	(libat_feat1_edx & bit_CMPXCHG8B)
+# define IFUNC_COND_1	(load_feat1 () & bit_CMPXCHG8B)
 #endif
 
 #ifdef __x86_64__
Index: libgcc/ChangeLog
===================================================================
--- a/src/libgcc/ChangeLog	(.../tags/gcc_8_3_0_release)
+++ b/src/libgcc/ChangeLog	(.../branches/gcc-8-branch)
@@ -1,3 +1,10 @@
+2019-08-11  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-12  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin-vecsave.S: Set .machine appropriately.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: libgcc/config/rs6000/darwin-vecsave.S
===================================================================
--- a/src/libgcc/config/rs6000/darwin-vecsave.S	(.../tags/gcc_8_3_0_release)
+++ b/src/libgcc/config/rs6000/darwin-vecsave.S	(.../branches/gcc-8-branch)
@@ -31,8 +31,14 @@
    (4 bytes) to do the operation; for Vector regs, 2 instructions are
    required (8 bytes.).   */
 
+/* With some assemblers, we need the correct machine directive to get the
+   right CPU type / subtype in the file header.  */
+#if	__ppc64__
+	.machine ppc64
+#else
 	.machine ppc7400
-.text
+#endif
+	.text
 	.align 2
 
 .private_extern saveVEC
Index: gcc/attribs.c
===================================================================
--- a/src/gcc/attribs.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/attribs.c	(.../branches/gcc-8-branch)
@@ -1685,8 +1685,11 @@
 	     a function global scope, unless declared static.  */
 	  if (current_function_decl != NULL_TREE && !TREE_STATIC (node))
 	    TREE_PUBLIC (node) = 1;
-	  /* Clear TREE_STATIC because DECL_EXTERNAL is set.  */
-	  TREE_STATIC (node) = 0;
+	  /* Clear TREE_STATIC because DECL_EXTERNAL is set, unless
+	     it is a C++ static data member.  */
+	  if (DECL_CONTEXT (node) == NULL_TREE
+	      || !RECORD_OR_UNION_TYPE_P (DECL_CONTEXT (node)))
+	    TREE_STATIC (node) = 0;
 	}
 
       if (*no_add_attrs == false)
Index: gcc/opts-common.c
===================================================================
--- a/src/gcc/opts-common.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/opts-common.c	(.../branches/gcc-8-branch)
@@ -463,7 +463,8 @@
 
   extra_args = 0;
 
-  opt_index = find_opt (argv[0] + 1, lang_mask);
+  const char *opt_value = argv[0] + 1;
+  opt_index = find_opt (opt_value, lang_mask);
   i = 0;
   while (opt_index == OPT_SPECIAL_unknown
 	 && i < ARRAY_SIZE (option_map))
@@ -666,7 +667,24 @@
   /* Check if this is a switch for a different front end.  */
   if (!option_ok_for_language (option, lang_mask))
     errors |= CL_ERR_WRONG_LANG;
+  else if (strcmp (option->opt_text, "-Werror=") == 0
+	   && strchr (opt_value, ',') == NULL)
+    {
+      /* Verify that -Werror argument is a valid warning
+	 for a language.  */
+      char *werror_arg = xstrdup (opt_value + 6);
+      werror_arg[0] = 'W';
 
+      size_t warning_index = find_opt (werror_arg, lang_mask);
+      if (warning_index != OPT_SPECIAL_unknown)
+	{
+	  const struct cl_option *warning_option
+	    = &cl_options[warning_index];
+	  if (!option_ok_for_language (warning_option, lang_mask))
+	    errors |= CL_ERR_WRONG_LANG;
+	}
+    }
+
   /* Convert the argument to lowercase if appropriate.  */
   if (arg && option->cl_tolower)
     {
Index: gcc/c-family/ChangeLog
===================================================================
--- a/src/gcc/c-family/ChangeLog	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/c-family/ChangeLog	(.../branches/gcc-8-branch)
@@ -1,3 +1,26 @@
+2019-05-22  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2018-05-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR c++/85400
+	* c-attribs.c (handle_visibility_attribute): Do not set no_add_attrs.
+
+2019-04-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89946
+	* c-attribs.c (handle_patchable_function_entry_attribute): Add
+	function comment.  Warn if arguments of the attribute are not positive
+	integer constants.
+
+2019-04-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* c-ada-spec.c (print_destructor): Deal with deleting destructors.
+	(dump_ada_declaration) <FUNCTION_DECL>: Likewise.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: gcc/c-family/c-attribs.c
===================================================================
--- a/src/gcc/c-family/c-attribs.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/c-family/c-attribs.c	(.../branches/gcc-8-branch)
@@ -2310,14 +2310,13 @@
 
 static tree
 handle_tls_model_attribute (tree *node, tree name, tree args,
-			    int ARG_UNUSED (flags), bool *no_add_attrs)
+			    int ARG_UNUSED (flags),
+			    bool *ARG_UNUSED (no_add_attrs))
 {
   tree id;
   tree decl = *node;
   enum tls_model kind;
 
-  *no_add_attrs = true;
-
   if (!VAR_P (decl) || !DECL_THREAD_LOCAL_P (decl))
     {
       warning (OPT_Wattributes, "%qE attribute ignored", name);
@@ -3562,9 +3561,28 @@
   return NULL_TREE;
 }
 
+/* Handle a "patchable_function_entry" attributes; arguments as in
+   struct attribute_spec.handler.  */
+
 static tree
-handle_patchable_function_entry_attribute (tree *, tree, tree, int, bool *)
+handle_patchable_function_entry_attribute (tree *, tree name, tree args,
+					   int, bool *no_add_attrs)
 {
-  /* Nothing to be done here.  */
+  for (; args; args = TREE_CHAIN (args))
+    {
+      tree val = TREE_VALUE (args);
+      if (val && TREE_CODE (val) != IDENTIFIER_NODE
+	  && TREE_CODE (val) != FUNCTION_DECL)
+	val = default_conversion (val);
+
+      if (!tree_fits_uhwi_p (val))
+	{
+	  warning (OPT_Wattributes,
+		   "%qE attribute argument %qE is not an integer constant",
+		   name, val);
+	  *no_add_attrs = true;
+	  return NULL_TREE;
+	}
+    }
   return NULL_TREE;
 }
Index: gcc/c-family/c-ada-spec.c
===================================================================
--- a/src/gcc/c-family/c-ada-spec.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/c-family/c-ada-spec.c	(.../branches/gcc-8-branch)
@@ -2686,6 +2686,8 @@
   tree decl_name = DECL_NAME (TYPE_NAME (type));
 
   pp_string (buffer, "Delete_");
+  if (strncmp (IDENTIFIER_POINTER (DECL_NAME (t)), "__dt_del", 8) == 0)
+    pp_string (buffer, "And_Free_");
   pp_ada_tree_identifier (buffer, decl_name, t, 0, false);
 }
 
@@ -2937,9 +2939,10 @@
 	  if (DECL_ARTIFICIAL (t))
 	    return 0;
 
-	  /* Only consider constructors/destructors for complete objects.  */
+	  /* Only consider complete constructors and deleting destructors.  */
 	  if (strncmp (IDENTIFIER_POINTER (decl_name), "__ct_comp", 9) != 0
-	      && strncmp (IDENTIFIER_POINTER (decl_name), "__dt_comp", 9) != 0)
+	      && strncmp (IDENTIFIER_POINTER (decl_name), "__dt_comp", 9) != 0
+	      && strncmp (IDENTIFIER_POINTER (decl_name), "__dt_del", 8) != 0)
 	    return 0;
 	}
 
Index: gcc/c/ChangeLog
===================================================================
--- a/src/gcc/c/ChangeLog	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/c/ChangeLog	(.../branches/gcc-8-branch)
@@ -1,3 +1,35 @@
+2019-07-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline
+	2019-07-18  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR c/53633
+	* c-decl.c (finish_function): Check targetm.warn_func_return
+	before issuing a -Wreturn-type warning.
+
+2019-04-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90108
+	* c-decl.c (merge_decls): If remove is main variant and
+	DECL_ORIGINAL_TYPE is some other type, remove a DECL_ORIGINAL_TYPE
+	variant that has newdecl as TYPE_NAME if any.
+
+	2019-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89933
+	* c-decl.c (merge_decls): When newdecl's type is its main variant,
+	don't try to remove it from the variant list, but instead assert
+	it has no variants.
+
+	2019-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89734
+	* c-decl.c (grokdeclarator): Call c_build_qualified_type on function
+	return type even if quals_used is 0.  Formatting fixes.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: gcc/c/c-decl.c
===================================================================
--- a/src/gcc/c/c-decl.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/c/c-decl.c	(.../branches/gcc-8-branch)
@@ -2352,13 +2352,33 @@
       if (TYPE_NAME (TREE_TYPE (newdecl)) == newdecl)
 	{
 	  tree remove = TREE_TYPE (newdecl);
-	  for (tree t = TYPE_MAIN_VARIANT (remove); ;
-	       t = TYPE_NEXT_VARIANT (t))
-	    if (TYPE_NEXT_VARIANT (t) == remove)
-	      {
-		TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (remove);
-		break;
-	      }
+	  if (TYPE_MAIN_VARIANT (remove) == remove)
+	    {
+	      gcc_assert (TYPE_NEXT_VARIANT (remove) == NULL_TREE);
+	      /* If remove is the main variant, no need to remove that
+		 from the list.  One of the DECL_ORIGINAL_TYPE
+		 variants, e.g. created for aligned attribute, might still
+		 refer to the newdecl TYPE_DECL though, so remove that one
+		 in that case.  */
+	      if (DECL_ORIGINAL_TYPE (newdecl)
+		  && DECL_ORIGINAL_TYPE (newdecl) != remove)
+		for (tree t = TYPE_MAIN_VARIANT (DECL_ORIGINAL_TYPE (newdecl));
+		     t; t = TYPE_MAIN_VARIANT (t))
+		  if (TYPE_NAME (TYPE_NEXT_VARIANT (t)) == newdecl)
+		    {
+		      TYPE_NEXT_VARIANT (t)
+			= TYPE_NEXT_VARIANT (TYPE_NEXT_VARIANT (t));
+		      break;
+		    }
+	    }	    
+	  else
+	    for (tree t = TYPE_MAIN_VARIANT (remove); ;
+		 t = TYPE_NEXT_VARIANT (t))
+	      if (TYPE_NEXT_VARIANT (t) == remove)
+		{
+		  TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (remove);
+		  break;
+		}
 	}
     }
 
@@ -6436,10 +6456,12 @@
 		  quals_used &= TYPE_QUAL_ATOMIC;
 		if (quals_used && VOID_TYPE_P (type) && really_funcdef)
 		  pedwarn (specs_loc, 0,
-			   "function definition has qualified void return type");
+			   "function definition has qualified void "
+			   "return type");
 		else
 		  warning_at (specs_loc, OPT_Wignored_qualifiers,
-			   "type qualifiers ignored on function return type");
+			      "type qualifiers ignored on function "
+			      "return type");
 
 		/* Ensure an error for restrict on invalid types; the
 		   DR#423 resolution is not entirely clear about
@@ -6449,8 +6471,7 @@
 		    && (!POINTER_TYPE_P (type)
 			|| !C_TYPE_OBJECT_OR_INCOMPLETE_P (TREE_TYPE (type))))
 		  error_at (loc, "invalid use of %<restrict%>");
-		if (quals_used)
-		  type = c_build_qualified_type (type, quals_used);
+		type = c_build_qualified_type (type, quals_used);
 	      }
 	    type_quals = TYPE_UNQUALIFIED;
 
@@ -9485,7 +9506,8 @@
       && !C_FUNCTION_IMPLICIT_INT (fndecl)
       /* Normally, with -Wreturn-type, flow will complain, but we might
          optimize out static functions.  */
-      && !TREE_PUBLIC (fndecl))
+      && !TREE_PUBLIC (fndecl)
+      && targetm.warn_func_return (fndecl))
     {
       warning (OPT_Wreturn_type,
 	       "no return statement in function returning non-void");
Index: gcc/cgraph.c
===================================================================
--- a/src/gcc/cgraph.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/cgraph.c	(.../branches/gcc-8-branch)
@@ -3007,42 +3007,55 @@
   return redirect_callers;
 }
 
-/* Return TRUE if NODE2 a clone of NODE or is equivalent to it.  */
 
+/* Return TRUE if NODE2 a clone of NODE or is equivalent to it.  Return
+   optimistically true if this cannot be determined.  */
+
 static bool
 clone_of_p (cgraph_node *node, cgraph_node *node2)
 {
-  bool skipped_thunk = false;
   node = node->ultimate_alias_target ();
   node2 = node2->ultimate_alias_target ();
 
+  if (node2->clone_of == node
+      || node2->former_clone_of == node->decl)
+    return true;
+
+  if (!node->thunk.thunk_p && !node->former_thunk_p ())
+    {
+      while (node2 && node->decl != node2->decl)
+	node2 = node2->clone_of;
+      return node2 != NULL;
+    }
+
   /* There are no virtual clones of thunks so check former_clone_of or if we
      might have skipped thunks because this adjustments are no longer
      necessary.  */
-  while (node->thunk.thunk_p)
+  while (node->thunk.thunk_p || node->former_thunk_p ())
     {
-      if (node2->former_clone_of == node->decl)
-	return true;
       if (!node->thunk.this_adjusting)
 	return false;
+      /* In case of instrumented expanded thunks, which can have multiple calls
+	 in them, we do not know how to continue and just have to be
+	 optimistic.  */
+      if (node->callees->next_callee)
+	return true;
       node = node->callees->callee->ultimate_alias_target ();
-      skipped_thunk = true;
-    }
 
-  if (skipped_thunk)
-    {
       if (!node2->clone.args_to_skip
 	  || !bitmap_bit_p (node2->clone.args_to_skip, 0))
 	return false;
       if (node2->former_clone_of == node->decl)
 	return true;
-      else if (!node2->clone_of)
-	return false;
+
+      cgraph_node *n2 = node2;
+      while (n2 && node->decl != n2->decl)
+	n2 = n2->clone_of;
+      if (n2)
+	return true;
     }
 
-  while (node != node2 && node2)
-    node2 = node2->clone_of;
-  return node2 != NULL;
+  return false;
 }
 
 /* Verify edge count and frequency.  */
Index: gcc/cgraph.h
===================================================================
--- a/src/gcc/cgraph.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/cgraph.h	(.../branches/gcc-8-branch)
@@ -997,12 +997,17 @@
      If non-NULL BLOCK_TO_COPY determine what basic blocks to copy.
      If non_NULL NEW_ENTRY determine new entry BB of the clone.
 
+     If TARGET_ATTRIBUTES is non-null, when creating a new declaration,
+     add the attributes to DECL_ATTRIBUTES.  And call valid_attribute_p
+     that will promote value of the attribute DECL_FUNCTION_SPECIFIC_TARGET
+     of the declaration.
+
      Return the new version's cgraph node.  */
   cgraph_node *create_version_clone_with_body
     (vec<cgraph_edge *> redirect_callers,
      vec<ipa_replace_map *, va_gc> *tree_map, bitmap args_to_skip,
      bool skip_return, bitmap bbs_to_copy, basic_block new_entry_block,
-     const char *clone_name);
+     const char *clone_name, tree target_attributes = NULL_TREE);
 
   /* Insert a new cgraph_function_version_info node into cgraph_fnver_htab
      corresponding to cgraph_node.  */
@@ -1258,6 +1263,9 @@
      Note that at WPA stage, the function body may not be present in memory.  */
   inline bool has_gimple_body_p (void);
 
+  /* Return true if this node represents a former, i.e. an expanded, thunk.  */
+  inline bool former_thunk_p (void);
+
   /* Return true if function should be optimized for size.  */
   bool optimize_for_size_p (void);
 
@@ -2858,6 +2866,16 @@
   return definition && !thunk.thunk_p && !alias;
 }
 
+/* Return true if this node represents a former, i.e. an expanded, thunk.  */
+
+inline bool
+cgraph_node::former_thunk_p (void)
+{
+  return (!thunk.thunk_p
+	  && (thunk.fixed_offset
+	      || thunk.virtual_offset_p));
+}
+
 /* Walk all functions with body defined.  */
 #define FOR_EACH_FUNCTION_WITH_GIMPLE_BODY(node) \
    for ((node) = symtab->first_function_with_gimple_body (); (node); \
Index: gcc/DATESTAMP
===================================================================
--- a/src/gcc/DATESTAMP	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/DATESTAMP	(.../branches/gcc-8-branch)
@@ -1 +1 @@
-20190222
+20190817
Index: gcc/tree-ssa-loop-ch.c
===================================================================
--- a/src/gcc/tree-ssa-loop-ch.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-ssa-loop-ch.c	(.../branches/gcc-8-branch)
@@ -99,7 +99,7 @@
     }
 
   last = last_stmt (header);
-  if (gimple_code (last) != GIMPLE_COND)
+  if (!last || gimple_code (last) != GIMPLE_COND)
     {
       if (dump_file && (dump_flags & TDF_DETAILS))
 	fprintf (dump_file,
@@ -376,11 +376,23 @@
 		{
 		  gimple *stmt = gsi_stmt (bsi);
 		  if (gimple_code (stmt) == GIMPLE_COND)
-		    gimple_set_no_warning (stmt, true);
+		    {
+		      tree lhs = gimple_cond_lhs (stmt);
+		      if (gimple_cond_code (stmt) != EQ_EXPR
+			  && gimple_cond_code (stmt) != NE_EXPR
+			  && INTEGRAL_TYPE_P (TREE_TYPE (lhs))
+			  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (lhs)))
+			gimple_set_no_warning (stmt, true);
+		    }
 		  else if (is_gimple_assign (stmt))
 		    {
 		      enum tree_code rhs_code = gimple_assign_rhs_code (stmt);
-		      if (TREE_CODE_CLASS (rhs_code) == tcc_comparison)
+		      tree rhs1 = gimple_assign_rhs1 (stmt);
+		      if (TREE_CODE_CLASS (rhs_code) == tcc_comparison
+			  && rhs_code != EQ_EXPR
+			  && rhs_code != NE_EXPR
+			  && INTEGRAL_TYPE_P (TREE_TYPE (rhs1))
+			  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (rhs1)))
 			gimple_set_no_warning (stmt, true);
 		    }
 		}
Index: gcc/tree-tailcall.c
===================================================================
--- a/src/gcc/tree-tailcall.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-tailcall.c	(.../branches/gcc-8-branch)
@@ -37,6 +37,7 @@
 #include "tree-into-ssa.h"
 #include "tree-dfa.h"
 #include "except.h"
+#include "tree-eh.h"
 #include "dbgcnt.h"
 #include "cfgloop.h"
 #include "common/common-target.h"
@@ -472,6 +473,12 @@
       && !auto_var_in_fn_p (ass_var, cfun->decl))
     return;
 
+  /* If the call might throw an exception that wouldn't propagate out of
+     cfun, we can't transform to a tail or sibling call (82081).  */
+  if (stmt_could_throw_p (stmt)
+      && !stmt_can_throw_external (stmt))
+    return;
+
   /* We found the call, check whether it is suitable.  */
   tail_recursion = false;
   func = gimple_call_fndecl (call);
Index: gcc/tree-ssa-strlen.c
===================================================================
--- a/src/gcc/tree-ssa-strlen.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-ssa-strlen.c	(.../branches/gcc-8-branch)
@@ -996,10 +996,18 @@
     return false;
 
   tree callee = gimple_call_fndecl (stmt);
+  tree decl = builtin_decl_explicit (DECL_FUNCTION_CODE (callee));
+  if (decl
+      && decl != callee
+      && !gimple_builtin_call_types_compatible_p (stmt, decl))
+    return false;
+
   switch (DECL_FUNCTION_CODE (callee))
     {
     case BUILT_IN_MEMCMP:
     case BUILT_IN_MEMCMP_EQ:
+    case BUILT_IN_STRCMP:
+    case BUILT_IN_STRNCMP:
     case BUILT_IN_STRCHR:
     case BUILT_IN_STRCHR_CHKP:
     case BUILT_IN_STRLEN:
@@ -1024,6 +1032,8 @@
     case BUILT_IN_STPCPY_CHK:
     case BUILT_IN_STPCPY_CHKP:
     case BUILT_IN_STPCPY_CHK_CHKP:
+    case BUILT_IN_STPNCPY:
+    case BUILT_IN_STPNCPY_CHK:
     case BUILT_IN_STRCAT:
     case BUILT_IN_STRCAT_CHK:
     case BUILT_IN_STRCAT_CHKP:
@@ -1032,6 +1042,10 @@
     case BUILT_IN_STRCPY_CHK:
     case BUILT_IN_STRCPY_CHKP:
     case BUILT_IN_STRCPY_CHK_CHKP:
+    case BUILT_IN_STRNCAT:
+    case BUILT_IN_STRNCAT_CHK:
+    case BUILT_IN_STRNCPY:
+    case BUILT_IN_STRNCPY_CHK:
       /* The above functions should be neither const nor pure.  Punt if they
 	 aren't.  */
       if (gimple_vdef (stmt) == NULL_TREE || gimple_vuse (stmt) == NULL_TREE)
Index: gcc/tree.h
===================================================================
--- a/src/gcc/tree.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree.h	(.../branches/gcc-8-branch)
@@ -909,6 +909,11 @@
   (TREE_CHECK2 (NODE, VAR_DECL, \
 		RESULT_DECL)->decl_common.decl_nonshareable_flag)
 
+/* In a PARM_DECL, set for Fortran hidden string length arguments that some
+   buggy callers don't pass to the callee.  */
+#define DECL_HIDDEN_STRING_LENGTH(NODE) \
+  (TREE_CHECK (NODE, PARM_DECL)->decl_common.decl_nonshareable_flag)
+
 /* In a CALL_EXPR, means that the call is the jump from a thunk to the
    thunked-to function.  */
 #define CALL_FROM_THUNK_P(NODE) (CALL_EXPR_CHECK (NODE)->base.protected_flag)
Index: gcc/ipa-cp.c
===================================================================
--- a/src/gcc/ipa-cp.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/ipa-cp.c	(.../branches/gcc-8-branch)
@@ -1082,7 +1082,6 @@
   if (TREE_CODE_CLASS (code) == tcc_binary)
     {
       tree type = TREE_TYPE (operand);
-      gcc_assert (INTEGRAL_TYPE_P (type));
       widest_int o_value, o_mask;
       get_value_and_mask (operand, &o_value, &o_mask);
 
@@ -2852,12 +2851,19 @@
   base_time -= time;
   if (base_time > 65535)
     base_time = 65535;
-  time_benefit = base_time.to_int ()
-    + devirtualization_time_bonus (node, known_csts, known_contexts,
-				   known_aggs_ptrs)
-    + hint_time_bonus (hints)
-    + removable_params_cost + est_move_cost;
 
+  /* Extern inline functions have no cloning local time benefits because they
+     will be inlined anyway.  The only reason to clone them is if it enables
+     optimization in any of the functions they call.  */
+  if (DECL_EXTERNAL (node->decl) && DECL_DECLARED_INLINE_P (node->decl))
+    time_benefit = 0;
+  else
+    time_benefit = base_time.to_int ()
+      + devirtualization_time_bonus (node, known_csts, known_contexts,
+				     known_aggs_ptrs)
+      + hint_time_bonus (hints)
+      + removable_params_cost + est_move_cost;
+
   gcc_checking_assert (size >=0);
   /* The inliner-heuristics based estimates may think that in certain
      contexts some functions do not have any size at all but we want
Index: gcc/tree-scalar-evolution.c
===================================================================
--- a/src/gcc/tree-scalar-evolution.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-scalar-evolution.c	(.../branches/gcc-8-branch)
@@ -875,7 +875,7 @@
       gimple *stmt;
 
       stmt = last_stmt (exit_edge->src);
-      if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))
+      if (gcond *cond_stmt = safe_dyn_cast <gcond *> (stmt))
 	res = cond_stmt;
     }
 
@@ -1421,6 +1421,11 @@
       return build_polynomial_chrec (loop->num, init_cond, right);
     }
 
+  /* The affine code only deals with pointer and integer types.  */
+  if (!POINTER_TYPE_P (type)
+      && !INTEGRAL_TYPE_P (type))
+    return chrec_dont_know;
+
   /* Try harder to check if they are equal.  */
   tree_to_aff_combination_expand (left, type, &aff1, &peeled_chrec_map);
   tree_to_aff_combination_expand (step_val, type, &aff2, &peeled_chrec_map);
Index: gcc/rtlanal.c
===================================================================
--- a/src/gcc/rtlanal.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/rtlanal.c	(.../branches/gcc-8-branch)
@@ -358,10 +358,10 @@
   if (to == from)
     return 0;
 
-  /* It is not safe to call INITIAL_ELIMINATION_OFFSET
-     before the reload pass.  We need to give at least
-     an estimation for the resulting frame size.  */
-  if (! reload_completed)
+  /* It is not safe to call INITIAL_ELIMINATION_OFFSET before the epilogue
+     is completed, but we need to give at least an estimate for the stack
+     pointer based on the frame size.  */
+  if (!epilogue_completed)
     {
       offset1 = crtl->outgoing_args_size + get_frame_size ();
 #if !STACK_GROWS_DOWNWARD
Index: gcc/configure
===================================================================
--- a/src/gcc/configure	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/configure	(.../branches/gcc-8-branch)
@@ -22799,17 +22799,13 @@
 	#
 	# ld: Software Generation Utilities - Solaris Link Editors: 5.11-1.1701:onnv-ab196087-6931056-03/25/10
 	#
-	# In Solaris 11.4, this was changed to
-	#
-	# ld: Solaris ELF Utilities: 11.4-1.3123
-	#
 	# ld and ld.so.1 are guaranteed to be updated in lockstep, so ld version
 	# numbers can be used in ld.so.1 feature checks even if a different
 	# linker is configured.
 	ld_ver=`$gcc_cv_ld -V 2>&1`
-	if echo "$ld_ver" | $EGREP 'Solaris Link Editors|Solaris ELF Utilities' > /dev/null; then
+	if echo "$ld_ver" | grep 'Solaris Link Editors' > /dev/null; then
 	  ld_vers=`echo $ld_ver | sed -n \
-	    -e 's,^.*: \(5\|1[0-9]\)\.[0-9][0-9]*-\([0-9]\.[0-9][0-9]*\).*$,\2,p'`
+	    -e 's,^.*: 5\.[0-9][0-9]*-\([0-9]\.[0-9][0-9]*\).*$,\1,p'`
 	  ld_vers_major=`expr "$ld_vers" : '\([0-9]*\)'`
 	  ld_vers_minor=`expr "$ld_vers" : '[0-9]*\.\([0-9]*\)'`
 	fi
Index: gcc/builtins.c
===================================================================
--- a/src/gcc/builtins.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/builtins.c	(.../branches/gcc-8-branch)
@@ -2560,7 +2560,7 @@
   tree arg;
 
   if (!validate_arglist (exp, REAL_TYPE, VOID_TYPE))
-    gcc_unreachable ();
+    return NULL_RTX;
 
   arg = CALL_EXPR_ARG (exp, 0);
 
@@ -2696,7 +2696,7 @@
   enum built_in_function fallback_fn = BUILT_IN_NONE;
 
   if (!validate_arglist (exp, REAL_TYPE, VOID_TYPE))
-     gcc_unreachable ();
+    return NULL_RTX;
 
   arg = CALL_EXPR_ARG (exp, 0);
 
@@ -10088,6 +10088,9 @@
 static void
 maybe_emit_free_warning (tree exp)
 {
+  if (call_expr_nargs (exp) != 1)
+    return;
+
   tree arg = CALL_EXPR_ARG (exp, 0);
 
   STRIP_NOPS (arg);
Index: gcc/input.c
===================================================================
--- a/src/gcc/input.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/input.c	(.../branches/gcc-8-branch)
@@ -3538,6 +3538,34 @@
   ASSERT_EQ (num_cases_tested, 2 * 12);
 }
 
+/* Verify that when presented with a consecutive pair of locations with
+   a very large line offset, we don't attempt to consolidate them into
+   a single ordinary linemap where the line offsets within the line map
+   would lead to overflow (PR lto/88147).  */
+
+static void
+test_line_offset_overflow ()
+{
+  line_table_test ltt (line_table_case (5, 0));
+
+  linemap_add (line_table, LC_ENTER, false, "foo.c", 0);
+  linemap_line_start (line_table, 1, 100);
+  location_t loc_a = linemap_line_start (line_table, 2578, 255);
+  assert_loceq ("foo.c", 2578, 0, loc_a);
+
+  const line_map_ordinary *ordmap_a = LINEMAPS_LAST_ORDINARY_MAP (line_table);
+  ASSERT_EQ (ordmap_a->m_column_and_range_bits, 13);
+  ASSERT_EQ (ordmap_a->m_range_bits, 5);
+
+  location_t loc_b = linemap_line_start (line_table, 404198, 512);
+  assert_loceq ("foo.c", 404198, 0, loc_b);
+
+  /* We should have started a new linemap, rather than attempting to store
+     a very large line offset.  */
+  const line_map_ordinary *ordmap_b = LINEMAPS_LAST_ORDINARY_MAP (line_table);
+  ASSERT_NE (ordmap_a, ordmap_b);
+}
+
 /* Run all of the selftests within this file.  */
 
 void
@@ -3577,6 +3605,8 @@
   for_each_line_table_case (test_lexer_char_constants);
 
   test_reading_source_line ();
+
+  test_line_offset_overflow ();
 }
 
 } // namespace selftest
Index: gcc/fold-const.c
===================================================================
--- a/src/gcc/fold-const.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fold-const.c	(.../branches/gcc-8-branch)
@@ -3179,10 +3179,16 @@
       switch (TREE_CODE (arg0))
 	{
 	case INDIRECT_REF:
-	  if (!(flags & OEP_ADDRESS_OF)
-	      && (TYPE_ALIGN (TREE_TYPE (arg0))
-		  != TYPE_ALIGN (TREE_TYPE (arg1))))
-	    return 0;
+	  if (!(flags & OEP_ADDRESS_OF))
+	    {
+	      if (TYPE_ALIGN (TREE_TYPE (arg0))
+		  != TYPE_ALIGN (TREE_TYPE (arg1)))
+		return 0;
+	      /* Verify that the access types are compatible.  */
+	      if (TYPE_MAIN_VARIANT (TREE_TYPE (arg0))
+		  != TYPE_MAIN_VARIANT (TREE_TYPE (arg1)))
+		return 0;
+	    }
 	  flags &= ~OEP_ADDRESS_OF;
 	  return OP_SAME (0);
 
@@ -4239,7 +4245,7 @@
      There are problems with FP fields since the type_for_size call
      below can fail for, e.g., XFmode.  */
   if (! INTEGRAL_TYPE_P (TREE_TYPE (exp)))
-    return 0;
+    return NULL_TREE;
 
   /* We are interested in the bare arrangement of bits, so strip everything
      that doesn't affect the machine mode.  However, record the type of the
@@ -4255,7 +4261,7 @@
       exp = TREE_OPERAND (exp, 0);
       STRIP_NOPS (exp); STRIP_NOPS (and_mask);
       if (TREE_CODE (and_mask) != INTEGER_CST)
-	return 0;
+	return NULL_TREE;
     }
 
   poly_int64 poly_bitsize, poly_bitpos;
@@ -4271,8 +4277,12 @@
       || (! AGGREGATE_TYPE_P (TREE_TYPE (inner))
 	  && compare_tree_int (TYPE_SIZE (TREE_TYPE (inner)),
 			       *pbitpos + *pbitsize) < 0))
-    return 0;
+    return NULL_TREE;
 
+  unsigned_type = lang_hooks.types.type_for_size (*pbitsize, 1);
+  if (unsigned_type == NULL_TREE)
+    return NULL_TREE;
+
   *exp_ = exp;
 
   /* If the number of bits in the reference is the same as the bitsize of
@@ -4282,7 +4292,6 @@
     *punsignedp = TYPE_UNSIGNED (outer_type);
 
   /* Compute the mask to access the bitfield.  */
-  unsigned_type = lang_hooks.types.type_for_size (*pbitsize, 1);
   precision = TYPE_PRECISION (unsigned_type);
 
   mask = build_int_cst_type (unsigned_type, -1);
@@ -5515,12 +5524,15 @@
   /* On machines where the branch cost is expensive, if this is a
      short-circuited branch and the underlying object on both sides
      is the same, make a non-short-circuit operation.  */
-  else if (LOGICAL_OP_NON_SHORT_CIRCUIT
-	   && !flag_sanitize_coverage
-	   && lhs != 0 && rhs != 0
-	   && (code == TRUTH_ANDIF_EXPR
-	       || code == TRUTH_ORIF_EXPR)
-	   && operand_equal_p (lhs, rhs, 0))
+  bool logical_op_non_short_circuit = LOGICAL_OP_NON_SHORT_CIRCUIT;
+  if (PARAM_VALUE (PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT) != -1)
+    logical_op_non_short_circuit
+      = PARAM_VALUE (PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT);
+  if (logical_op_non_short_circuit
+      && !flag_sanitize_coverage
+      && lhs != 0 && rhs != 0
+      && (code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR)
+      && operand_equal_p (lhs, rhs, 0))
     {
       /* If simple enough, just rewrite.  Otherwise, make a SAVE_EXPR
 	 unless we are at top level or LHS contains a PLACEHOLDER_EXPR, in
@@ -8165,7 +8177,11 @@
   if ((tem = fold_truth_andor_1 (loc, code, type, arg0, arg1)) != 0)
     return tem;
 
-  if (LOGICAL_OP_NON_SHORT_CIRCUIT
+  bool logical_op_non_short_circuit = LOGICAL_OP_NON_SHORT_CIRCUIT;
+  if (PARAM_VALUE (PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT) != -1)
+    logical_op_non_short_circuit
+      = PARAM_VALUE (PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT);
+  if (logical_op_non_short_circuit
       && !flag_sanitize_coverage
       && (code == TRUTH_AND_EXPR
           || code == TRUTH_ANDIF_EXPR
@@ -13994,13 +14010,13 @@
 	    {
 	      tree elem0 = VECTOR_CST_ELT (op0, i);
 	      tree elem1 = VECTOR_CST_ELT (op1, i);
-	      tree tmp = fold_relational_const (code, type, elem0, elem1);
+	      tree tmp = fold_relational_const (EQ_EXPR, type, elem0, elem1);
 	      if (tmp == NULL_TREE)
 		return NULL_TREE;
 	      if (integer_zerop (tmp))
-		return constant_boolean_node (false, type);
+		return constant_boolean_node (code == NE_EXPR, type);
 	    }
-	  return constant_boolean_node (true, type);
+	  return constant_boolean_node (code == EQ_EXPR, type);
 	}
       tree_vector_builder elts;
       if (!elts.new_binary_operation (type, op0, op1, false))
@@ -14671,6 +14687,7 @@
   tree type = build_vector_type (inner_type, 4);
   tree zero = build_zero_cst (type);
   tree one = build_one_cst (type);
+  tree index = build_index_vector (type, 0, 1);
 
   /* Verify equality tests that return a scalar boolean result.  */
   tree res_type = boolean_type_node;
@@ -14678,6 +14695,13 @@
   ASSERT_TRUE (integer_nonzerop (fold_build2 (EQ_EXPR, res_type, zero, zero)));
   ASSERT_TRUE (integer_nonzerop (fold_build2 (NE_EXPR, res_type, zero, one)));
   ASSERT_FALSE (integer_nonzerop (fold_build2 (NE_EXPR, res_type, one, one)));
+  ASSERT_TRUE (integer_nonzerop (fold_build2 (NE_EXPR, res_type, index, one)));
+  ASSERT_FALSE (integer_nonzerop (fold_build2 (EQ_EXPR, res_type,
+					       index, one)));
+  ASSERT_FALSE (integer_nonzerop (fold_build2 (NE_EXPR, res_type,
+					      index, index)));
+  ASSERT_TRUE (integer_nonzerop (fold_build2 (EQ_EXPR, res_type,
+					      index, index)));
 }
 
 /* Verify folding of VEC_DUPLICATE_EXPRs.  */
Index: gcc/gimple-ssa-sprintf.c
===================================================================
--- a/src/gcc/gimple-ssa-sprintf.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/gimple-ssa-sprintf.c	(.../branches/gcc-8-branch)
@@ -376,9 +376,14 @@
      overlong strings just like the translated strings are.  */
   if (target_to_host_charmap['\0'] == 1)
     {
-      strncpy (hostr, targstr, hostsz - 4);
-      if (strlen (targstr) >= hostsz)
-	strcpy (hostr + hostsz - 4, "...");
+      size_t len = strlen (targstr);
+      if (len >= hostsz)
+	{
+	  memcpy (hostr, targstr, hostsz - 4);
+	  strcpy (hostr + hostsz - 4, "...");
+	}
+      else
+	memcpy (hostr, targstr, len + 1);
       return hostr;
     }
 
@@ -392,10 +397,9 @@
       if (!*targstr)
 	break;
 
-      if (size_t (ph - hostr) == hostsz - 4)
+      if (size_t (ph - hostr) == hostsz)
 	{
-	  *ph = '\0';
-	  strcat (ph, "...");
+	  strcpy (ph - 4, "...");
 	  break;
 	}
     }
@@ -3662,10 +3666,10 @@
 	 are badly declared.  */
       && !stmt_ends_bb_p (info.callstmt))
     {
-      tree cst = build_int_cst (integer_type_node, retval[0]);
+      tree cst = build_int_cst (lhs ? TREE_TYPE (lhs) : integer_type_node,
+				retval[0]);
 
-      if (lhs == NULL_TREE
-	  && info.nowrite)
+      if (lhs == NULL_TREE && info.nowrite)
 	{
 	  /* Remove the call to the bounded function with a zero size
 	     (e.g., snprintf(0, 0, "%i", 123)) if there is no lhs.  */
@@ -3706,7 +3710,7 @@
 	    }
 	}
     }
-  else if (lhs)
+  else if (lhs && types_compatible_p (TREE_TYPE (lhs), integer_type_node))
     {
       bool setrange = false;
 
Index: gcc/omp-low.c
===================================================================
--- a/src/gcc/omp-low.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/omp-low.c	(.../branches/gcc-8-branch)
@@ -851,6 +851,7 @@
       ctx->cb.copy_decl = omp_copy_decl;
       ctx->cb.eh_lp_nr = 0;
       ctx->cb.transform_call_graph_edges = CB_CGE_MOVE;
+      ctx->cb.dont_remap_vla_if_no_change = true;
       ctx->depth = 1;
     }
 
Index: gcc/gcov.c
===================================================================
--- a/src/gcc/gcov.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/gcov.c	(.../branches/gcc-8-branch)
@@ -604,27 +604,11 @@
 typedef vector<arc_info *> arc_vector_t;
 typedef vector<const block_info *> block_vector_t;
 
-/* Enum with types of loop in CFG.  */
-
-enum loop_type
-{
-  NO_LOOP = 0,
-  LOOP = 1,
-  NEGATIVE_LOOP = 3
-};
-
-/* Loop_type operator that merges two values: A and B.  */
-
-inline loop_type& operator |= (loop_type& a, loop_type b)
-{
-    return a = static_cast<loop_type> (a | b);
-}
-
 /* Handle cycle identified by EDGES, where the function finds minimum cs_count
    and subtract the value from all counts.  The subtracted value is added
    to COUNT.  Returns type of loop.  */
 
-static loop_type
+static void
 handle_cycle (const arc_vector_t &edges, int64_t &count)
 {
   /* Find the minimum edge of the cycle, and reduce all nodes in the cycle by
@@ -640,7 +624,7 @@
   for (unsigned i = 0; i < edges.size (); i++)
     edges[i]->cs_count -= cycle_count;
 
-  return cycle_count < 0 ? NEGATIVE_LOOP : LOOP;
+  gcc_assert (cycle_count > 0);
 }
 
 /* Unblock a block U from BLOCKED.  Apart from that, iterate all blocks
@@ -666,17 +650,28 @@
     unblock (*it, blocked, block_lists);
 }
 
+/* Return true when PATH contains a zero cycle arc count.  */
+
+static bool
+path_contains_zero_cycle_arc (arc_vector_t &path)
+{
+  for (unsigned i = 0; i < path.size (); i++)
+    if (path[i]->cs_count == 0)
+      return true;
+  return false;
+}
+
 /* Find circuit going to block V, PATH is provisional seen cycle.
    BLOCKED is vector of blocked vertices, BLOCK_LISTS contains vertices
    blocked by a block.  COUNT is accumulated count of the current LINE.
    Returns what type of loop it contains.  */
 
-static loop_type
+static bool
 circuit (block_info *v, arc_vector_t &path, block_info *start,
 	 block_vector_t &blocked, vector<block_vector_t> &block_lists,
 	 line_info &linfo, int64_t &count)
 {
-  loop_type result = NO_LOOP;
+  bool loop_found = false;
 
   /* Add v to the block list.  */
   gcc_assert (find (blocked.begin (), blocked.end (), v) == blocked.end ());
@@ -686,26 +681,35 @@
   for (arc_info *arc = v->succ; arc; arc = arc->succ_next)
     {
       block_info *w = arc->dst;
-      if (w < start || !linfo.has_block (w))
+      if (w < start
+	  || arc->cs_count == 0
+	  || !linfo.has_block (w))
 	continue;
 
       path.push_back (arc);
       if (w == start)
-	/* Cycle has been found.  */
-	result |= handle_cycle (path, count);
-      else if (find (blocked.begin (), blocked.end (), w) == blocked.end ())
-	result |= circuit (w, path, start, blocked, block_lists, linfo, count);
+	{
+	  /* Cycle has been found.  */
+	  handle_cycle (path, count);
+	  loop_found = true;
+	}
+      else if (!path_contains_zero_cycle_arc (path)
+	       &&  find (blocked.begin (), blocked.end (), w) == blocked.end ())
+	loop_found |= circuit (w, path, start, blocked, block_lists, linfo,
+			       count);
 
       path.pop_back ();
     }
 
-  if (result != NO_LOOP)
+  if (loop_found)
     unblock (v, blocked, block_lists);
   else
     for (arc_info *arc = v->succ; arc; arc = arc->succ_next)
       {
 	block_info *w = arc->dst;
-	if (w < start || !linfo.has_block (w))
+	if (w < start
+	    || arc->cs_count == 0
+	    || !linfo.has_block (w))
 	  continue;
 
 	size_t index
@@ -716,14 +720,13 @@
 	  list.push_back (v);
       }
 
-  return result;
+  return loop_found;
 }
 
-/* Find cycles for a LINFO.  If HANDLE_NEGATIVE_CYCLES is set and the line
-   contains a negative loop, then perform the same function once again.  */
+/* Find cycles for a LINFO.  */
 
 static gcov_type
-get_cycles_count (line_info &linfo, bool handle_negative_cycles = true)
+get_cycles_count (line_info &linfo)
 {
   /* Note that this algorithm works even if blocks aren't in sorted order.
      Each iteration of the circuit detection is completely independent
@@ -731,7 +734,7 @@
      Therefore, operating on a permuted order (i.e., non-sorted) only
      has the effect of permuting the output cycles.  */
 
-  loop_type result = NO_LOOP;
+  bool loop_found = false;
   gcov_type count = 0;
   for (vector<block_info *>::iterator it = linfo.blocks.begin ();
        it != linfo.blocks.end (); it++)
@@ -739,14 +742,10 @@
       arc_vector_t path;
       block_vector_t blocked;
       vector<block_vector_t > block_lists;
-      result |= circuit (*it, path, *it, blocked, block_lists, linfo,
-			 count);
+      loop_found |= circuit (*it, path, *it, blocked, block_lists, linfo,
+			     count);
     }
 
-  /* If we have a negative cycle, repeat the find_cycles routine.  */
-  if (result == NEGATIVE_LOOP && handle_negative_cycles)
-    count += get_cycles_count (linfo, false);
-
   return count;
 }
 
Index: gcc/toplev.c
===================================================================
--- a/src/gcc/toplev.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/toplev.c	(.../branches/gcc-8-branch)
@@ -2110,6 +2110,34 @@
 	else
 	  int_n_enabled_p[i] = false;
 
+      /* Initialize mpfrs exponent range.  This is important to get
+         underflow/overflow in a reasonable timeframe.  */
+      machine_mode mode;
+      int min_exp = -1;
+      int max_exp = 1;
+      FOR_EACH_MODE_IN_CLASS (mode, MODE_FLOAT)
+	if (SCALAR_FLOAT_MODE_P (mode))
+	  {
+	    const real_format *fmt = REAL_MODE_FORMAT (mode);
+	    if (fmt)
+	      {
+		/* fmt->emin - fmt->p + 1 should be enough but the
+		   back-and-forth dance in real_to_decimal_for_mode we
+		   do for checking fails due to rounding effects then.  */
+		if ((fmt->emin - fmt->p) < min_exp)
+		  min_exp = fmt->emin - fmt->p;
+		if (fmt->emax > max_exp)
+		  max_exp = fmt->emax;
+	      }
+	  }
+      /* E.g. mpc_norm assumes it can square a number without bothering with
+	 with range scaling, so until that is fixed, double the minimum
+	 and maximum exponents, plus add some buffer for arithmetics
+	 on the squared numbers.  */
+      if (mpfr_set_emin (2 * (min_exp - 1))
+	  || mpfr_set_emax (2 * (max_exp + 1)))
+	sorry ("mpfr not configured to handle all float modes");
+
       /* Set up the back-end if requested.  */
       if (!no_backend)
 	backend_init ();
Index: gcc/ChangeLog
===================================================================
--- a/src/gcc/ChangeLog	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/ChangeLog	(.../branches/gcc-8-branch)
@@ -1,3 +1,1234 @@
+2019-08-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-04-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/rs6000.md (group_end_nop): Emit insn register
+	names using operand format, rather than hard-wired.
+	(speculation_barrier): Likewise.
+
+2019-08-14  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-08-22 Iain Sandoe <iain@sandoe.co.uk>
+
+	* config/darwin.h (LINK_COMMAND_SPEC_A): Update lto options
+	to match gcc/gcc.c.
+
+2019-08-05  Kito Cheng  <kito.cheng@sifive.com>
+
+	Backport from mainline
+	2019-08-05  Kito Cheng  <kito.cheng@sifive.com>
+
+	* config/riscv/riscv.c (riscv_promote_function_mode): New.
+	(TARGET_PROMOTE_FUNCTION_MODE): Use riscv_promote_function_mode.
+
+2019-08-04  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-05-02  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* config/rs6000/rs6000.c (rs6000_dbx_register_number): Return the
+	correct numbers for TFHAR, TFIAR, TEXASR.
+
+2019-07-23  Matthew Beliveau  <mbelivea@redhat.com>
+	
+	Backported from mainline
+	2019-07-16  Jeff Law  <law@redhat.com>
+	
+	PR rtl-optimization/91173
+	* tree-ssa-address.c (addr_for_mem_ref): If the base is an
+	SSA_NAME with a constant value, fold its value into the offset
+	and clear the base before calling gen_addr_rtx.
+	* g++.dg/pr91173.C: New test.
+
+2019-07-23  Richard Biener  <rguenther@suse.de>
+
+	PR debug/91231
+	* lto-streamer-in.c (input_function): Drop inline-entry markers
+	that ended up with an unknown location block.
+
+2019-07-22  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-07-22  Martin Liska  <mliska@suse.cz>
+
+	PR driver/91172
+	* opts-common.c (decode_cmdline_option): Decode
+	argument of -Werror and check it for a wrong language.
+	* opts-global.c (complain_wrong_lang): Remove such case.
+
+2019-07-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline
+	2019-07-10  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* fold-const.c (fold_relational_const): Fix folding of
+	vector-to-scalar NE_EXPRs.
+	(test_vector_folding): Add more tests.
+
+2019-07-19  Jason Merrill  <jason@redhat.com>
+
+	PR c++/82081 - tail call optimization breaks noexcept
+	* tree-tailcall.c (find_tail_calls): Don't turn a call from a
+	nothrow function to a might-throw function into a tail call.
+
+2019-07-16  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backport from mainline
+	PR target/89222
+	* config/arm/arm.md (movsi): Use targetm.cannot_force_const_mem
+	to decide when to split off a non-zero offset from a symbol.
+	* config/arm/arm.c (arm_cannot_force_const_mem): Disallow offsets
+	in function symbols.
+
+2019-07-16  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backport from mainline
+	2019-02-13  Wilco Dijkstra  <wdijkstr@arm.com>
+	PR target/89190
+	* config/arm/arm.c (ldm_stm_operation_p) Set
+	addr_reg_in_reglist correctly for first register.
+	(load_multiple_sequence): Remove dead base check.
+	(gen_ldm_seq): Correctly set write_back for Thumb-1.
+
+2019-07-15  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-07-01  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/vector.md: Fix shift count operand printing.
+
+2019-07-15  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backport from mainline
+	2019-01-23  Bin Cheng  <bin.cheng@arm.com>
+		    Steve Ellcey  <sellcey@marvell.com>
+
+	PR target/85711
+	* recog.c (address_operand): Return false on wrong mode for address.
+	(constrain_operands): Check for mode with 'p' constraint.
+
+2019-07-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/91136
+	* df-core.c (ACCESSING REFS): Fix typos in comment.
+	* resource.c (mark_target_live_reg): Add artificial defs that occur at
+	the beginning of the block to the initial set of live registers.
+
+2019-07-04  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-07-03  Martin Liska  <mliska@suse.cz>
+
+	PR middle-end/90899
+	* multiple_target.c (create_dispatcher_calls): Add to comdat
+	group only if set for ifunc.
+
+2019-06-28  Jeff Law  <law@redhat.com>
+
+	Backport from mainline
+	2019-06-21  Jeff Law  <law@redhat.com>
+
+	PR tree-optimization/90949
+	* tree-ssa-copy.c (fini_copy_prop): Use reset_flow_sensitive_info.
+	* tree-ssanames.c (reset_flow_sensitive_info): Reset non-null state.
+
+2019-06-26  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-06-25  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/90939
+	* ipa-cp.c (ipcp_bits_lattice::meet_with): Remove assert.
+
+2019-06-26  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline
+	2019-06-17  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* configure.ac (ld_vers) <*-*-solaris2*>: Remove support for
+	alternative Solaris 11.4 format.
+	* configure: Regenerate.
+
+2019-06-16  Jeff Law  <law@redhat.com>
+
+	Backport from mainline
+	2019-06-16  Prachi Godbole  <prachi.godbole@imgtec.com>
+		    Robert Suchanek  <robert.suchanek@mips.com>
+	* config/mips/mips.c (mips_expand_builtin_insn): Swap the 1st
+	and 3rd operands of the fmadd/fmsub/maddv builtin.
+
+2019-06-16  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR middle-end/64242
+	* config/pa/pa.md (nonlocal_goto): Restore frame pointer last.  Add
+	frame clobbers and schedule block.
+	(builtin_longjmp): Likewise.
+
+2019-06-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/90811
+	* config/nvptx/nvptx.c (nvptx_output_softstack_switch): Use and.b%d
+	instead of and.u%d.
+
+2019-06-07  John David Anglin  <danglin@gcc.gnu.orig>
+
+	PR target/90751
+	* config/pa/pa-linux.h (ASM_DECLARE_FUNCTION_NAME): Update comment.
+	Call pa_output_function_label.
+	(TARGET_ASM_FUNCTION_PROLOGUE): define.
+	* config/pa/pa-protos.h (pa_output_function_label): Declare.
+	* config/pa/pa.c (pa_output_function_prologue): Add ATTRIBUTE_UNUSED
+	to declaration.
+	(pa_linux_output_function_prologue): Declare.
+	(TARGET_ASM_FUNCTION_PROLOGUE): Delete define.
+	(pa_output_function_label): New.
+	(pa_output_function_prologue): Revise to use pa_output_function_label.
+	(pa_linux_output_function_prologue): New.
+	* config/pa/pa.h (TARGET_ASM_FUNCTION_PROLOGUE): Define.
+
+2019-06-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-12  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/82920
+	* config/i386/darwin.h (CC1_SPEC): Report -mx32 as an error for
+	Darwin.
+
+2019-06-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-12  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/82920
+	* config/i386/i386.c (ix86_output_jmp_thunk_or_indirect): New.
+	(ix86_output_indirect_branch_via_reg): Use output mechanism
+	accounting for __USER_LABEL_PREFIX__.
+	(ix86_output_indirect_branch_via_push): Likewise.
+	(ix86_output_function_return): Likewise.
+	(ix86_output_indirect_function_return): Likewise.
+
+2019-05-30  Jakub Jelinek  <jakub@redhat.com>
+
+	* tree-predcom.c (is_inv_store_elimination_chain): Fix a typo - lenght
+	to length.
+
+2019-05-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/90329
+	* lto-streamer.h (LTO_minor_version): Bump to 2.
+
+	Backported from mainline
+	2019-05-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/90329
+	* tree-core.h (struct tree_decl_common): Document
+	decl_nonshareable_flag for PARM_DECLs.
+	* tree.h (DECL_HIDDEN_STRING_LENGTH): Define.
+	* calls.c (expand_call): Don't try tail call if caller
+	has any DECL_HIDDEN_STRING_LENGTH PARM_DECLs that are or might be
+	passed on the stack and callee needs to pass any arguments on the
+	stack.
+	* tree-streamer-in.c (unpack_ts_decl_common_value_fields): Use
+	else if instead of series of mutually exclusive ifs.  Handle
+	DECL_HIDDEN_STRING_LENGTH for PARM_DECLs.
+	* tree-streamer-out.c (pack_ts_decl_common_value_fields): Likewise.
+
+2019-05-28  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (hppa_profile_hook): Remove offset adjustment.
+
+2019-05-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* dwarf2out.c (resolve_args_picking_1): Deal with DW_OP_GNU_addr_index
+	and DW_OP_GNU_const_index opcodes.
+
+2019-05-24  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/90530
+	* config/pa/pa.c (pa_can_change_mode_class): Accept mode changes from
+	DImode to SImode in floating-point registers on 64-bit target.
+	* config/pa/pa.md (umulsidi3): Change nonimmediate_operand to
+	register_operand in xmpyu patterns.
+
+2019-05-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-05-23  Martin Liska  <mliska@suse.cz>
+
+	PR sanitizer/90570
+	* gimplify.c (gimplify_target_expr): Skip TREE_STATIC target
+	expression similarly to gimplify_decl_expr.
+
+2019-05-23  Uro Bizjak  <ubizjak@gmail.com>
+
+	Backported from mainline
+	2019-05-21  Uro Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/cpuid.h (__cpuid): For 32bit targets, zero
+	%ebx and %ecx bafore calling cpuid with leaf 1 or
+	non-constant leaf argument.
+
+	2019-05-21  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/90547
+	* config/i386/i386.md (anddi_1 to andsi_1_zext splitter):
+	Avoid calling gen_lowpart with CONST operand.
+
+2019-05-21  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backported from mainline
+	2019-05-16  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/arm/t-rtems: Replace ARMv7-M multilibs with Cortex-M
+	multilibs.
+
+2019-05-20  Jeff Law  <law@redhat.com>
+
+	Backport from mainline
+	2019-05-17  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	* config/mips/mips.c (mips_dwarf_frame_reg_mode): Replace
+	TARGET_FLOAT64 with !TARGET_FLOAT32, thus handling both fp64
+	and fpxx modes.
+
+2019-05-16  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-05-07  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89765
+	* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):
+	In handling of ALTIVEC_BUILTIN_VEC_INSERT, use modular arithmetic
+	to compute vector element selector for both constant and variable
+	operands.
+
+2019-05-15  David Edelsohn  <dje.gcc@gmail.com>
+
+	Backport from mainline
+	2019-04-11  David Edelsohn  <dje.gcc@gmail.com>
+	* xcoffout.h (xcoff_private_rodata_section_name): Declare.
+	* xcoffout.c (xcoff_private_rodata_section_name): Define.
+	* config/rs6000/rs6000.c (rs6000_xcoff_asm_init_sections): Create
+	read_only_private_data_section using coff_private_rodata_section_name.
+	(rs6000_xcoff_file_start): Generate coff_private_rodata_section_name.
+
+	2018-12-04  David Edelsohn  <dje.gcc@gmail.com>
+	2018-12-13  David Edelsohn  <dje.gcc@gmail.com>
+	PR target/61976
+	* config/rs6000/rs6000.c (rs6000_function_arg): Don't pass aggregates
+	in FPRs on AIX. Ensure type is non-NULL.
+	(rs6000_arg_partial_bytes): Same.
+
+2019-05-14  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-05-13  Martin Liska  <mliska@suse.cz>
+
+	PR gcov-profile/90380
+	* gcov.c (handle_cycle): Do not support zero cycle count,
+	it should not be possible.
+	(path_contains_zero_cycle_arc): New function.
+	(circuit): Ignore zero cycle arc counts.
+
+2019-05-14  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-05-13  Martin Liska  <mliska@suse.cz>
+
+	PR gcov-profile/90380
+	* gcov.c (enum loop_type): Remove the enum and
+	the operator.
+	(handle_cycle): Assert that we should not reach
+	a negative count.
+	(circuit): Use loop_found instead of a tri-state loop_type.
+	(get_cycles_count): Do not handle NEGATIVE_LOOP as it can't
+	happen.
+
+2019-05-11  Andreas Tobler <andreast@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-04-25  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	* config/i386/freebsd64.h: Add bits for 32-bit multilib support.
+	* config/i386/t-freebsd64: New file.
+	* config.gcc: Add the t-freebsd64 for multilib support.
+
+2019-05-08  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-05-06  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89424
+	* config/rs6000/rs6000.c (rs6000_expand_vector_extract): Add
+	handling of V1TImode.
+
+2019-05-06  Richard Biener  <rguenther@suse.de>
+
+	PR bootstrap/90359
+	Backport from mainline
+	2019-03-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89655
+	PR bootstrap/89656
+	* vr-values.c (vr_values::update_value_range): If
+	old_vr->varying_p (), don't update it, make new_vr also VARYING
+	and return false.
+
+2019-05-03  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89698
+	* fold-const.c (operand_equal_p): For INDIRECT_REF check
+	that the access types are similar.
+
+	2019-03-07  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89595
+	* tree-ssa-dom.c (dom_opt_dom_walker::optimize_stmt): Take
+	stmt iterator as reference, take boolean output parameter to
+	indicate whether the stmt was removed and thus the iterator
+	already advanced.
+	(dom_opt_dom_walker::before_dom_children): Re-iterate over
+	stmts created by folding.
+
+	2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89710
+	* tree-ssa-loop-ch.c (should_duplicate_loop_header_p): Use
+	safe_dyn_cast.
+
+	2019-04-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90071
+	* tree-ssa-reassoc.c (init_range_entry): Do not pick up
+	abnormal operands from def stmts.
+
+	2018-08-20  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	PR target/86984
+	* expr.c (expand_assignment): Assert that bitpos is positive.
+	(store_field): Likewise
+	(expand_expr_real_1): Make sure that bitpos is positive.
+	* config/alpha/alpha.h (CONSTANT_ADDRESS_P): Avoid signed
+	integer overflow.
+
+	2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	PR target/89711
+	* config/i386/i386.c (make_resolver_func): Properly set
+	DECL_CONTEXT on the RESULT_DECL.
+	* config/rs6000/rs6000.c (make_resolver_func): Likewise.
+
+2019-04-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-04-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/90193
+	* rtl.c (classify_insn): Return JUMP_INSN for asm goto.
+	* emit-rtl.c (try_split): Copy over REG_LABEL_TARGET.
+
+	PR target/90187
+	* config/i386/i386.c (ix86_expand_sse_fp_minmax): Force if_true into
+	a register if both if_true and if_false are MEMs.
+
+	PR tree-optimization/90208
+	* tree-cfg.c (remove_bb): Move forced labels from removed bbs
+	after labels of new_bb, not before them.
+
+	2019-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/90082
+	* dce.c (can_delete_call): New function.
+	(deletable_insn_p, mark_insn): Use it.
+
+	PR tree-optimization/90090
+	* tree-ssa-math-opts.c (is_division_by): Ignore divisions that can
+	throw internally.
+	(is_division_by_square): Likewise.  Formatting fix.
+
+	2019-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/89965
+	* dce.c: Include rtl-iter.h.
+	(struct check_argument_load_data): New type.
+	(check_argument_load): New function.
+	(find_call_stack_args): Check for loads from stack slots still tracked
+	in sp_bytes and punt if any is found.
+
+	PR c/89946
+	* varasm.c (assemble_start_function): Don't use tree_fits_uhwi_p
+	and gcc_unreachable if it fails, just call tree_to_uhwi which
+	verifies that too.  Test TREE_CHAIN instead of list_length > 1.
+	Start warning message with a lower-case letter.  Formatting fixes.
+
+	PR rtl-optimization/90026
+	* cfgcleanup.c (try_optimize_cfg): When removing empty bb with no
+	successors, look for BARRIERs inside of the whole BB_FOOTER chain
+	rather than just at the start of it.  If e->src BB_FOOTER is not NULL
+	in cfglayout mode, use emit_barrier_after_bb.
+
+	2019-04-11  Jakub Jelinek  <jakub@redhat.com>
+	
+	PR rtl-optimization/89965
+	* dce.c (sp_based_mem_offset): New function.
+	(find_call_stack_args): Use sp_based_mem_offset.
+
+	2019-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90010
+	* gimple-ssa-sprintf.c (target_to_host): Fix handling of targstr
+	with strlen in between hostsz-3 and hostsz-1 inclusive when no
+	translation is needed, and when translation is needed, only append
+	... if the string length is hostsz or more bytes long.  Avoid using
+	strncpy or strcat.
+
+	2019-04-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/89998
+	* gimple-ssa-sprintf.c (try_substitute_return_value): Use lhs type
+	instead of integer_type_node if possible, don't add ranges if return
+	type is not compatible with int.
+	* gimple-fold.c (gimple_fold_builtin_sprintf,
+	gimple_fold_builtin_snprintf): Use lhs type instead of hardcoded
+	integer_type_node.
+
+	2019-03-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89872
+	* gimplify.c (gimplify_compound_literal_expr): Don't optimize a
+	non-addressable complit into its initializer if it is volatile.
+
+	2019-03-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89621
+	* tree-inline.h (struct copy_body_data): Add
+	dont_remap_vla_if_no_change flag.
+	* tree-inline.c (remap_type_3, remap_type_2): New functions.
+	(remap_type): Don't remap vla types if id->dont_remap_vla_if_no_change
+	and remap_type_2 returns false.
+	* omp-low.c (new_omp_context): Set ctx->cb.dont_remap_vla_if_no_change.
+
+	2019-03-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/89752
+	* lra-constraints.c (process_alt_operands) <reg>: For BLKmode, don't
+	update this_alternative nor this_alternative_set.
+
+	2019-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/89768
+	* loop-unroll.c (unroll_loop_constant_iterations): Use gen_int_mode
+	instead of GEN_INT.
+	(unroll_loop_runtime_iterations): Likewise.
+
+	PR target/89752
+	* gimplify.c (gimplify_asm_expr): For output argument with
+	TREE_ADDRESSABLE type, clear allows_reg if it allows memory, otherwise
+	diagnose error.
+
+	PR target/89726
+	* config/i386/i386.c (ix86_expand_floorceildf_32): In ceil
+	compensation use x2 += 1 instead of x2 -= -1 and when honoring
+	signed zeros, do another copysign after the compensation.
+
+	2019-03-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/89704
+	* dwarf2out.c (add_const_value_attribute): Return false for MINUS,
+	SIGN_EXTEND and ZERO_EXTEND.
+
+	2019-03-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/89684
+	* multiple_target.c (create_dispatcher_calls): Change
+	references_to_redirect from vector of ipa_ref * to vector of ipa_ref.
+	In the node->iterate_referring loop, push *ref rather than ref, call
+	ref->remove_reference () and always pass 0 to iterate_referring.
+
+	PR rtl-optimization/89679
+	* expmed.c (expand_mult_const): Don't add a REG_EQUAL note if it
+	would contain a paradoxical SUBREG.
+
+	PR tree-optimization/89703
+	* tree-ssa-strlen.c (valid_builtin_call): Punt if stmt call types
+	aren't compatible also with builtin_decl_explicit.  Check pure
+	or non-pure status of BUILT_IN_STR{{,N}CMP,N{LEN,{CAT,CPY}{,_CHK}}}
+	and BUILT_IN_STPNCPY{,_CHK}.
+
+	2019-03-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/89498
+	* dwarf2out.c (size_of_die): For dw_val_class_view_list always use
+	DWARF_OFFSET_SIZE.
+	(value_format): For dw_val_class_view_list never use DW_FORM_loclistx.
+
+	PR middle-end/88588
+	* omp-simd-clone.c (ipa_simd_modify_stmt_ops): Handle PHI args.
+	(ipa_simd_modify_function_body): Handle PHIs.
+
+	2019-03-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89663
+	* builtins.c (expand_builtin_int_roundingfn,
+	expand_builtin_int_roundingfn_2): Return NULL_RTX instead of
+	gcc_unreachable if validate_arglist fails.
+
+	2019-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/88568
+	* attribs.c (handle_dll_attribute): Don't clear TREE_STATIC for
+	dllimport on VAR_DECLs with RECORD_TYPE or UNION_TYPE DECL_CONTEXT.
+
+	2019-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/89587
+	* config/rs6000/t-linux (MULTIARCH_DIRNAME): Set to non-empty only
+	if_multiarch.
+
+	PR middle-end/89590
+	* builtins.c (maybe_emit_free_warning): Punt if free doesn't have
+	exactly one argument.
+
+	2019-02-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89520
+	* convert.c (convert_to_real_1, convert_to_integer_1): Punt for
+	builtins if they don't have a single scalar floating point argument.
+	Formatting fixes.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89412
+	* expr.c (expand_assignment): If result is a MEM, use change_address
+	instead of simplify_gen_subreg.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+		    David Malcolm  <dmalcolm@redhat.com>
+
+	PR middle-end/89091
+	* fold-const.c (decode_field_reference): Return NULL_TREE if
+	lang_hooks.types.type_for_size returns NULL.  Check it before
+	overwriting *exp_.  Use return NULL_TREE instead of return 0.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/88074
+	PR middle-end/89415
+	* toplev.c (do_compile): Double the emin/emax exponents to workaround
+	buggy mpc_norm.
+
+	2019-02-19  Richard Biener  <rguenther@suse.de>
+
+        PR middle-end/88074
+	* toplev.c (do_compile): Initialize mpfr's exponent range
+	based on available float modes.
+
+2019-04-30  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from mainline.
+	2019-04-30  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+	PR target/86538
+	* config/aarch64/aarch64-c.c (aarch64_update_cpp_builtins):
+	Define __ARM_FEATURE_ATOMICS.
+
+2019-04-30  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	Backport from mainline
+	2018-12-11  Richard Earnshaw  <Richard.Earnshaw@arm.com>
+
+	PR target/37369
+	* config/aarch64/iterators.md (sizem1): Add sizes for
+	SFmode and DFmode.
+	(Vbtype): Add SFmode mapping.
+	* config/aarch64/aarch64.md (copysigndf3, copysignsf3): Delete.
+	(copysign<GPF:mode>3): New expand pattern.
+	(copysign<GPF:mode>3_insn): New insn pattern.
+
+2019-04-29  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline:
+	2019-01-25  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/89037
+	* varasm.c (output_constructor_bitfield): Use wi::extract_uhwi
+	instead of accessing TREE_INT_CST_ELT directly.
+
+2019-04-29  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline:
+	2018-08-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/85910
+	* config/aarch64/aarch64.c (aarch64_expand_vec_perm_const_1): Fix
+	aarch64_evpc_tbl guard.
+
+2019-04-29  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline:
+	2019-03-08  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR debug/89631
+	* dwarf2cfi.c (dwarf2out_frame_debug_expr): Use CONST_POLY_INT
+	instead of POLY_INT_CST.
+
+2019-04-26  Roman Zhuykov  <zhroma@ispras.ru>
+
+	Backport from mainline
+	2019-04-23  Roman Zhuykov  <zhroma@ispras.ru>
+
+	PR rtl-optimization/87979
+	* modulo-sched.c (sms_schedule): Start ii value "mii" should
+	not equal zero.
+
+	PR rtl-optimization/84032
+	* modulo-sched.c (ps_insn_find_column): Change condition so that
+	branch will always be the last insn in a row inside partial
+	schedule.
+
+2019-04-19  Pat Haugen  <pthaugen@us.ibm.com>
+
+	Backport from mainline:
+	2019-04-16  Pat Haugen  <pthaugen@us.ibm.com>
+
+	PR target/84369
+	* config/rs6000/power9.md: Add store forwarding bypass.
+
+2019-04-17  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-10  Martin Jambor  <mjambor@suse.cz>
+
+        PR tree-optimization/85762
+        PR tree-optimization/87008
+        PR tree-optimization/85459
+        * tree-sra.c (contains_vce_or_bfcref_p): New parameter, set the bool
+        it points to if there is a type changing MEM_REF.  Adjust all callers.
+        (build_accesses_from_assign): Disable total scalarization if
+        contains_vce_or_bfcref_p returns true through the new parameter, for
+        both rhs and lhs.
+
+2019-04-17  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-03-15  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/87532
+	* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):
+	When handling vec_extract, use modular arithmetic to allow
+	constant selectors greater than vector length.
+	* config/rs6000/rs6000.c (rs6000_expand_vector_extract): Allow
+	V1TImode vectors to have constant selector values greater than 0.
+	Use modular arithmetic to compute vector index.
+	(rs6000_split_vec_extract_var): Use modular arithmetic to compute
+	index for in-memory vectors.  Correct code generation for
+	in-register vectors.  Use inner mode of vector rather than mode of
+	destination for move instruction.
+	(altivec_expand_vec_ext_builtin): Use modular arithmetic to
+	compute index.
+
+	2019-04-12  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/87532
+	* config/rs6000/vsx.md (*vsx_extract_<mode>_<VS_scalar>mode_var):
+	Use QI inner mode with V16QI vector mode.
+
+2019-04-15  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-04-15  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/89693
+	* cgraph.c (clone_of_p): Loop over clone chain for each step in
+	the thunk chain.
+
+2019-04-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-01-18  Martin Liska  <mliska@suse.cz>
+		    Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/88587
+	* cgraph.h (create_version_clone_with_body): Add new argument
+	with attributes.
+	* cgraphclones.c (cgraph_node::create_version_clone): Add
+	DECL_ATTRIBUTES to a newly created decl.  And call
+	valid_attribute_p so that proper cl_target_optimization_node
+	is set for the newly created declaration.
+	* multiple_target.c (create_target_clone): Set DECL_ATTRIBUTES
+	for declaration.
+	(expand_target_clones): Do not call valid_attribute_p, it must
+	be already done.
+	* tree-inline.c (copy_decl_for_dup_finish): Reset mode for
+	vector types.
+
+2019-04-11  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90018
+	* tree-vect-data-refs.c (vect_preserves_scalar_order_p):
+	Test both SLP and interleaving variants.
+
+2019-04-10  Matthew Malcomson  <matthew.malcomson@arm.com>
+
+	PR target/90024
+	* config/arm/arm.c (neon_valid_immediate): Disallow VOIDmode parameter.
+	* config/arm/constraints.md (Dm, DN, Dn): Split previous Dn constraint
+	into three.
+	* config/arm/neon.md (*neon_mov<mode>): Account for TImode and DImode
+	differences directly.
+	(*smax<mode>3_neon, vashl<mode>3, vashr<mode>3_imm): Use Dm constraint.
+
+2019-04-07  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/89945
+	* config/i386/i386.md (anddi_1 to andsi_1_zext splitter):
+	Avoid calling gen_lowpart with SYMBOL_REF and LABEL_REF operand.
+
+2019-04-04  Martin Sebor  <msebor@redhat.com>
+
+	PR middle-end/89934
+	* gimple-ssa-warn-restrict.c (builtin_access::builtin_access): Bail
+	out if the number of arguments is less than expected.
+
+2019-04-03  Richard Biener  <rguenther@suse.de>
+
+	PR lto/89896
+	* lto-wrapper.c (run_gcc): Avoid implicit rules making
+	the all target phony.
+
+2019-04-02  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/89902
+	PR target/89903
+	* config/i386/i386.c (dimode_scalar_to_vector_candidate_p):
+	Return false for variable DImode shifts.
+	(dimode_scalar_chain::compute_convert_gain): Do not handle
+	register count operand in variable DImode shifts.
+	(dimode_scalar_chain::make_vector_copies): Remove support to copy
+	count argument of a variable shift instruction to a vector register.
+	(dimode_scalar_chain::convert_reg): Remove support to convert
+	count argument of a variable shift instruction.
+
+2019-03-29  Kugan Vivekanandarajah  <kuganv@linaro.org>
+
+	Backport from mainline
+	2019-03-29  Kugan Vivekanandarajah  <kuganv@linaro.org>
+		    Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/89862
+	* rtl.h (word_register_operation_p): Exclude CONST_INT from operations
+	that operates on the full registers for WORD_REGISTER_OPERATIONS
+	architectures.
+
+2019-03-28  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/89848
+	* config/i386/i386.c (dimode_scalar_chain::make_vector_copies):
+	Also process XEXP (src, 0) of a shift insn.
+
+2019-03-28  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-11-05  Martin Liska  <mliska@suse.cz>
+
+	PR web/87829
+	* doc/invoke.texi: Remove options that are
+	not disabled with -Os.
+
+2019-03-26  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/89827
+	* config/i386/i386.c (dimode_scalar_chain::convert_reg):
+	Also process XEXP (src, 0) of a shift insn.
+
+2019-03-25  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-03-20  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	PR target/89775
+	* config/s390/s390.c (global_not_special_regno_p): Move to make it
+	available to ...
+	(s390_optimize_register_info): Use global_not_special_regno_p to
+	check for global regs.
+
+2019-03-22  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from mainline
+	2019-03-22  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	* config/rs6000/mmintrin.h (_mm_sub_pi32): Fix typo.
+
+2019-03-21  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+        Backport from mainline
+        2019-03-08  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+        * config/rs6000/rs6000-p8swap.c (rs6000_analyze_swaps): Rebuild
+        ud- and du-chains between phases.
+
+2019-03-19  Richard Biener  <rguenther@suse.de>
+
+	PR debug/88389
+	* opts.c (finish_options): Disable -gsplit-dwarf when doing LTO.
+
+2019-03-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/89753
+	* loop-unroll.c (decide_unroll_constant_iterations): Make guard for
+	explicit unrolling factor even more robust.
+
+2019-03-18  Martin Sebor  <msebor@redhat.com>
+
+	PR middle-end/88273
+	* gimple-ssa-warn-restrict.c (builtin_memref::extend_offset_range):
+	Handle anti-ranges the same as no range at all.
+
+2019-03-18  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-18  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/89546
+	* tree-sra.c (propagate_subaccesses_across_link): Requeue new_acc if
+	any propagation to its children took place.
+
+2019-03-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2019-03-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/89523
+	* config/i386/i386.c (ix86_print_operand): Handle 'M' to add
+	addr32 prefix to VSIB address for X32.
+	* config/i386/sse.md (*avx512pf_gatherpf<mode>sf_mask): Prepend
+	"%M2" to opcode.
+	(*avx512pf_gatherpf<mode>df_mask): Likewise.
+	(*avx512pf_scatterpf<mode>sf_mask): Likewise.
+	(*avx512pf_scatterpf<mode>df_mask): Likewise.
+	(*avx2_gathersi<mode>): Prepend "%M3" to opcode.
+	(*avx2_gathersi<mode>_2): Prepend "%M2" to opcode.
+	(*avx2_gatherdi<mode>): Prepend "%M3" to opcode.
+	(*avx2_gatherdi<mode>_2): Prepend "%M2" to opcode.
+	(*avx2_gatherdi<mode>_3): Prepend "%M3" to opcode.
+	(*avx2_gatherdi<mode>_4): Prepend "%M2" to opcode.`
+	(*avx512f_gathersi<mode>): Prepend "%M4" to opcode.
+	(*avx512f_gathersi<mode>_2): Prepend "%M3" to opcode.
+	(*avx512f_gatherdi<mode>): Prepend "%M4" to opcode.
+	(*avx512f_gatherdi<mode>_2): Prepend "%M3" to opcode.
+	(*avx512f_scattersi<mode>): Prepend "%M0" to opcode.
+	(*avx512f_scatterdi<mode>): Likewise.
+
+2019-03-15  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-11-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR testsuite/85368
+	* params.def (PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT): New param.
+	* tree-ssa-ifcombine.c (ifcombine_ifandif): If
+	--param logical-op-non-short-circuit is present, override
+	LOGICAL_OP_NON_SHORT_CIRCUIT value from the param.
+	* fold-const.c (fold_range_test, fold_truth_andor): Likewise.
+
+2019-03-15  Martin Liska  <mliska@suse.cz>
+
+	PR other/89712
+	* doc/invoke.texi: Remove -fdump-class-hierarchy option.
+
+2019-03-14  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-07  Martin Jambor  <mjambor@suse.cz>
+
+	PR lto/87525
+	* ipa-cp.c (perform_estimation_of_a_value): Account zero time benefit
+	for extern inline functions.
+
+2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89572
+	* tree-scalar-evolution.c (get_loop_exit_condition): Use
+	safe_dyn_cast.
+	* tree-ssa-loop-ivcanon.c (canonicalize_loop_induction_variables):
+	Use gimple_location_safe.
+
+2019-03-13  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR target/85860
+	* lra-constraints.c (inherit_in_ebb): Update
+	potential_reload_hard_regs along with live_hard_regs.
+
+2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-03-13  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89677
+	* tree-scalar-evolution.c (simplify_peeled_chrec): Do not
+	throw FP expressions at tree-affine.
+
+	2019-03-01  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89497
+	* tree-cfgcleanup.h (cleanup_tree_cfg): Add SSA update flags
+	argument, defaulted to zero.
+	* passes.c (execute_function_todo): Pass down SSA update flags
+	to cleanup_tree_cfg.
+	* tree-cfgcleanup.c: Include tree-into-ssa.h and tree-cfgcleanup.h.
+	(cleanup_tree_cfg_1): After cleanup_control_flow_pre update SSA
+	form if requested.
+	(cleanup_tree_cfg_noloop): Pass down SSA update flags.
+	(cleanup_tree_cfg): Get and pass down SSA update flags.
+
+	2019-02-18  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89296
+	* tree-ssa-loop-ch.c (ch_base::copy_headers): Restrict setting
+	of no-warning flag to cases that might emit the bogus warning.
+
+2019-03-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-03-11  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/s390.c (s390_expand_builtin): Do the copy_to_reg not
+	only on the else branch.
+
+2019-03-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-02-07  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/s390-builtin-types.def: Add new types.
+	* config/s390/s390-builtins.def: (s390_vec_xl, s390_vec_xld2)
+	(s390_vec_xlw4): Make the memory operand into a const pointer.
+	(s390_vec_xld2, s390_vec_xlw4): Add a variant for single precision
+	float.
+	* config/s390/s390-c.c (s390_expand_overloaded_builtin): Generate
+	a new vector type with the alignment of the scalar memory operand.
+
+2019-03-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89664
+	* tree-ssa-math-opts.c (execute_cse_reciprocals_1): Properly
+	free the occurance tree after the early out.
+
+2019-03-12  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2019-03-08  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* config/arm/arm.h (TARGET_FP16_TO_DOUBLE): Add TARGET_VFP_DOUBLE
+	requirement.
+
+2019-03-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/89588
+	* loop-unroll.c (decide_unroll_constant_iterations): Make guard for
+	explicit unrolling factor more robust.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-03-08  Martin Liska  <mliska@suse.cz>
+
+	PR target/86952
+	* config/i386/i386.c (ix86_option_override_internal): Disable
+	jump tables when retpolines are used.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-11  David Malcolm  <dmalcolm@redhat.com>
+
+	PR lto/88147
+	* input.c (selftest::test_line_offset_overflow): New selftest.
+	(selftest::input_c_tests): Call it.
+
+2019-03-08  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-07  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/88235
+	* cgraph.h (cgraph_node): New inline method former_thunk_p.
+	* cgraph.c (cgraph_node::dump): Dump a note if node is a former thunk.
+	(clone_of_p): Treat expanded thunks like thunks, be optimistic if they
+	have multiple callees.  At the end check if declarations match as
+	opposed to cgraph_nodes.
+
+2019-03-06  Tamar Christina  <tamar.christina@arm.com>
+
+	Backport from trunk.
+	2019-02-25  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/88530
+	* common/config/aarch64/aarch64-common.c
+	(struct aarch64_option_extension): Add is_synthetic.
+	(all_extensions): Use it.
+	(TARGET_OPTION_INIT_STRUCT): Define hook.
+	(struct gcc_targetm_common): Moved to end.
+	(all_extensions_by_on): New.
+	(opt_ext_cmp, typedef opt_ext): New.
+	(aarch64_option_init_struct): New.
+	(aarch64_contains_opt): New.
+	(aarch64_get_extension_string_for_isa_flags): Output smallest set.
+	* config/aarch64/aarch64-option-extensions.def
+	(AARCH64_OPT_EXTENSION): Explicitly include AES and SHA2 in crypto.
+	(fp, simd, crc, lse, fp16, rcpc, rdma, dotprod, aes, sha2, sha3,
+	sm4, fp16fml, sve):
+	Set is_synthetic to false.
+	(crypto): Set is_synthetic to true.
+	* config/aarch64/driver-aarch64.c (AARCH64_OPT_EXTENSION): Add
+	SYNTHETIC.
+
+2019-03-06  Tamar Christina  <tamar.christina@arm.com>
+
+	Backport from trunk.
+	2019-02-28  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/88530
+	* config/aarch64/aarch64-option-extensions.def: Document it.
+	* config/aarch64/driver-aarch64.c (host_detect_local_cpu): Skip feature
+	if empty hwcaps.
+
+2019-03-06  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport of r268834 from mainline to gcc-8-branch.
+	2019-02-13  Xiong Hu Luo  <luoxhu@linux.vnet.ibm.com>
+
+	* config/rs6000/altivec.h (vec_sbox_be, vec_cipher_be,
+	vec_cipherlast_be, vec_ncipher_be, vec_ncipherlast_be): New #defines.
+	* config/rs6000/crypto.md (CR_vqdi): New define_mode_iterator.
+	(crypto_vsbox_<mode>, crypto_<CR_insn>_<mode>): New define_insns.
+	* config/rs6000/rs6000-builtin.def (VSBOX_BE): New BU_CRYPTO_1.
+	(VCIPHER_BE, VCIPHERLAST_BE, VNCIPHER_BE, VNCIPHERLAST_BE):
+	New BU_CRYPTO_2.
+	* config/rs6000/rs6000.c (builtin_function_type)
+	<CRYPTO_BUILTIN_VSBOX_BE, CRYPTO_BUILTIN_VCIPHER_BE,
+	CRYPTO_BUILTIN_VCIPHERLAST_BE, CRYPTO_BUILTIN_VNCIPHER_BE,
+	CRYPTO_BUILTIN_VNCIPHERLAST_BE>: New switch options.
+	* doc/extend.texi (vec_sbox_be, vec_cipher_be, vec_cipherlast_be,
+	vec_ncipher_be, vec_ncipherlast_be): New builtin functions.
+
+2019-03-05  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-02-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89505
+	* tree-ssa-structalias.c (compute_dependence_clique): Make sure
+	to handle restrict pointed-to vars with multiple subvars
+	correctly.
+
+2019-03-01  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/89517
+	* config/aarch64/aarch64-option-extensions.def (fp, simd, crypto,
+	fp16): Collapse line.
+
+2019-03-01  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-03-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR bootstrap/89539
+	* dwarf2out.c (output_comdat_type_unit): Add ATTRIBUTE_UNUSED to
+	early_lto_debug argument.
+
+	2019-02-27  Richard Biener  <rguenther@suse.de>
+
+	PR debug/88878
+	* dwarf2out.c (use_debug_types): Disable when in_lto_p.
+
+	2019-02-27  Richard Biener  <rguenther@suse.de>
+
+	PR debug/88878
+	* dwarf2out.c (output_comdat_type_unit): Add early_lto_debug
+	parameter, prefix section name with .gnu.debuglto_ if true.
+	(dwarf2out_finish): Pass false to output_comdat_type_unit.
+	(dwarf2out_early_finish): Pass true to output_comdat_type_unit.
+
+	2019-02-27  Richard Biener  <rguenther@suse.de>
+
+	PR debug/89514
+	* dwarf2out.c (size_of_die): Key on AT_ref (a)->comdat_type_p
+	rather than on use_debug_types, doing what output_die does.
+	(value_format): Likewise.
+
+2019-02-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR tree-optimization/89536
+	* tree-ssa-dom.c (edge_info::derive_equivalences) <BIT_NOT_EXPR>: Test
+	only whether bit #0 of the value is 0 instead of the entire value.
+
+2019-02-28  Li Jia He  <helijia@linux.ibm.com>
+
+	Backport from trunk
+	2019-02-20  Li Jia He  <helijia@linux.ibm.com>
+
+	PR target/88100
+	* gcc/config/rs6000/rs6000.c (rs6000_gimple_fold_builtin)
+	<case ALTIVEC_BUILTIN_VSPLTISB, ALTIVEC_BUILTIN_VSPLTISH,
+	ALTIVEC_BUILTIN_VSPLTISW>: Don't convert the operand before
+	range checking it.
+
+2019-02-27  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/89397
+	* config/i386/i386.c (ix86_atomic_assign_expand_fenv): Check
+	TARGET_SSE in addition to TARGET_SSE_MATH.
+
+	(ix86_excess_precision): Ditto.
+	(ix86_float_exceptions_rounding_supported_p): Ditto.
+	(use_rsqrt_p): Ditto.
+	* config/i386/sse.md (rsqrt<mode>2): Ditto.
+
+2019-02-27  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-02-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/89361
+	* config/s390/s390.c (s390_indirect_branch_attrvalue,
+	s390_indirect_branch_settings): Define unconditionally.
+	(s390_set_current_function): Likewise, but guard the whole body except
+	the s390_indirect_branch_settings call with
+	#if S390_USE_TARGET_ATTRIBUTE.
+	(TARGET_SET_CURRENT_FUNCTION): Redefine unconditionally.
+
+2019-02-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2019-02-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* rtlanal.c (get_initial_register_offset): Fall back to the estimate
+	as long as the epilogue isn't completed.
+
+2019-02-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* tree-ssa-dom.c (edge_info::derive_equivalences) <BIT_IOR_EXPR>: Fix
+	and move around comment.
+	<BIT_AND_EXPR>: Likewise.
+	<BIT_NOT_EXPR>: Add specific handling for boolean types.
+
+2019-02-24  Alan Modra  <amodra@gmail.com>
+
+	PR target/89271
+	* config/rs6000/rs6000.md (<bd>_<mode> split): Check for an int
+	output reg on add insn.
+	(<bd>tf_<mode> split): Likewise.  Match predicates with insn.
+
+2019-02-22  Jakub Jelinek  <jakub@redhat.com>
+
+	* BASE-VER: Set to 8.3.1.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
@@ -568,7 +1799,7 @@
 
 	Backport from mainline
 	2018-11-20  Richard Biener  <rguenther@suse.de>
- 
+
 	PR tree-optimization/88105
 	* tree-ssa-dom.c (pass_dominator::execute): Do not walk
 	backedges.
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-18d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18d.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18d.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,148 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Unsigned Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned int s3 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector unsigned int s1 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector unsigned int s21 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned int s30 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned int ms3 (vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector unsigned int ms1(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector unsigned int ms21(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned int ms30(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned int ci (vector unsigned int v, int i, unsigned int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned int mci(vector unsigned int *vp, int i, unsigned int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, unsigned char *argv[]) {
+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };
+
+  sv = s3 (sv, CONST2);
+  if (sv [3] != CONST2)
+    abort ();
+
+  sv = s1 (sv, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST1);
+  if (sv [2] != CONST1)
+    abort ();
+
+  sv = ms3 (&sv, CONST0);
+  if (sv [3] != CONST0)
+    abort ();
+
+  sv = ms1 (&sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ms21 (&sv, CONST1);
+  if (sv [1] != CONST1)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = ci (sv, 2, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 15, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = mci (&sv, 12, CONST2);
+  if (sv [0] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 25, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 16, CONST1);
+  if (sv [0] != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-19c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19c.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19c.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,122 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+#define CONST2		(3 * 31415926539LL)
+#define CONST3		(4 * 31415926539LL)
+#define CONST4		(5 * 31415926539LL)
+#define CONST5		(6 * 31415926539LL)
+#define CONST6		(7 * 31415926539LL)
+#define CONST7		(8 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned long long int
+e0 (vector unsigned long long int v, unsigned long long int x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned long long int
+e3 (vector unsigned long long int v, unsigned long long int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned long long int
+me0 (vector unsigned long long int *vp, unsigned long long int x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned long long int
+me3 (vector unsigned long long int *vp, unsigned long long int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned long long int
+ei (vector unsigned long long int v, int i, unsigned long long int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned long long int
+mei (vector unsigned long long int *vp, int i, unsigned long long int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned long long int dv = { CONST0, CONST1 };
+  unsigned long long int d;
+
+  dv = e0 (dv, CONST7);
+  if (dv [0] != CONST7)
+    abort ();
+
+  dv = e3 (dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = me0 (&dv, CONST4);
+  if (dv [0] != CONST4)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST5);
+  if (dv [0] != CONST5)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST6);
+  if (dv [1] != CONST6)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-10a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10a.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10a.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+short s3 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 3);
+}
+
+short s7 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 7);
+}
+
+short s21 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 21);
+}
+
+short s30 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+short ms3 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 3);
+}
+
+short ms7 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 7);
+}
+
+short ms21 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 21);
+}
+
+short ms30 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+short ci (vector short v, int i)
+{
+  return __builtin_vec_ext_v8hi (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+short mci (vector short *vp, int i)
+{
+  return __builtin_vec_ext_v8hi (*vp, i);
+}
+
+
+int main (int argc, short *argv[]) {
+  vector short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  short s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s7 (sv);
+  if (s != CONST7)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST5)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms7 (&sv);
+  if (s != CONST7)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST5)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST7)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-20a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20a.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20a.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+/* Define this after PR89424 is addressed.  */
+#define PR89424
+
+extern void abort (void);
+
+#define CONST0		(((unsigned __int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned __int128 e0 (vector unsigned __int128 v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned __int128 e3 (vector unsigned __int128 v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+unsigned __int128 me0 (vector unsigned __int128 *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned __int128 me3 (vector unsigned __int128 *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+#ifdef PR89424
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned __int128 ei (vector unsigned __int128 v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+unsigned __int128 mei (vector unsigned __int128 *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+#endif
+
+int main (int argc, char *argv[]) {
+  vector unsigned __int128 dv = { CONST0 };
+  unsigned __int128 d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST0)
+    abort ();
+
+#ifdef PR89424
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+#endif
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-10c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10c.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10c.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector short s3 (vector short v, short x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector short s7 (vector short v, short x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector short s21 (vector short v, short x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector short s30 (vector short v, short x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector short ms3 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector short ms7 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 7);
+}
+
+vector short ms21 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector short ms30 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector short ci (vector short v, int i, short x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector short mci (vector short *vp, int i, short x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, short *argv[]) {
+  vector short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  short s;
+
+  sv = s3 (sv, CONST6);
+  if (sv [3] != CONST6)
+    abort ();
+
+  sv = s7 (sv, CONST4);
+  if (sv [7] != CONST4)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST2);
+  if (sv [6] != CONST2)
+    abort ();
+
+  sv = ms3 (&sv, CONST5);
+  if (sv [3] != CONST5)
+    abort ();
+
+  sv = ms7 (&sv, CONST1);
+  if (sv [7] != CONST1)
+    abort ();
+
+  sv = ms21 (&sv, CONST2);
+  if (sv [5] != CONST2)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [6] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST6);
+  if (sv [5] != CONST6)
+    abort ();
+
+  sv = ci (sv, 2, CONST4);
+  if (sv [2] != CONST4)
+    abort ();
+
+  sv = ci (sv, 15, CONST3);
+  if (sv [7] != CONST3)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [4] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 12, CONST7);
+  if (sv [4] != CONST7)
+    abort ();
+
+  sv = mci (&sv, 25, CONST6);
+  if (sv [1] != CONST6)
+    abort ();
+
+  sv = mci (&sv, 16, CONST5);
+  if (sv [0] != CONST5)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-11b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11b.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11b.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+int s3 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 3);
+}
+
+int s1 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 1);
+}
+
+int s21 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 21);
+}
+
+int s30 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+int ms3 (vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 3);
+}
+
+int ms1(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 1);
+}
+
+int ms21(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 21);
+}
+
+int ms30(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+int ci (vector int v, int i)
+{
+  return __builtin_vec_ext_v4si (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+int mci(vector int *vp, int i)
+{
+  return __builtin_vec_ext_v4si (*vp, i);
+}
+
+
+int main (int argc, int *argv[]) {
+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };
+  int s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s1 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms1 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST3)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-9b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9b.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9b.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,164 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+signed char c0 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 0);
+}
+
+signed char c9 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 9);
+}
+
+signed char c21 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 21);
+}
+
+signed char c30 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+signed char mc0 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 0);
+}
+
+signed char mc9 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 9);
+}
+
+signed char mc21 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 21);
+}
+
+signed char mc30 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+signed char ci (vector signed char v, int i)
+{
+  return __builtin_vec_ext_v16qi (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+signed char mci(vector signed char *vp, int i) {
+  return __builtin_vec_ext_v16qi (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  signed char c;
+
+  c = c0 (cv);
+  if (c != CONST0)
+    abort ();
+
+  c = c9 (cv);
+  if (c != CONST9)
+    abort ();
+
+  c = c21 (cv);
+  if (c != CONST5)
+    abort ();
+
+  c = c30 (cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = mc0 (&cv);
+  if (c != CONST0)
+    abort ();
+
+  c = mc9 (&cv);
+  if (c != CONST9)
+    abort ();
+
+  c = mc21 (&cv);
+  if (c != CONST5)
+    abort ();
+
+  c = mc30 (&cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = ci (cv, 8);
+  if (c != CONST8)
+    abort ();
+
+  c = ci (cv, 13);
+  if (c != CONSTD)
+    abort ();
+
+  c = ci (cv, 23);
+  if (c != CONST7)
+    abort ();
+
+  c = ci (cv, 31);
+  if (c != CONSTF)
+    abort ();
+
+  c = mci (&cv, 5);
+  if (c != CONST5)
+    abort ();
+
+  c = mci (&cv, 12);
+  if (c != CONSTC)
+    abort ();
+
+  c = mci (&cv, 25);
+  if (c != CONST9)
+    abort ();
+
+  c = mci (&cv, 16);
+  if (c != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-12a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12a.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12a.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,109 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+long long int e0 (vector long long int v)
+{
+  return __builtin_vec_ext_v2di (v, 0);
+}
+
+long long int e3 (vector long long int v)
+{
+  return __builtin_vec_ext_v2di (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+long long int me0 (vector long long int *vp)
+{
+  return __builtin_vec_ext_v2di (*vp, 0);
+}
+
+long long int me3 (vector long long int *vp)
+{
+  return __builtin_vec_ext_v2di (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+long long int ei (vector long long int v, int i)
+{
+  return __builtin_vec_ext_v2di (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+long long int mei (vector long long int *vp, int i)
+{
+  return __builtin_vec_ext_v2di (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector long long int dv = { CONST0, CONST1 };
+  long long int d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-20c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20c.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20c.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(((unsigned __int128) 31415926539) << 60)
+#define CONST1		(((unsigned __int128) 31415926539) << 54)
+#define CONST2		(((unsigned __int128) 31415926539) << 48)
+#define CONST3		(((unsigned __int128) 31415926539) << 32)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned __int128 e0 (vector unsigned __int128 v, unsigned __int128 x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned __int128 e3 (vector unsigned __int128 v, unsigned __int128 x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned __int128
+me0 (vector unsigned __int128 *vp, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned __int128
+me3 (vector unsigned __int128 *vp, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned __int128
+ei (vector unsigned __int128 v, int i, unsigned __int128 x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned __int128
+mei (vector unsigned __int128 *vp, int i, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned __int128 dv = { CONST0 };
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me0 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST0);
+  if (dv [0] != CONST0)
+    abort ();
+
+  dv = ei (dv, 1, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = ei (dv, 3, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 0, CONST0);
+  if (dv [0] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 1, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 3, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-11d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11d.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11d.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector int s3 (vector int v, int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector int s1 (vector int v, int x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector int s21 (vector int v, int x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector int s30 (vector int v, int x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector int ms3  (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector int ms1 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector int ms21 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector int ms30 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector int ci (vector int v, int i, int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector int mci(vector int *vp, int i, int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, int *argv[]) {
+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };
+  int s;
+
+  sv = s3 (sv, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = s1 (sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = s21 (sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = s30 (sv, CONST1);
+  if (sv [2] != CONST1)
+    abort ();
+
+  sv = ms3 (&sv, CONST2);
+  if (sv [3] != CONST2)
+    abort ();
+
+  sv = ms1 (&sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ms21 (&sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ci (sv, 2, CONST3);
+  if (sv [2] != CONST3)
+    abort ();
+
+  sv = ci (sv, 15, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 12, CONST1);
+  if (sv [0] != CONST1)
+    abort ();
+
+  sv = mci (&sv, 25, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 16, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-9d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9d.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9d.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,164 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector signed char c0 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector signed char c9 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 9);
+}
+
+vector signed char c21 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector signed char c30 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector signed char mc0 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector signed char mc9 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 9);
+}
+
+vector signed char mc21 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector signed char mc30 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector signed char ci (vector signed char v, int i, signed char x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector signed char mci(vector signed char *vp, int i, signed char x) {
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  signed char c;
+
+  cv = c0 (cv, CONSTF);
+  if (cv [0] != CONSTF)
+    abort ();
+
+  cv = c9 (cv, CONST7);
+  if (cv [9] != CONST7)
+    abort ();
+
+  cv = c21 (cv, CONSTA);
+  if (cv [5] != CONSTA)
+    abort ();
+
+  cv = c30 (cv, CONSTC);
+  if (cv [14] != CONSTC)
+    abort ();
+
+  cv = mc0 (&cv, CONSTB);
+  if (cv [0] != CONSTB)
+    abort ();
+
+  cv = mc9 (&cv, CONST1);
+  if (cv [9] != CONST1)
+    abort ();
+
+  cv = mc21 (&cv, CONST7);
+  if (cv [5] != CONST7)
+    abort ();
+
+  cv = mc30 (&cv, CONST2);
+  if (cv [14] != CONST2)
+    abort ();
+
+  cv = ci (cv, 8, CONST4);
+  if (cv [8] != CONST4)
+    abort ();
+
+  cv = ci (cv, 13, CONSTB);
+  if (cv [13] != CONSTB)
+    abort ();
+
+  cv = ci (cv, 23, CONST3);
+  if (cv [7] != CONST3)
+    abort ();
+
+  cv = ci (cv, 31, CONST2);
+  if (cv [15] != CONST2)
+    abort ();
+
+  cv = mci (&cv, 5, CONST1);
+  if (cv [5] != CONST1)
+    abort ();
+
+  cv = mci (&cv, 12, CONST3);
+  if (cv [12] != CONST3)
+    abort ();
+
+  cv = mci (&cv, 25, CONST5);
+  if (cv [9] != CONST5)
+    abort ();
+
+  cv = mci (&cv, 16, CONSTD);
+  if (cv [0] != CONSTD)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-12c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12c.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12c.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,112 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+#define CONST2		(3 * 31415926539LL)
+#define CONST3		(4 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector long long int e0 (vector long long int v, long long int x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector long long int e3 (vector long long int v, long long int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector long long int me0 (vector long long int *vp, long long int x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector long long int me3 (vector long long int *vp, long long int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector long long int ei (vector long long int v, int i, long long int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector long long int mei (vector long long int *vp, int i, long long int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector long long int dv = { CONST0, CONST1 };
+  long long int d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = me0 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 0, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 3, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-13b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13b.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13b.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,124 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+/* Define this after PR89424 is addressed.  */
+#define PR89424
+
+/* Define this after PR89626 is addressed.  */
+#undef PR89626
+
+#ifdef PR89626
+#define SIGNED
+#else
+#define SIGNED signed
+#endif
+
+extern void abort (void);
+
+#define CONST0		(((SIGNED __int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+SIGNED __int128 e0 (vector SIGNED __int128 v)
+{
+  return __builtin_vec_ext_v1ti (v, 0);
+}
+
+SIGNED __int128 e3 (vector SIGNED __int128 v)
+{
+  return __builtin_vec_ext_v1ti (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+SIGNED __int128 me0 (vector SIGNED __int128 *vp)
+{
+  return __builtin_vec_ext_v1ti (*vp, 0);
+}
+
+SIGNED __int128 me3 (vector SIGNED __int128 *vp)
+{
+  return __builtin_vec_ext_v1ti (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+#ifdef PR89424
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+SIGNED __int128 ei (vector SIGNED __int128 v, int i)
+{
+  return __builtin_vec_ext_v1ti (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+SIGNED __int128 mei (vector SIGNED __int128 *vp, int i)
+{
+  return __builtin_vec_ext_v1ti (*vp, i);
+}
+#endif
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  SIGNED __int128 d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST0)
+    abort ();
+
+#ifdef PR89424
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+#endif
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-14a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14a.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14a.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,126 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		((float) (3.1415926539))
+#define CONST1		((float) (3.1415926539 * 2))
+#define CONST2		((float) (3.1415926539 * 3))
+#define CONST3		((float) (3.1415926539 * 4))
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+float e0(vector float v){ return __builtin_vec_ext_v4sf (v, 0); }
+float e1(vector float v){ return __builtin_vec_ext_v4sf (v, 1); }
+float e7(vector float v){ return __builtin_vec_ext_v4sf (v, 7); }
+float e8(vector float v){ return __builtin_vec_ext_v4sf (v, 8); }
+
+/* Test for vector residing in memory.  */
+float me0(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 0); }
+float me1(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 1); }
+
+float me13(vector float *vp)
+{
+  return __builtin_vec_ext_v4sf (*vp, 13);
+}
+
+float me15(vector float *vp)
+{
+  return __builtin_vec_ext_v4sf (*vp, 15);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+float ei(vector float v, int i)
+{
+  return __builtin_vec_ext_v4sf (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+float mei(vector float *vp, int i)
+{
+  return __builtin_vec_ext_v4sf (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };
+  float d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e1 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = e7 (dv);
+  if (d != CONST3)
+    abort ();
+
+  d = e8 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me1 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me13 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me15 (&dv);
+  if (d != CONST3)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST2)
+    abort ();
+
+  d = ei (dv, 11);
+  if (d != CONST3)
+    abort ();
+
+  d = ei (dv, 17);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 15);
+  if (d != CONST3)
+    abort ();
+
+  d = mei (&dv, 6);
+  if (d != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2a.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2a.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,14 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O2 -mvsx" } */
+
+#define TYPE unsigned char
+/* ELEMENTS is number of elements in a vector of TYPE.  */
+#define ELEMENTS 16
+#define INITIAL \
+  {  3, 2, 3, 4, 5, 6, 7, 8, 240, 241, 242, 243, 244, 245, 246, 247 }
+
+#define DO_TRACE
+#define DISABLE_INLINE_OF_GET_AUTO_N
+
+#include "vec-extract-v16qiu-v2.h"
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-13d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13d.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13d.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+#define SIGNED signed
+
+extern void abort (void);
+
+#define CONST0		(((SIGNED __int128) 31415926539) << 60)
+#define CONST1		(((SIGNED __int128) 31415926539) << 55)
+#define CONST2		(((SIGNED __int128) 31415926539) << 50)
+#define CONST3		(((SIGNED __int128) 31415926539) << 45)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector SIGNED __int128 e0 (vector SIGNED __int128 v, SIGNED __int128 x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector SIGNED __int128 e3 (vector SIGNED __int128 v, SIGNED __int128 x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector SIGNED __int128 me0 (vector SIGNED __int128 *vp, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector SIGNED __int128 me3 (vector SIGNED __int128 *vp, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector SIGNED __int128
+ei (vector SIGNED __int128 v, int i, SIGNED __int128 x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector SIGNED __int128
+mei (vector SIGNED __int128 *vp, int i, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  SIGNED __int128 d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 0, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 1, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-14c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14c.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14c.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		((float) (3.1415926539))
+#define CONST1		((float) (3.1415926539 * 2))
+#define CONST2		((float) (3.1415926539 * 3))
+#define CONST3		((float) (3.1415926539 * 4))
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector float e0(vector float v, float x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector float e1(vector float v, float x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector float e7(vector float v, float x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector float e8(vector float v, float x)
+{
+  return vec_insert (x, v, 8);
+}
+
+/* Test for vector residing in memory.  */
+vector float me0(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector float me1(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector float me13(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 13);
+}
+
+vector float me15(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 15);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector float ei(vector float v, int i, float x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector float mei(vector float *vp, int i, float x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };
+  float d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e1 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = e7 (dv, CONST2);
+  if (dv [3] != CONST2)
+    abort ();
+
+  dv = e8 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me1 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = me13 (&dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = me15 (&dv, CONST1);
+  if (dv [3] != CONST1)
+    abort ();
+
+  dv = ei (dv, 0, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 2, CONST1);
+  if (dv [2] != CONST1)
+    abort ();
+
+  dv = ei (dv, 11, CONST0);
+  if (dv [3] != CONST0)
+    abort ();
+
+  dv = ei (dv, 17, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 15, CONST1);
+  if (dv [3] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 6, CONST0);
+  if (dv [2] != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-15b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15b.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15b.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,113 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(3.1415926539)
+#define CONST1		(3.1415926539 * 2)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+double e0(vector double v){ return __builtin_vec_ext_v2df (v, 0); }
+double e1(vector double v){ return __builtin_vec_ext_v2df (v, 1); }
+double e2(vector double v){ return __builtin_vec_ext_v2df (v, 2); }
+double e3(vector double v){ return __builtin_vec_ext_v2df (v, 3); }
+
+/* Test for vector residing in memory.  */
+double me0(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 0); }
+double me1(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 1); }
+double me2(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 2); }
+double me3(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 3); }
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+double ei(vector double v, int i){ return __builtin_vec_ext_v2df (v, i); }
+
+/* Test for variable selector and vector residing in memory.  */
+double mei(vector double *vp, int i){ return __builtin_vec_ext_v2df (*vp, i); }
+
+
+int main (int argc, char *argv[]) {
+  vector double dv;
+  double d;
+  dv[0] = CONST0;
+  dv[1] = CONST1;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e1 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = e2 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me1 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me2 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-16a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16a.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16a.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,165 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned char c0 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned char c9 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 9);
+}
+
+unsigned char c21 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned char c30 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned char mc0 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned char mc9 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 9);
+}
+
+unsigned char mc21 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned char mc30 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned char ci (vector unsigned char v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned char mci (vector unsigned char *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  unsigned char c;
+
+  c = c0 (cv);
+  if (c != CONST0)
+    abort ();
+
+  c = c9 (cv);
+  if (c != CONST9)
+    abort ();
+
+  c = c21 (cv);
+  if (c != CONST5)
+    abort ();
+
+  c = c30 (cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = mc0 (&cv);
+  if (c != CONST0)
+    abort ();
+
+  c = mc9 (&cv);
+  if (c != CONST9)
+    abort ();
+
+  c = mc21 (&cv);
+  if (c != CONST5)
+    abort ();
+
+  c = mc30 (&cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = ci (cv, 8);
+  if (c != CONST8)
+    abort ();
+
+  c = ci (cv, 13);
+  if (c != CONSTD)
+    abort ();
+
+  c = ci (cv, 23);
+  if (c != CONST7)
+    abort ();
+
+  c = ci (cv, 31);
+  if (c != CONSTF)
+    abort ();
+
+  c = mci (&cv, 5);
+  if (c != CONST5)
+    abort ();
+
+  c = mci (&cv, 12);
+  if (c != CONSTC)
+    abort ();
+
+  c = mci (&cv, 25);
+  if (c != CONST9)
+    abort ();
+
+  c = mci (&cv, 16);
+  if (c != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-15d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15d.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15d.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,151 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(3.1415926539)
+#define CONST1		(3.1415926539 * 2)
+#define CONST2		(3.1415926539 * 3)
+#define CONST3		(3.1415926539 * 4)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector double e0(vector double v, double x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector double e1(vector double v, double x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector double e2(vector double v, double x)
+{
+  return vec_insert (x, v, 2);
+}
+
+vector double e3(vector double v, double x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector double me0(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector double me1(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector double me2(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 2);
+}
+
+vector double me3(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector double ei(vector double v, int i, double x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector double mei(vector double *vp, int i, double x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector double dv;
+  double d;
+  dv[0] = CONST0;
+  dv[1] = CONST1;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e1 (dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = e2 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = e3 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me1 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = me2 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = ei (dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 3, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-16c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16c.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16c.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,180 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <stdio.h>
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned char c0 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned char c9 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 9);
+}
+
+vector unsigned char c21 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned char c30 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned char mc0 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned char mc9 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 9);
+}
+
+vector unsigned char mc21 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned char mc30 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned char ci (vector unsigned char v, int i, unsigned char x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned char mci (vector unsigned char *vp, int i, unsigned char x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,
+			      CONST4, CONST5, CONST6, CONST7,
+			      CONST8, CONST9, CONSTA, CONSTB,
+			      CONSTC, CONSTD, CONSTE, CONSTF };
+  printf ("A\n");
+  cv = c0 (cv, CONST3);
+  if (cv [0] != CONST3)
+    abort ();
+
+  printf ("B\n");
+  cv = c9 (cv, CONST2);
+  if (cv [9] != CONST2)
+    abort ();
+
+  printf ("C\n");
+  cv = c21 (cv, CONSTF);
+  if (cv [5] != CONSTF)
+    abort ();
+
+  printf ("D\n");
+  cv = c30 (cv, CONST3);
+  if (cv [14] != CONST3)
+    abort ();
+
+  printf ("E\n");
+  cv = mc0 (&cv, CONST4);
+  if (cv [0] != CONST4)
+    abort ();
+
+  printf ("F\n");
+  cv = mc9 (&cv, CONST3);
+  if (cv [9] != CONST3)
+    abort ();
+
+  printf ("G\n");
+  cv = mc21 (&cv, CONST1);
+  if (cv [5] != CONST1)
+    abort ();
+
+  printf ("H\n");
+  cv = mc30 (&cv, CONSTC);
+  if (cv [14] != CONSTC)
+    abort ();
+
+  printf ("I\n");
+  cv = ci (cv, 8, CONSTD);
+  if (cv [8] != CONSTD)
+    abort ();
+
+  printf ("J\n");
+  cv = ci (cv, 13, CONST5);
+  if (cv [13] != CONST5)
+    abort ();
+
+  printf ("K\n");
+  cv = ci (cv, 23, CONST6);
+  if (cv [7] != CONST6)
+    abort ();
+
+  printf ("L\n");
+  cv = ci (cv, 31, CONST7);
+  if (cv [15] != CONST7)
+    abort ();
+
+  printf ("M\n");
+  cv = mci (&cv, 5, CONST8);
+  if (cv [5] != CONST8)
+    abort ();
+
+  printf ("N\n");
+  cv = mci (&cv, 12, CONST9);
+  if (cv [12] != CONST9)
+    abort ();
+
+  printf ("O\n");
+  cv = mci (&cv, 25, CONSTA);
+  if (cv [9] != CONSTA)
+    abort ();
+
+  printf ("P\n");
+  cv = mci (&cv, 16, CONSTB);
+  if (cv [0] != CONSTB)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-17b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17b.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17b.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned short s3 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+unsigned short s7 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 7);
+}
+
+unsigned short s21 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned short s30 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned short ms3 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+unsigned short ms7 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 7);
+}
+
+unsigned short ms21 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned short ms30 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned short ci (vector unsigned short v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned short mci (vector unsigned short *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+int main (int argc, unsigned short *argv[]) {
+  vector unsigned short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  unsigned short s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s7 (sv);
+  if (s != CONST7)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST5)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms7 (&sv);
+  if (s != CONST7)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST5)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST7)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-18a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18a.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18a.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Unsigned Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned int s3 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+unsigned int s1 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 1);
+}
+
+unsigned int s21 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned int s30 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned int ms3 (vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+unsigned int ms1(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 1);
+}
+
+unsigned int ms21(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned int ms30(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned int ci (vector unsigned int v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned int mci(vector unsigned int *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+unsigned int main (int argc, unsigned char *argv[]) {
+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };
+  unsigned int s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s1 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms1 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST3)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr87532-mc.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr87532-mc.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr87532-mc.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,258 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O2" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <stdlib.h>
+#include <stddef.h>
+#include <altivec.h>
+
+#include <stdio.h>
+
+static vector unsigned __int128
+deoptimize_uint128 (vector unsigned __int128  a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned long long int
+deoptimize_ulong (vector unsigned long long int a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned int
+deoptimize_uint (vector unsigned int a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned char
+deoptimize_uchar (vector unsigned char a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned short
+deoptimize_ushort (vector unsigned short a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+__attribute ((noinline)) unsigned __int128
+get_auto_n_uint128 (vector unsigned __int128 a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+__attribute ((noinline)) unsigned long long int
+get_auto_n_ulong (vector unsigned long long int a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned int get_auto_n_uint (vector unsigned int a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned char get_auto_n_uchar (vector unsigned char a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned short get_auto_n_ushort (vector unsigned short a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+
+int check_uint128_element (int i, unsigned __int128 entry)
+{
+  printf ("checking uint128 entry at index %d\n", i);
+
+  return (entry == ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)
+		    | 0x0706050403020100ULL));
+}
+
+int check_ulong_element (int i, unsigned long long int entry)
+{
+  printf ("checking ulong entry 0x%llx at index %d\n", entry, i);
+
+  switch (i % 2)
+    {
+      case 0: return (entry == 0x9999901010ULL);
+      case 1: return (entry == 0x7777733333ULL);
+      default:
+	return 0;
+    }
+}
+
+int check_uint_element (int i, unsigned int entry)
+{
+  printf ("checking uint entry 0x%x at index %d\n", entry, i);
+
+  switch (i % 4)
+    {
+    case 0: return (entry == 0x99999);
+    case 1: return (entry == 0x01010);
+    case 2: return (entry == 0x77777);
+    case 3: return (entry == 0x33333);
+    default:
+      return 0;
+    }
+}
+
+int check_uchar_element (int i, unsigned char entry)
+{
+  printf ("checking uchar entry 0x%x at index %d\n", entry, i);
+  switch (i % 16)
+    {
+    case 0: return (entry == 0x90);
+    case 1: return (entry == 0x80);
+    case 2: return (entry == 0x70);
+    case 3: return (entry == 0x60);
+    case 4: return (entry == 0x50);
+    case 5: return (entry == 0x40);
+    case 6: return (entry == 0x30);
+    case 7: return (entry == 0x20);
+    case 8: return (entry == 0x10);
+    case 9: return (entry == 0xf0);
+    case 10: return (entry == 0xe0);
+    case 11: return (entry == 0xd0);
+    case 12: return (entry == 0xc0);
+    case 13: return (entry == 0xb0);
+    case 14: return (entry == 0xa0);
+    case 15: return (entry == 0xff);
+    default:
+      return 0;
+    }
+}
+
+int check_ushort_element (int i, unsigned short entry)
+{
+  printf ("checking ushort entry 0x%x at index %d\n", entry, i);
+  switch (i % 8)
+    {
+    case 0: return (entry == 0x9988);
+    case 1: return (entry == 0x8877);
+    case 2: return (entry == 0x7766);
+    case 3: return (entry == 0x6655);
+    case 4: return (entry == 0x5544);
+    case 5: return (entry == 0x4433);
+    case 6: return (entry == 0x3322);
+    case 7: return (entry == 0x2211);
+    default:
+      return 0;
+    }
+}
+
+void do_auto_uint128 ( vector unsigned __int128 a )
+{
+  int i;
+  unsigned __int128 c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uint128 (a,i);
+      if (!check_uint128_element (i, c)) abort ();
+    }
+ }
+
+void do_auto_ulong ( vector unsigned long long int a )
+{
+  int i;
+  unsigned long long int c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_ulong (a,i);
+      if (!check_ulong_element (i, c)) abort ();
+    }
+ }
+
+void do_auto_uint ( vector unsigned int a )
+{
+  int i;
+  unsigned int c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uint (a,i);
+      if (!check_uint_element (i, c)) abort ();
+    }
+ }
+
+void do_auto_ushort ( vector unsigned short a )
+{
+  int i;
+  unsigned short c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_ushort (a,i);
+      if (!check_ushort_element (i, c)) abort ();
+    }
+}
+
+void do_auto_uchar ( vector unsigned char a )
+{
+  int i;
+  unsigned char c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uchar (a,i);
+      if (!check_uchar_element (i, c)) abort ();
+    }
+}
+
+int
+main (void)
+{
+  size_t i;
+
+  vector unsigned __int128 u = {
+    ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)
+     | 0x0706050403020100ULL) };
+  vector unsigned __int128 du;
+
+  vector unsigned long long int v = { 0x9999901010ULL, 0x7777733333ULL };
+  vector unsigned long long int dv;
+
+  vector unsigned int x = { 0x99999, 0x01010, 0x77777, 0x33333 };
+  vector unsigned int dx;
+
+  vector unsigned char y = { 0x90, 0x80, 0x70, 0x60, 0x50, 0x40, 0x30, 0x20,
+			     0x10, 0xf0, 0xe0, 0xd0, 0xc0, 0xb0, 0xa0, 0xff };
+  vector unsigned char dy;
+
+  vector unsigned short z = { 0x9988, 0x8877, 0x7766, 0x6655,
+			      0x5544, 0x4433, 0x3322, 0x2211 };
+  vector unsigned short dz;
+
+  do_auto_uint128 (u);
+  do_auto_ulong (v);
+  do_auto_uint (x);
+  do_auto_uchar (y);
+  do_auto_ushort (z);
+
+  du = deoptimize_uint128 (u);
+  dv = deoptimize_ulong (v);
+  dx = deoptimize_uint (x);
+  dy = deoptimize_uchar (y);
+  dz = deoptimize_ushort (z);
+
+  do_auto_uint128 (du);
+  do_auto_ulong (dv);
+  do_auto_uint (dx);
+  do_auto_uchar (dy);
+  do_auto_ushort (dz);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/ppc-fortran/ppc-fortran.exp
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/ppc-fortran/ppc-fortran.exp	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/ppc-fortran/ppc-fortran.exp	(.../branches/gcc-8-branch)
@@ -36,7 +36,7 @@
     global gfortran_test_path
     global gfortran_aux_module_flags
     if { [llength $args] != 2 } {
-	error "dg-set-target-env-var: needs one argument"
+	error "dg-compile-aux-modules: needs one argument"
 	return
     }
 
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-17d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17d.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17d.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,154 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned short s3 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector unsigned short s7 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector unsigned short s21 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned short s30 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned short ms3 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector unsigned short ms7 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 7);
+}
+
+vector unsigned short ms21 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned short ms30 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned short ci (vector unsigned short v, int i, unsigned short x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned short mci (vector unsigned short *vp, int i, unsigned short x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, unsigned short *argv[]) {
+  vector unsigned short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+
+  sv = s3 (sv, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = s7 (sv, CONST2);
+  if (sv [7] != CONST2)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST4);
+  if (sv [6] != CONST4)
+    abort ();
+
+  sv = ms3 (&sv, CONST5);
+  if (sv [3] != CONST5)
+    abort ();
+
+  sv = ms7 (&sv, CONST6);
+  if (sv [7] != CONST6)
+    abort ();
+
+  sv = ms21 (&sv, CONST7);
+  if (sv [5] != CONST7)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [6] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST1);
+  if (sv [5] != CONST1)
+    abort ();
+
+  sv = ci (sv, 2, CONST3);
+  if (sv [2] != CONST3)
+    abort ();
+
+  sv = ci (sv, 15, CONST2);
+  if (sv [7] != CONST2)
+    abort ();
+
+  sv = ci (sv, 28, CONST5);
+  if (sv [4] != CONST5)
+    abort ();
+
+  sv = mci (&sv, 5, CONST4);
+  if (sv [5] != CONST4)
+    abort ();
+
+  sv = mci (&sv, 12, CONST6);
+  if (sv [4] != CONST6)
+    abort ();
+
+  sv = mci (&sv, 25, CONST7);
+  if (sv [1] != CONST7)
+    abort ();
+
+  sv = mci (&sv, 16, CONST4);
+  if (sv [0] != CONST4)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr89424-0.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr89424-0.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr89424-0.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,76 @@
+/* { dg-do run { target { powerpc*-*-* && lp64 } } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+/* Define PR89626 after that pr is addressed.  */
+#ifdef PR89626
+#define SIGNED
+#else
+#define SIGNED signed
+#endif
+
+#define CONST0		(((__int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+__int128 ei (vector SIGNED __int128 v, int i)
+{
+  return __builtin_vec_ext_v1ti (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__int128 mei (vector SIGNED __int128 *vp, int i)
+{
+  return __builtin_vec_ext_v1ti (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  __int128 d;
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-18c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18c.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18c.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,148 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Unsigned Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned int s3 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector unsigned int s1 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector unsigned int s21 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned int s30 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned int ms3 (vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector unsigned int ms1(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector unsigned int ms21(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned int ms30(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned int ci (vector unsigned int v, int i, unsigned int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned int mci(vector unsigned int *vp, int i, unsigned int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, unsigned char *argv[]) {
+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };
+
+  sv = s3 (sv, CONST2);
+  if (sv [3] != CONST2)
+    abort ();
+
+  sv = s1 (sv, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST1);
+  if (sv [2] != CONST1)
+    abort ();
+
+  sv = ms3 (&sv, CONST0);
+  if (sv [3] != CONST0)
+    abort ();
+
+  sv = ms1 (&sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ms21 (&sv, CONST1);
+  if (sv [1] != CONST1)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = ci (sv, 2, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 15, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = mci (&sv, 12, CONST2);
+  if (sv [0] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 25, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 16, CONST1);
+  if (sv [0] != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-19b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19b.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19b.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,109 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned long long int e0 (vector unsigned long long int v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned long long int e3 (vector unsigned long long int v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+unsigned long long int me0 (vector unsigned long long int *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned long long int me3 (vector unsigned long long int *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned long long int ei (vector unsigned long long int v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+unsigned long long int mei (vector unsigned long long int *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned long long int dv = { CONST0, CONST1 };
+  unsigned long long int d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-19d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19d.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19d.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,122 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+#define CONST2		(3 * 31415926539LL)
+#define CONST3		(4 * 31415926539LL)
+#define CONST4		(5 * 31415926539LL)
+#define CONST5		(6 * 31415926539LL)
+#define CONST6		(7 * 31415926539LL)
+#define CONST7		(8 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned long long int
+e0 (vector unsigned long long int v, unsigned long long int x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned long long int
+e3 (vector unsigned long long int v, unsigned long long int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned long long int
+me0 (vector unsigned long long int *vp, unsigned long long int x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned long long int
+me3 (vector unsigned long long int *vp, unsigned long long int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned long long int
+ei (vector unsigned long long int v, int i, unsigned long long int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned long long int
+mei (vector unsigned long long int *vp, int i, unsigned long long int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned long long int dv = { CONST0, CONST1 };
+  unsigned long long int d;
+
+  dv = e0 (dv, CONST7);
+  if (dv [0] != CONST7)
+    abort ();
+
+  dv = e3 (dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = me0 (&dv, CONST4);
+  if (dv [0] != CONST4)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST5);
+  if (dv [0] != CONST5)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST6);
+  if (dv [1] != CONST6)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-10b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10b.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10b.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+short s3 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 3);
+}
+
+short s7 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 7);
+}
+
+short s21 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 21);
+}
+
+short s30 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+short ms3 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 3);
+}
+
+short ms7 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 7);
+}
+
+short ms21 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 21);
+}
+
+short ms30 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+short ci (vector short v, int i)
+{
+  return __builtin_vec_ext_v8hi (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+short mci (vector short *vp, int i)
+{
+  return __builtin_vec_ext_v8hi (*vp, i);
+}
+
+
+int main (int argc, short *argv[]) {
+  vector short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  short s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s7 (sv);
+  if (s != CONST7)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST5)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms7 (&sv);
+  if (s != CONST7)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST5)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST7)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-11a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11a.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11a.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+int s3 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 3);
+}
+
+int s1 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 1);
+}
+
+int s21 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 21);
+}
+
+int s30 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+int ms3 (vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 3);
+}
+
+int ms1(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 1);
+}
+
+int ms21(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 21);
+}
+
+int ms30(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+int ci (vector int v, int i)
+{
+  return __builtin_vec_ext_v4si (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+int mci(vector int *vp, int i)
+{
+  return __builtin_vec_ext_v4si (*vp, i);
+}
+
+
+int main (int argc, int *argv[]) {
+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };
+  int s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s1 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms1 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST3)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-9a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9a.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9a.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,164 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+signed char c0 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 0);
+}
+
+signed char c9 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 9);
+}
+
+signed char c21 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 21);
+}
+
+signed char c30 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+signed char mc0 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 0);
+}
+
+signed char mc9 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 9);
+}
+
+signed char mc21 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 21);
+}
+
+signed char mc30 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+signed char ci (vector signed char v, int i)
+{
+  return __builtin_vec_ext_v16qi (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+signed char mci(vector signed char *vp, int i) {
+  return __builtin_vec_ext_v16qi (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  signed char c;
+
+  c = c0 (cv);
+  if (c != CONST0)
+    abort ();
+
+  c = c9 (cv);
+  if (c != CONST9)
+    abort ();
+
+  c = c21 (cv);
+  if (c != CONST5)
+    abort ();
+
+  c = c30 (cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = mc0 (&cv);
+  if (c != CONST0)
+    abort ();
+
+  c = mc9 (&cv);
+  if (c != CONST9)
+    abort ();
+
+  c = mc21 (&cv);
+  if (c != CONST5)
+    abort ();
+
+  c = mc30 (&cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = ci (cv, 8);
+  if (c != CONST8)
+    abort ();
+
+  c = ci (cv, 13);
+  if (c != CONSTD)
+    abort ();
+
+  c = ci (cv, 23);
+  if (c != CONST7)
+    abort ();
+
+  c = ci (cv, 31);
+  if (c != CONSTF)
+    abort ();
+
+  c = mci (&cv, 5);
+  if (c != CONST5)
+    abort ();
+
+  c = mci (&cv, 12);
+  if (c != CONSTC)
+    abort ();
+
+  c = mci (&cv, 25);
+  if (c != CONST9)
+    abort ();
+
+  c = mci (&cv, 16);
+  if (c != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c	(.../branches/gcc-8-branch)
@@ -4,6 +4,7 @@
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
 /* { dg-options "-mcpu=power8 -O2 -ftree-vectorize -fvect-cost-model=dynamic -fno-unroll-loops -fno-unroll-all-loops" } */
 
+#include <altivec.h>
 typedef vector unsigned long long	crypto_t;
 typedef vector unsigned long long	v2di_t;
 typedef vector unsigned int		v4si_t;
@@ -10,31 +11,56 @@
 typedef vector unsigned short		v8hi_t;
 typedef vector unsigned char		v16qi_t;
 
-crypto_t crpyto1 (crypto_t a)
+crypto_t crypto1 (crypto_t a)
 {
   return __builtin_crypto_vsbox (a);
 }
 
+v16qi_t crypto1_be (v16qi_t a)
+{
+  return vec_sbox_be (a);
+}
+
 crypto_t crypto2 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vcipher (a, b);
 }
 
+v16qi_t crypto2_be (v16qi_t a, v16qi_t b)
+{
+  return vec_cipher_be (a, b);
+}
+
 crypto_t crypto3 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vcipherlast (a, b);
 }
 
+v16qi_t crypto3_be (v16qi_t a, v16qi_t b)
+{
+  return vec_cipherlast_be (a, b);
+}
+
 crypto_t crypto4 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vncipher (a, b);
 }
 
+v16qi_t crypto4_be (v16qi_t a, v16qi_t b)
+{
+  return vec_ncipher_be (a, b);
+}
+
 crypto_t crypto5 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vncipherlast (a, b);
 }
 
+v16qi_t crypto5_be (v16qi_t a, v16qi_t b)
+{
+  return vec_ncipherlast_be (a, b);
+}
+
 v16qi_t crypto6a (v16qi_t a, v16qi_t b, v16qi_t c)
 {
   return __builtin_crypto_vpermxor (a, b, c);
@@ -117,15 +143,15 @@
 
 /* Note space is used after the instruction so that vcipherlast does not match
    vcipher.  */
-/* { dg-final { scan-assembler-times "vcipher "      1 } } */
-/* { dg-final { scan-assembler-times "vcipherlast "  1 } } */
-/* { dg-final { scan-assembler-times "vncipher "     1 } } */
-/* { dg-final { scan-assembler-times "vncipherlast " 1 } } */
+/* { dg-final { scan-assembler-times "vcipher "      2 } } */
+/* { dg-final { scan-assembler-times "vcipherlast "  2 } } */
+/* { dg-final { scan-assembler-times "vncipher "     2 } } */
+/* { dg-final { scan-assembler-times "vncipherlast " 2 } } */
 /* { dg-final { scan-assembler-times "vpermxor "     4 } } */
 /* { dg-final { scan-assembler-times "vpmsumb "      2 } } */
 /* { dg-final { scan-assembler-times "vpmsumd "      2 } } */
 /* { dg-final { scan-assembler-times "vpmsumh "      2 } } */
 /* { dg-final { scan-assembler-times "vpmsumw "      2 } } */
-/* { dg-final { scan-assembler-times "vsbox "        1 } } */
+/* { dg-final { scan-assembler-times "vsbox "        2 } } */
 /* { dg-final { scan-assembler-times "vshasigmad "   2 } } */
 /* { dg-final { scan-assembler-times "vshasigmaw "   2 } } */
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-20b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20b.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20b.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+/* Define this after PR89424 is addressed.  */
+#define PR89424
+
+extern void abort (void);
+
+#define CONST0		(((unsigned __int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned __int128 e0 (vector unsigned __int128 v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned __int128 e3 (vector unsigned __int128 v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+unsigned __int128 me0 (vector unsigned __int128 *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned __int128 me3 (vector unsigned __int128 *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+#ifdef PR89424
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned __int128 ei (vector unsigned __int128 v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+unsigned __int128 mei (vector unsigned __int128 *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+#endif
+
+int main (int argc, char *argv[]) {
+  vector unsigned __int128 dv = { CONST0 };
+  unsigned __int128 d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST0)
+    abort ();
+
+#ifdef PR89424
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+#endif
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-10d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10d.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10d.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector short s3 (vector short v, short x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector short s7 (vector short v, short x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector short s21 (vector short v, short x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector short s30 (vector short v, short x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector short ms3 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector short ms7 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 7);
+}
+
+vector short ms21 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector short ms30 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector short ci (vector short v, int i, short x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector short mci (vector short *vp, int i, short x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, short *argv[]) {
+  vector short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  short s;
+
+  sv = s3 (sv, CONST6);
+  if (sv [3] != CONST6)
+    abort ();
+
+  sv = s7 (sv, CONST4);
+  if (sv [7] != CONST4)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST2);
+  if (sv [6] != CONST2)
+    abort ();
+
+  sv = ms3 (&sv, CONST5);
+  if (sv [3] != CONST5)
+    abort ();
+
+  sv = ms7 (&sv, CONST1);
+  if (sv [7] != CONST1)
+    abort ();
+
+  sv = ms21 (&sv, CONST2);
+  if (sv [5] != CONST2)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [6] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST6);
+  if (sv [5] != CONST6)
+    abort ();
+
+  sv = ci (sv, 2, CONST4);
+  if (sv [2] != CONST4)
+    abort ();
+
+  sv = ci (sv, 15, CONST3);
+  if (sv [7] != CONST3)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [4] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 12, CONST7);
+  if (sv [4] != CONST7)
+    abort ();
+
+  sv = mci (&sv, 25, CONST6);
+  if (sv [1] != CONST6)
+    abort ();
+
+  sv = mci (&sv, 16, CONST5);
+  if (sv [0] != CONST5)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-11c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11c.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11c.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector int s3 (vector int v, int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector int s1 (vector int v, int x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector int s21 (vector int v, int x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector int s30 (vector int v, int x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector int ms3  (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector int ms1 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector int ms21 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector int ms30 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector int ci (vector int v, int i, int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector int mci(vector int *vp, int i, int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, int *argv[]) {
+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };
+  int s;
+
+  sv = s3 (sv, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = s1 (sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = s21 (sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = s30 (sv, CONST1);
+  if (sv [2] != CONST1)
+    abort ();
+
+  sv = ms3 (&sv, CONST2);
+  if (sv [3] != CONST2)
+    abort ();
+
+  sv = ms1 (&sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ms21 (&sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ci (sv, 2, CONST3);
+  if (sv [2] != CONST3)
+    abort ();
+
+  sv = ci (sv, 15, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 12, CONST1);
+  if (sv [0] != CONST1)
+    abort ();
+
+  sv = mci (&sv, 25, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 16, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/mmx-psubd-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/mmx-psubd-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/mmx-psubd-2.c	(.../branches/gcc-8-branch)
@@ -23,20 +23,28 @@
   return _mm_sub_pi32 (s1, s2);
 }
 
+static __m64
+__attribute__((noinline, unused))
+test_alias (__m64 s1, __m64 s2)
+{
+  return _m_psubd (s1, s2);
+}
+
 static void
 TEST (void)
 {
   __m64_union u, s1, s2;
-  __m64_union e;
+  __m64_union e, v;
   int i;
    
   s1.as_m64 = _mm_setr_pi32 (30, 90);
   s2.as_m64 = _mm_setr_pi32 (76, -100);
   u.as_m64 = test (s1.as_m64, s2.as_m64);
-   
+  v.as_m64 = test_alias (s1.as_m64, s2.as_m64);
+
   for (i = 0; i < 2; i++)
      e.as_int[i] = s1.as_int[i] - s2.as_int[i];
 
-  if (u.as_m64 != e.as_m64)
+  if (u.as_m64 != e.as_m64 || u.as_m64 != v.as_m64)
     abort ();
 }
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-9c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9c.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9c.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,164 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector signed char c0 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector signed char c9 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 9);
+}
+
+vector signed char c21 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector signed char c30 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector signed char mc0 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector signed char mc9 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 9);
+}
+
+vector signed char mc21 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector signed char mc30 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector signed char ci (vector signed char v, int i, signed char x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector signed char mci(vector signed char *vp, int i, signed char x) {
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  signed char c;
+
+  cv = c0 (cv, CONSTF);
+  if (cv [0] != CONSTF)
+    abort ();
+
+  cv = c9 (cv, CONST7);
+  if (cv [9] != CONST7)
+    abort ();
+
+  cv = c21 (cv, CONSTA);
+  if (cv [5] != CONSTA)
+    abort ();
+
+  cv = c30 (cv, CONSTC);
+  if (cv [14] != CONSTC)
+    abort ();
+
+  cv = mc0 (&cv, CONSTB);
+  if (cv [0] != CONSTB)
+    abort ();
+
+  cv = mc9 (&cv, CONST1);
+  if (cv [9] != CONST1)
+    abort ();
+
+  cv = mc21 (&cv, CONST7);
+  if (cv [5] != CONST7)
+    abort ();
+
+  cv = mc30 (&cv, CONST2);
+  if (cv [14] != CONST2)
+    abort ();
+
+  cv = ci (cv, 8, CONST4);
+  if (cv [8] != CONST4)
+    abort ();
+
+  cv = ci (cv, 13, CONSTB);
+  if (cv [13] != CONSTB)
+    abort ();
+
+  cv = ci (cv, 23, CONST3);
+  if (cv [7] != CONST3)
+    abort ();
+
+  cv = ci (cv, 31, CONST2);
+  if (cv [15] != CONST2)
+    abort ();
+
+  cv = mci (&cv, 5, CONST1);
+  if (cv [5] != CONST1)
+    abort ();
+
+  cv = mci (&cv, 12, CONST3);
+  if (cv [12] != CONST3)
+    abort ();
+
+  cv = mci (&cv, 25, CONST5);
+  if (cv [9] != CONST5)
+    abort ();
+
+  cv = mci (&cv, 16, CONSTD);
+  if (cv [0] != CONSTD)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-12b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12b.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12b.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,109 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+long long int e0 (vector long long int v)
+{
+  return __builtin_vec_ext_v2di (v, 0);
+}
+
+long long int e3 (vector long long int v)
+{
+  return __builtin_vec_ext_v2di (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+long long int me0 (vector long long int *vp)
+{
+  return __builtin_vec_ext_v2di (*vp, 0);
+}
+
+long long int me3 (vector long long int *vp)
+{
+  return __builtin_vec_ext_v2di (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+long long int ei (vector long long int v, int i)
+{
+  return __builtin_vec_ext_v2di (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+long long int mei (vector long long int *vp, int i)
+{
+  return __builtin_vec_ext_v2di (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector long long int dv = { CONST0, CONST1 };
+  long long int d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-13a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13a.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13a.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,124 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+/* Define this after PR89424 is addressed.  */
+#define PR89424
+
+/* Define this after PR89626 is addressed.  */
+#undef PR89626
+
+#ifdef PR89626
+#define SIGNED
+#else
+#define SIGNED signed
+#endif
+
+extern void abort (void);
+
+#define CONST0		(((SIGNED __int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+SIGNED __int128 e0 (vector SIGNED __int128 v)
+{
+  return __builtin_vec_ext_v1ti (v, 0);
+}
+
+SIGNED __int128 e3 (vector SIGNED __int128 v)
+{
+  return __builtin_vec_ext_v1ti (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+SIGNED __int128 me0 (vector SIGNED __int128 *vp)
+{
+  return __builtin_vec_ext_v1ti (*vp, 0);
+}
+
+SIGNED __int128 me3 (vector SIGNED __int128 *vp)
+{
+  return __builtin_vec_ext_v1ti (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+#ifdef PR89424
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+SIGNED __int128 ei (vector SIGNED __int128 v, int i)
+{
+  return __builtin_vec_ext_v1ti (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+SIGNED __int128 mei (vector SIGNED __int128 *vp, int i)
+{
+  return __builtin_vec_ext_v1ti (*vp, i);
+}
+#endif
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  SIGNED __int128 d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST0)
+    abort ();
+
+#ifdef PR89424
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+#endif
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-20d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20d.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20d.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(((unsigned __int128) 31415926539) << 60)
+#define CONST1		(((unsigned __int128) 31415926539) << 54)
+#define CONST2		(((unsigned __int128) 31415926539) << 48)
+#define CONST3		(((unsigned __int128) 31415926539) << 32)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned __int128 e0 (vector unsigned __int128 v, unsigned __int128 x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned __int128 e3 (vector unsigned __int128 v, unsigned __int128 x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned __int128
+me0 (vector unsigned __int128 *vp, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned __int128
+me3 (vector unsigned __int128 *vp, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned __int128
+ei (vector unsigned __int128 v, int i, unsigned __int128 x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned __int128
+mei (vector unsigned __int128 *vp, int i, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned __int128 dv = { CONST0 };
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me0 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST0);
+  if (dv [0] != CONST0)
+    abort ();
+
+  dv = ei (dv, 1, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = ei (dv, 3, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 0, CONST0);
+  if (dv [0] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 1, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 3, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-12d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12d.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12d.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,112 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+#define CONST2		(3 * 31415926539LL)
+#define CONST3		(4 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector long long int e0 (vector long long int v, long long int x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector long long int e3 (vector long long int v, long long int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector long long int me0 (vector long long int *vp, long long int x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector long long int me3 (vector long long int *vp, long long int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector long long int ei (vector long long int v, int i, long long int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector long long int mei (vector long long int *vp, int i, long long int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector long long int dv = { CONST0, CONST1 };
+  long long int d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = me0 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 0, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 3, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-13c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13c.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13c.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+#define SIGNED signed
+
+extern void abort (void);
+
+#define CONST0		(((SIGNED __int128) 31415926539) << 60)
+#define CONST1		(((SIGNED __int128) 31415926539) << 55)
+#define CONST2		(((SIGNED __int128) 31415926539) << 50)
+#define CONST3		(((SIGNED __int128) 31415926539) << 45)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector SIGNED __int128 e0 (vector SIGNED __int128 v, SIGNED __int128 x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector SIGNED __int128 e3 (vector SIGNED __int128 v, SIGNED __int128 x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector SIGNED __int128 me0 (vector SIGNED __int128 *vp, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector SIGNED __int128 me3 (vector SIGNED __int128 *vp, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector SIGNED __int128
+ei (vector SIGNED __int128 v, int i, SIGNED __int128 x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector SIGNED __int128
+mei (vector SIGNED __int128 *vp, int i, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  SIGNED __int128 d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 0, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 1, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-14b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14b.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14b.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,126 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		((float) (3.1415926539))
+#define CONST1		((float) (3.1415926539 * 2))
+#define CONST2		((float) (3.1415926539 * 3))
+#define CONST3		((float) (3.1415926539 * 4))
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+float e0(vector float v){ return __builtin_vec_ext_v4sf (v, 0); }
+float e1(vector float v){ return __builtin_vec_ext_v4sf (v, 1); }
+float e7(vector float v){ return __builtin_vec_ext_v4sf (v, 7); }
+float e8(vector float v){ return __builtin_vec_ext_v4sf (v, 8); }
+
+/* Test for vector residing in memory.  */
+float me0(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 0); }
+float me1(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 1); }
+
+float me13(vector float *vp)
+{
+  return __builtin_vec_ext_v4sf (*vp, 13);
+}
+
+float me15(vector float *vp)
+{
+  return __builtin_vec_ext_v4sf (*vp, 15);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+float ei(vector float v, int i)
+{
+  return __builtin_vec_ext_v4sf (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+float mei(vector float *vp, int i)
+{
+  return __builtin_vec_ext_v4sf (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };
+  float d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e1 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = e7 (dv);
+  if (d != CONST3)
+    abort ();
+
+  d = e8 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me1 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me13 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me15 (&dv);
+  if (d != CONST3)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST2)
+    abort ();
+
+  d = ei (dv, 11);
+  if (d != CONST3)
+    abort ();
+
+  d = ei (dv, 17);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 15);
+  if (d != CONST3)
+    abort ();
+
+  d = mei (&dv, 6);
+  if (d != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-15a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15a.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15a.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,113 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(3.1415926539)
+#define CONST1		(3.1415926539 * 2)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+double e0(vector double v){ return __builtin_vec_ext_v2df (v, 0); }
+double e1(vector double v){ return __builtin_vec_ext_v2df (v, 1); }
+double e2(vector double v){ return __builtin_vec_ext_v2df (v, 2); }
+double e3(vector double v){ return __builtin_vec_ext_v2df (v, 3); }
+
+/* Test for vector residing in memory.  */
+double me0(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 0); }
+double me1(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 1); }
+double me2(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 2); }
+double me3(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 3); }
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+double ei(vector double v, int i){ return __builtin_vec_ext_v2df (v, i); }
+
+/* Test for variable selector and vector residing in memory.  */
+double mei(vector double *vp, int i){ return __builtin_vec_ext_v2df (*vp, i); }
+
+
+int main (int argc, char *argv[]) {
+  vector double dv;
+  double d;
+  dv[0] = CONST0;
+  dv[1] = CONST1;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e1 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = e2 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me1 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me2 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2b.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2b.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,14 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O2 -mvsx" } */
+
+#define TYPE unsigned char
+/* ELEMENTS is number of elements in a vector of TYPE.  */
+#define ELEMENTS 16
+#define INITIAL \
+  {  3, 2, 3, 4, 5, 6, 7, 8, 240, 241, 242, 243, 244, 245, 246, 247 }
+
+#define DO_TRACE
+#undef DISABLE_INLINE_OF_GET_AUTO_N
+
+#include "vec-extract-v16qiu-v2.h"
Index: gcc/testsuite/gcc.target/powerpc/pr87532.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr87532.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr87532.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,72 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <stdlib.h>
+#include <stddef.h>
+#include <altivec.h>
+#include <stdio.h>
+
+static void
+check (unsigned char, unsigned char) __attribute__((__noinline__));
+
+static __attribute__((altivec(vector__))) unsigned char
+deoptimize (__attribute__((altivec(vector__))) unsigned char)
+__attribute__((__noinline__));
+
+static __attribute__((altivec(vector__))) unsigned char
+deoptimize (__attribute__((altivec(vector__))) unsigned char a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+// Toggle this attribute inline/noinline to see pass/fail.
+// fails with the noinline attribute applied.
+__attribute__ ((__noinline__))
+unsigned char
+get_auto_n (__attribute__((altivec(vector__))) unsigned char a, size_t n)
+{
+  return (unsigned char) __builtin_vec_extract (a, n);
+}
+
+void
+do_auto (__attribute__((altivec(vector__))) unsigned char a)
+{
+  size_t i;
+  for (i = 1; i < 3 ; i++)
+  {
+    do
+      {
+	printf ("get_auto_n (a, %d) produces 0x0%x\n",
+		i, (int) get_auto_n (a, i));
+
+	if ((int) get_auto_n (a,i) > 250) abort();
+      } while (0);
+  }
+}
+
+int
+main (void)
+{
+  size_t i;
+  __attribute__((altivec(vector__))) unsigned char x =
+    { 3, 2, 3, 8, 5, 6, 7, 8, 240, 241, 242, 243, 244, 245, 246, 247 };
+  __attribute__((altivec(vector__))) unsigned char a;
+
+  printf (" first elements of x are: %d %d %d %d %d\n",
+	  x[0], x[1], x[2], x[3], x[4]);
+
+  a = deoptimize (x);
+
+  printf (" after deoptimization, first elements of a are: %d %d %d %d %d\n",
+	  a[0], a[1], a[2], a[3], a[4]);
+
+  do_auto (a);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-14d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14d.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14d.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		((float) (3.1415926539))
+#define CONST1		((float) (3.1415926539 * 2))
+#define CONST2		((float) (3.1415926539 * 3))
+#define CONST3		((float) (3.1415926539 * 4))
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector float e0(vector float v, float x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector float e1(vector float v, float x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector float e7(vector float v, float x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector float e8(vector float v, float x)
+{
+  return vec_insert (x, v, 8);
+}
+
+/* Test for vector residing in memory.  */
+vector float me0(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector float me1(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector float me13(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 13);
+}
+
+vector float me15(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 15);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector float ei(vector float v, int i, float x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector float mei(vector float *vp, int i, float x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };
+  float d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e1 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = e7 (dv, CONST2);
+  if (dv [3] != CONST2)
+    abort ();
+
+  dv = e8 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me1 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = me13 (&dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = me15 (&dv, CONST1);
+  if (dv [3] != CONST1)
+    abort ();
+
+  dv = ei (dv, 0, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 2, CONST1);
+  if (dv [2] != CONST1)
+    abort ();
+
+  dv = ei (dv, 11, CONST0);
+  if (dv [3] != CONST0)
+    abort ();
+
+  dv = ei (dv, 17, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 15, CONST1);
+  if (dv [3] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 6, CONST0);
+  if (dv [2] != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-15c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15c.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15c.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,151 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(3.1415926539)
+#define CONST1		(3.1415926539 * 2)
+#define CONST2		(3.1415926539 * 3)
+#define CONST3		(3.1415926539 * 4)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector double e0(vector double v, double x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector double e1(vector double v, double x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector double e2(vector double v, double x)
+{
+  return vec_insert (x, v, 2);
+}
+
+vector double e3(vector double v, double x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector double me0(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector double me1(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector double me2(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 2);
+}
+
+vector double me3(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector double ei(vector double v, int i, double x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector double mei(vector double *vp, int i, double x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector double dv;
+  double d;
+  dv[0] = CONST0;
+  dv[1] = CONST1;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e1 (dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = e2 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = e3 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me1 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = me2 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = ei (dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 3, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-16b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16b.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16b.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,165 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned char c0 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned char c9 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 9);
+}
+
+unsigned char c21 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned char c30 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned char mc0 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned char mc9 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 9);
+}
+
+unsigned char mc21 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned char mc30 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned char ci (vector unsigned char v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned char mci (vector unsigned char *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  unsigned char c;
+
+  c = c0 (cv);
+  if (c != CONST0)
+    abort ();
+
+  c = c9 (cv);
+  if (c != CONST9)
+    abort ();
+
+  c = c21 (cv);
+  if (c != CONST5)
+    abort ();
+
+  c = c30 (cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = mc0 (&cv);
+  if (c != CONST0)
+    abort ();
+
+  c = mc9 (&cv);
+  if (c != CONST9)
+    abort ();
+
+  c = mc21 (&cv);
+  if (c != CONST5)
+    abort ();
+
+  c = mc30 (&cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = ci (cv, 8);
+  if (c != CONST8)
+    abort ();
+
+  c = ci (cv, 13);
+  if (c != CONSTD)
+    abort ();
+
+  c = ci (cv, 23);
+  if (c != CONST7)
+    abort ();
+
+  c = ci (cv, 31);
+  if (c != CONSTF)
+    abort ();
+
+  c = mci (&cv, 5);
+  if (c != CONST5)
+    abort ();
+
+  c = mci (&cv, 12);
+  if (c != CONSTC)
+    abort ();
+
+  c = mci (&cv, 25);
+  if (c != CONST9)
+    abort ();
+
+  c = mci (&cv, 16);
+  if (c != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2.h
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2.h	(.../branches/gcc-8-branch)
@@ -0,0 +1,253 @@
+#include <stdlib.h>
+#include <stddef.h>
+#include <altivec.h>
+
+#ifndef RTYPE
+#define RTYPE TYPE
+#endif
+
+#ifdef DO_TRACE
+#include <stdio.h>
+
+#define TRACE(STRING, NUM)						\
+do									\
+  {									\
+    fprintf (stderr, "%s: %2d\n", STRING, (int) NUM);			\
+    fflush (stderr);							\
+  }									\
+while (0)
+
+#ifndef FAIL_FORMAT
+#define FAIL_FORMAT "%ld"
+#define FAIL_CAST(X) ((long)(X))
+#endif
+
+#define FAIL(EXP, GOT)							 \
+do									 \
+  {									 \
+    fprintf (stderr, "Expected: " FAIL_FORMAT ", got " FAIL_FORMAT "\n", \
+	     FAIL_CAST (EXP), FAIL_CAST (GOT));				 \
+    fflush (stderr);							 \
+    abort ();								 \
+  }									 \
+while (0)
+
+#else
+#define TRACE(STRING, NUM)
+#define FAIL(EXP, GOT) abort ()
+#endif
+
+static void
+check (RTYPE, RTYPE) __attribute__((__noinline__));
+
+static vector TYPE
+deoptimize (vector TYPE) __attribute__((__noinline__));
+
+static vector TYPE
+*deoptimize_ptr (vector TYPE *)	__attribute__((__noinline__));
+
+static void
+check (RTYPE expected, RTYPE got)
+{
+  if (expected != got)
+    FAIL (expected, got);
+}
+
+static vector TYPE
+deoptimize (vector TYPE a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector TYPE *
+deoptimize_ptr (vector TYPE *p)
+{
+  __asm__ (" # %0" : "+r" (p));
+  return p;
+}
+
+
+RTYPE
+get_auto_0 (vector TYPE a)
+{
+  TRACE ("get_auto_", 0);
+  return (RTYPE) vec_extract (a, 0);
+}
+
+RTYPE
+get_auto_1 (vector TYPE a)
+{
+  TRACE ("get_auto_", 1);
+  return (RTYPE) vec_extract (a, 1);
+}
+
+#if ELEMENTS >= 4
+RTYPE
+get_auto_2 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 2);
+}
+
+RTYPE
+get_auto_3 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 3);
+}
+
+#if ELEMENTS >= 8
+RTYPE
+get_auto_4 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 4);
+}
+
+RTYPE
+get_auto_5 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 5);
+}
+
+RTYPE
+get_auto_6 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 6);
+}
+
+RTYPE
+get_auto_7 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 7);
+}
+
+#if ELEMENTS >= 16
+RTYPE
+get_auto_8 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 8);
+}
+
+RTYPE
+get_auto_9 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 9);
+}
+
+RTYPE
+get_auto_10 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 10);
+}
+
+RTYPE
+get_auto_11 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 11);
+}
+
+RTYPE
+get_auto_12 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 12);
+}
+
+RTYPE
+get_auto_13 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 13);
+}
+
+RTYPE
+get_auto_14 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 14);
+}
+
+RTYPE
+get_auto_15 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 15);
+}
+
+#endif
+#endif
+#endif
+
+
+/* Tests for the normal case of vec_extract where the vector is in a register
+   and returning the result in a register as a return value.  */
+#ifdef DISABLE_INLINE_OF_GET_AUTO_N
+__attribute__ ((__noinline__))
+#else
+/* gcc issues warning: always_inline function might not be inlinable
+
+   __attribute__ ((__always_inline__))
+*/
+#endif
+RTYPE
+get_auto_n (vector TYPE a, ssize_t n)
+{
+  return (RTYPE) vec_extract (a, n);
+}
+
+typedef RTYPE (*auto_func_type) (vector TYPE);
+
+static auto_func_type get_auto_const[] = {
+  get_auto_0,
+  get_auto_1,
+#if ELEMENTS >= 4
+  get_auto_2,
+  get_auto_3,
+#if ELEMENTS >= 8
+  get_auto_4,
+  get_auto_5,
+  get_auto_6,
+  get_auto_7,
+#if ELEMENTS >= 16
+  get_auto_8,
+  get_auto_9,
+  get_auto_10,
+  get_auto_11,
+  get_auto_12,
+  get_auto_13,
+  get_auto_14,
+  get_auto_15,
+#endif
+#endif
+#endif
+};
+
+extern void do_auto (vector TYPE a) __attribute__((__noinline__));
+
+void
+do_auto (vector TYPE a)
+{
+  size_t i;
+
+  for (i = 1; i < 40; i += 3)
+    {
+      TRACE ("do_auto, i: ", i);
+      TRACE ("  get_auto_const[i] returns: ",
+	     (*get_auto_const [i % ELEMENTS]) (a));
+      TRACE ("  get_auto_n returns", get_auto_n (a, i));
+      check (get_auto_n (a, i), (*get_auto_const [i % ELEMENTS]) (a));
+    }
+}
+
+
+
+/* Main program to test all of the possibilities.  */
+int
+main (void)
+{
+  size_t i;
+  vector TYPE x = INITIAL;
+  vector TYPE *p, *p2, a, y;
+  vector TYPE z[2];
+
+  a = deoptimize (x);
+
+  do_auto (a);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-17a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17a.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17a.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned short s3 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+unsigned short s7 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 7);
+}
+
+unsigned short s21 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned short s30 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned short ms3 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+unsigned short ms7 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 7);
+}
+
+unsigned short ms21 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned short ms30 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned short ci (vector unsigned short v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned short mci (vector unsigned short *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+int main (int argc, unsigned short *argv[]) {
+  vector unsigned short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  unsigned short s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s7 (sv);
+  if (s != CONST7)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST5)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms7 (&sv);
+  if (s != CONST7)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST5)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST7)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-16d.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16d.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16d.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,163 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned char c0 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned char c9 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 9);
+}
+
+vector unsigned char c21 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned char c30 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned char mc0 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned char mc9 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 9);
+}
+
+vector unsigned char mc21 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned char mc30 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned char ci (vector unsigned char v, int i, unsigned char x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned char mci (vector unsigned char *vp, int i, unsigned char x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,
+			      CONST4, CONST5, CONST6, CONST7,
+			      CONST8, CONST9, CONSTA, CONSTB,
+			      CONSTC, CONSTD, CONSTE, CONSTF };
+  cv = c0 (cv, CONST3);
+  if (cv [0] != CONST3)
+    abort ();
+
+  cv = c9 (cv, CONST2);
+  if (cv [9] != CONST2)
+    abort ();
+
+  cv = c21 (cv, CONSTF);
+  if (cv [5] != CONSTF)
+    abort ();
+
+  cv = c30 (cv, CONST3);
+  if (cv [14] != CONST3)
+    abort ();
+
+  cv = mc0 (&cv, CONST4);
+  if (cv [0] != CONST4)
+    abort ();
+
+  cv = mc9 (&cv, CONST3);
+  if (cv [9] != CONST3)
+    abort ();
+
+  cv = mc21 (&cv, CONST1);
+  if (cv [5] != CONST1)
+    abort ();
+
+  cv = mc30 (&cv, CONSTC);
+  if (cv [14] != CONSTC)
+    abort ();
+
+  cv = ci (cv, 8, CONSTD);
+  if (cv [8] != CONSTD)
+    abort ();
+
+  cv = ci (cv, 13, CONST5);
+  if (cv [13] != CONST5)
+    abort ();
+
+  cv = ci (cv, 23, CONST6);
+  if (cv [7] != CONST6)
+    abort ();
+
+  cv = ci (cv, 31, CONST7);
+  if (cv [15] != CONST7)
+    abort ();
+
+  cv = mci (&cv, 5, CONST8);
+  if (cv [5] != CONST8)
+    abort ();
+
+  cv = mci (&cv, 12, CONST9);
+  if (cv [12] != CONST9)
+    abort ();
+
+  cv = mci (&cv, 25, CONSTA);
+  if (cv [9] != CONSTA)
+    abort ();
+
+  cv = mci (&cv, 16, CONSTB);
+  if (cv [0] != CONSTB)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr88100.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr88100.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr88100.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,44 @@
+/* PR88100.  Verify that rs6000 gimple-folding code handles the
+   vec_splat_{su}{8,16,32} invalid data properly. */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-maltivec" } */
+
+#include <altivec.h>
+
+vector unsigned char
+splatu1 (void)
+{
+  return vec_splat_u8(0x100);/* { dg-error "argument 1 must be a 5-bit signed literal" } */
+}
+
+vector unsigned short
+splatu2 (void)
+{
+  return vec_splat_u16(0x10000);/* { dg-error "argument 1 must be a 5-bit signed literal" } */
+}
+
+vector unsigned int
+splatu3 (void)
+{
+  return vec_splat_u32(0x10000000);/* { dg-error "argument 1 must be a 5-bit signed literal" } */
+}
+
+vector signed char
+splats1 (void)
+{
+  return vec_splat_s8(0x100);/* { dg-error "argument 1 must be a 5-bit signed literal" } */
+}
+
+vector signed short
+splats2 (void)
+{
+  return vec_splat_s16(0x10000);/* { dg-error "argument 1 must be a 5-bit signed literal" } */
+}
+
+vector signed int
+splats3 (void)
+{
+  return vec_splat_s32(0x10000000);/* { dg-error "argument 1 must be a 5-bit signed literal" } */
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-17c.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17c.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17c.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,154 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned short s3 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector unsigned short s7 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector unsigned short s21 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned short s30 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned short ms3 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector unsigned short ms7 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 7);
+}
+
+vector unsigned short ms21 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned short ms30 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned short ci (vector unsigned short v, int i, unsigned short x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned short mci (vector unsigned short *vp, int i, unsigned short x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, unsigned short *argv[]) {
+  vector unsigned short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+
+  sv = s3 (sv, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = s7 (sv, CONST2);
+  if (sv [7] != CONST2)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST4);
+  if (sv [6] != CONST4)
+    abort ();
+
+  sv = ms3 (&sv, CONST5);
+  if (sv [3] != CONST5)
+    abort ();
+
+  sv = ms7 (&sv, CONST6);
+  if (sv [7] != CONST6)
+    abort ();
+
+  sv = ms21 (&sv, CONST7);
+  if (sv [5] != CONST7)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [6] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST1);
+  if (sv [5] != CONST1)
+    abort ();
+
+  sv = ci (sv, 2, CONST3);
+  if (sv [2] != CONST3)
+    abort ();
+
+  sv = ci (sv, 15, CONST2);
+  if (sv [7] != CONST2)
+    abort ();
+
+  sv = ci (sv, 28, CONST5);
+  if (sv [4] != CONST5)
+    abort ();
+
+  sv = mci (&sv, 5, CONST4);
+  if (sv [5] != CONST4)
+    abort ();
+
+  sv = mci (&sv, 12, CONST6);
+  if (sv [4] != CONST6)
+    abort ();
+
+  sv = mci (&sv, 25, CONST7);
+  if (sv [1] != CONST7)
+    abort ();
+
+  sv = mci (&sv, 16, CONST4);
+  if (sv [0] != CONST4)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr89765-mc.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/pr89765-mc.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/pr89765-mc.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,400 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O2" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <stdlib.h>
+#include <stddef.h>
+#include <altivec.h>
+
+#include <stdio.h>
+
+static vector unsigned __int128
+deoptimize_uint128 (vector unsigned __int128  a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned long long int
+deoptimize_ulong (vector unsigned long long int a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned int
+deoptimize_uint (vector unsigned int a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned char
+deoptimize_uchar (vector unsigned char a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned short
+deoptimize_ushort (vector unsigned short a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+__attribute ((noinline))
+vector unsigned __int128
+set_auto_n_uint128 (vector unsigned __int128 a, int n, unsigned __int128 x)
+{
+  return vec_insert (x, a, n);
+}
+
+__attribute ((noinline))
+vector unsigned long long int
+set_auto_n_ulong (vector unsigned long long int a, int n,
+		  unsigned long long int x)
+{
+  return vec_insert (x, a, n);
+}
+
+__attribute ((noinline))
+vector unsigned int
+set_auto_n_uint (vector unsigned int a, int n, unsigned int x)
+{
+  return vec_insert (x, a, n);
+}
+
+__attribute ((noinline))
+vector unsigned char
+set_auto_n_uchar (vector unsigned char a, int n, unsigned char x)
+{
+  return vec_insert (x, a, n);
+}
+
+__attribute ((noinline))
+vector unsigned short
+set_auto_n_ushort (vector unsigned short a, int n, unsigned short x)
+{
+  return vec_insert (x, a, n);
+}
+
+__attribute ((noinline))
+unsigned __int128
+get_auto_n_uint128 (vector unsigned __int128 a, int n)
+{
+  return vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned long long int
+get_auto_n_ulong (vector unsigned long long int a, int n)
+{
+  return vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned int
+get_auto_n_uint (vector unsigned int a, int n)
+{
+  return vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned char
+get_auto_n_uchar (vector unsigned char a, int n)
+{
+  return vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned short
+get_auto_n_ushort (vector unsigned short a, int n)
+{
+  return vec_extract (a, n);
+}
+
+int check_uint128_element (int i, unsigned __int128 entry)
+{
+  printf ("checking uint128 entry at index %d\n", i);
+
+  return (entry == ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)
+		    | 0x0706050403020100ULL));
+}
+
+unsigned __int128 get_uint128_element (int i)
+{
+  return ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)
+	  | 0x0706050403020100ULL);
+}
+
+int check_ulong_element (int i, unsigned long long int entry)
+{
+  printf ("checking ulong entry 0x%llx at index %d\n", entry, i);
+
+  switch (i % 2)
+    {
+      case 0: return (entry == 0x9999901010ULL);
+      case 1: return (entry == 0x7777733333ULL);
+      default:
+	return 0;
+    }
+}
+
+unsigned long long int get_ulong_element (int i)
+{
+  switch (i % 2)
+    {
+    case 0: return 0x9999901010ULL;
+    case 1: return 0x7777733333ULL;
+    }
+}
+
+int check_uint_element (int i, unsigned int entry)
+{
+  printf ("checking uint entry 0x%x at index %d\n", entry, i);
+
+  switch (i % 4)
+    {
+    case 0: return (entry == 0x99999);
+    case 1: return (entry == 0x01010);
+    case 2: return (entry == 0x77777);
+    case 3: return (entry == 0x33333);
+    default:
+      return 0;
+    }
+}
+
+unsigned int get_uint_element (int i)
+{
+  switch (i % 4)
+    {
+    case 0: return 0x99999;
+    case 1: return 0x01010;
+    case 2: return 0x77777;
+    case 3: return 0x33333;
+    }
+}
+
+int check_uchar_element (int i, unsigned char entry)
+{
+  printf ("checking uchar entry 0x%x at index %d\n", entry, i);
+  switch (i % 16)
+    {
+    case 0: return (entry == 0x90);
+    case 1: return (entry == 0x80);
+    case 2: return (entry == 0x70);
+    case 3: return (entry == 0x60);
+    case 4: return (entry == 0x50);
+    case 5: return (entry == 0x40);
+    case 6: return (entry == 0x30);
+    case 7: return (entry == 0x20);
+    case 8: return (entry == 0x10);
+    case 9: return (entry == 0xf0);
+    case 10: return (entry == 0xe0);
+    case 11: return (entry == 0xd0);
+    case 12: return (entry == 0xc0);
+    case 13: return (entry == 0xb0);
+    case 14: return (entry == 0xa0);
+    case 15: return (entry == 0xff);
+    default:
+      return 0;
+    }
+}
+
+unsigned char get_uchar_element (int i)
+{
+  switch (i % 16)
+    {
+    case 0: return 0x90;
+    case 1: return 0x80;
+    case 2: return 0x70;
+    case 3: return 0x60;
+    case 4: return 0x50;
+    case 5: return 0x40;
+    case 6: return 0x30;
+    case 7: return 0x20;
+    case 8: return 0x10;
+    case 9: return 0xf0;
+    case 10: return 0xe0;
+    case 11: return 0xd0;
+    case 12: return 0xc0;
+    case 13: return 0xb0;
+    case 14: return 0xa0;
+    case 15: return 0xff;
+    }
+}
+
+int check_ushort_element (int i, unsigned short entry)
+{
+  printf ("checking ushort entry 0x%x at index %d\n", entry, i);
+  switch (i % 8)
+    {
+    case 0: return (entry == 0x9988);
+    case 1: return (entry == 0x8877);
+    case 2: return (entry == 0x7766);
+    case 3: return (entry == 0x6655);
+    case 4: return (entry == 0x5544);
+    case 5: return (entry == 0x4433);
+    case 6: return (entry == 0x3322);
+    case 7: return (entry == 0x2211);
+    default:
+      return 0;
+    }
+}
+
+unsigned short get_ushort_element (int i)
+{
+  switch (i % 8)
+    {
+    case 0: return 0x9988;
+    case 1: return 0x8877;
+    case 2: return 0x7766;
+    case 3: return 0x6655;
+    case 4: return 0x5544;
+    case 5: return 0x4433;
+    case 6: return 0x3322;
+    case 7: return 0x2211;
+    }
+}
+
+vector unsigned __int128
+init_auto_uint128 (vector unsigned __int128 a)
+{
+  int i;
+  for (i = 0; i < 32; i += 3)
+    a = set_auto_n_uint128 (a, i, get_uint128_element (i));
+  return a;
+}
+
+void do_auto_uint128 (vector unsigned __int128 a)
+{
+  int i;
+  unsigned __int128 c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uint128 (a, i);
+      if (!check_uint128_element (i, c)) abort ();
+    }
+}
+
+vector unsigned long long int
+init_auto_ulong (vector unsigned long long int a)
+{
+  int i;
+  for (i = 0; i < 32; i += 3)
+    a = set_auto_n_ulong (a, i, get_ulong_element (i));
+  return a;
+}
+
+void do_auto_ulong (vector unsigned long long int a)
+{
+  int i;
+  unsigned long long int c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_ulong (a, i);
+      if (!check_ulong_element (i, c)) abort ();
+    }
+ }
+
+vector unsigned int init_auto_uint (vector unsigned int a)
+{
+  int i;
+  for (i = 0; i < 32; i += 3)
+    a = set_auto_n_uint (a, i, get_uint_element (i));
+  return a;
+}
+
+void do_auto_uint (vector unsigned int a)
+{
+  int i;
+  unsigned int c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uint (a, i);
+      if (!check_uint_element (i, c)) abort ();
+    }
+ }
+
+vector unsigned short init_auto_ushort ( vector unsigned short a )
+{
+  int i;
+  for (i = 0; i < 32; i += 3)
+    a = set_auto_n_ushort (a, i, get_ushort_element (i));
+  return a;
+}
+
+void do_auto_ushort (vector unsigned short a)
+{
+  int i;
+  unsigned short c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_ushort (a, i);
+      if (!check_ushort_element (i, c)) abort ();
+    }
+}
+
+vector unsigned char init_auto_uchar (vector unsigned char a)
+{
+  int i;
+  for (i = 0; i < 32; i += 3)
+    a = set_auto_n_uchar (a, i, get_uchar_element (i));
+  return a;
+}
+
+void do_auto_uchar (vector unsigned char a)
+{
+  int i;
+  unsigned char c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uchar (a, i);
+      if (!check_uchar_element (i, c)) abort ();
+    }
+}
+
+int
+main (void)
+{
+  size_t i;
+
+  vector unsigned __int128 u = { 0 };
+  vector unsigned __int128 du;
+
+  vector unsigned long long int v = { 0, 0 };
+  vector unsigned long long int dv;
+
+  vector unsigned int x = { 0, 0, 0, 0 };
+  vector unsigned int dx;
+
+  vector unsigned char y = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+  vector unsigned char dy;
+
+  vector unsigned short z = { 0, 0, 0, 0, 0, 0, 0, 0 };
+  vector unsigned short dz;
+
+  du = init_auto_uint128 (u);
+  dv = init_auto_ulong (v);
+  dx = init_auto_uint (x);
+  dy = init_auto_uchar (y);
+  dz = init_auto_ushort (z);
+
+  du = deoptimize_uint128 (du);
+  dv = deoptimize_ulong (dv);
+  dx = deoptimize_uint (dx);
+  dy = deoptimize_uchar (dy);
+  dz = deoptimize_ushort (dz);
+
+  do_auto_uint128 (du);
+  do_auto_ulong (dv);
+  do_auto_uint (dx);
+  do_auto_uchar (dy);
+  do_auto_ushort (dz);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-18b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18b.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18b.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Unsigned Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned int s3 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+unsigned int s1 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 1);
+}
+
+unsigned int s21 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned int s30 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned int ms3 (vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+unsigned int ms1(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 1);
+}
+
+unsigned int ms21(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned int ms30(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned int ci (vector unsigned int v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned int mci(vector unsigned int *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+unsigned int main (int argc, unsigned char *argv[]) {
+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };
+  unsigned int s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s1 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms1 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST3)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-19a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19a.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19a.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,109 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned long long int e0 (vector unsigned long long int v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned long long int e3 (vector unsigned long long int v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+unsigned long long int me0 (vector unsigned long long int *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned long long int me3 (vector unsigned long long int *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned long long int ei (vector unsigned long long int v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+unsigned long long int mei (vector unsigned long long int *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned long long int dv = { CONST0, CONST1 };
+  unsigned long long int d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/arm/pr89222.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr89222.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr89222.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,32 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void g (void);
+
+void f1 (int x)
+{
+  if (x != (int) g + 3)
+    return;
+  g();
+}
+
+void (*a2)(void);
+
+void f2 (void)
+{
+  a2 = &g + 3;
+}
+
+typedef void (*__sighandler_t)(int);
+void handler (int);
+
+void f3 (int x)
+{
+  __sighandler_t h = &handler;
+  if (h != (__sighandler_t) 2 && h != (__sighandler_t) 1)
+    h (x);
+}
+
+/* { dg-final { scan-assembler-times {add(?:s)?\tr[0-9]+, r[0-9]+, #3} 2 } } */
+/* { dg-final { scan-assembler-not {.word\tg\+3} } } */
+/* { dg-final { scan-assembler-not {.word\thandler-1} } } */
Index: gcc/testsuite/gcc.target/arm/f16_f64_conv_no_dp.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/f16_f64_conv_no_dp.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/arm/f16_f64_conv_no_dp.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_fp16_ok } */
+/* { dg-skip-if "do not override fpu" { *-*-* } { "-mfpu=*" } { "-mfpu=fpv5-sp-d16" } } */
+/* { dg-skip-if "do not disable fpu" { *-*-* } { "-mfloat-abi=soft" } { * } } */
+/* { dg-skip-if "do not override fp16-format" { *-*-* } { "-mfp16-format=*" } { "-mfp16-format=ieee" } } */
+/* { dg-options "-O1 -mfpu=fpv5-sp-d16 -mfloat-abi=hard -mfp16-format=ieee" } */
+
+__fp16 foo (double a)
+{
+  return a;
+}
+
+double bar (__fp16 a)
+{
+  return a;
+}
Index: gcc/testsuite/gcc.target/arm/pr89190.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr89190.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr89190.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_arch_v8m_base_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_arch_v8m_base } */
+
+long long a;
+int b, c;
+int d(int e, int f) { return e << f; }
+void g() {
+  long long h;
+  char i = d(b >= 7, 2);
+  c = i == 0 ?: 1 / i;
+  h = c && a ?: c + a;
+  b = h;
+}
Index: gcc/testsuite/gcc.target/alpha/pr86984.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/alpha/pr86984.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/alpha/pr86984.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,96 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wall -Wwrite-strings -Werror -fmerge-all-constants -fno-stack-protector -mieee -fdump-rtl-expand" } */
+
+struct expression {
+  unsigned long int num;
+};
+union YYSTYPE {
+  unsigned long int num;
+  struct expression *exp;
+};
+
+typedef union YYSTYPE YYSTYPE;
+
+struct expression * new_exp_0 (int);
+
+union yyalloc {
+  short yyss_alloc;
+};
+
+static const signed char yypact[] = {
+  -9, -9, -10, -10, -9, 8, 36, -10, 13, -10, -9, -9, -9, -9, -9, -9, -9, -10, 26, 41, 45, 18, -2, 14, -10, -9, 36 };
+static const unsigned char yydefact[] = {
+  0, 0, 12, 11, 0, 0, 2, 10, 0, 1, 0, 0, 0, 0, 0, 0, 0, 13, 0, 4, 5, 6, 7, 8, 9, 0, 3 };
+
+static const signed char yypgoto[3] = "\366\366\377";
+static const signed char yydefgoto[3] = "\377\005\006";
+
+static const unsigned char yytable[] = {
+  7, 1, 2, 8, 3, 4, 15, 16, 9, 18, 19, 20, 21, 22, 23, 24, 10, 11, 12, 13, 14, 15, 16, 16, 26, 14, 15, 16, 17, 10, 11, 12, 13, 14, 15, 16, 0, 0, 25, 10, 11, 12, 13, 14, 15, 16, 12, 13, 14, 15, 16, 13, 14, 15, 16 };
+
+static const signed char yycheck[] = {
+  1, 10, 11, 4, 13, 14, 8, 9, 0, 10, 11, 12, 13, 14, 15, 16, 3, 4, 5, 6, 7, 8, 9, 9, 25, 7, 8, 9, 15, 3, 4, 5, 6, 7, 8, 9, -1, -1, 12, 3, 4, 5, 6, 7, 8, 9, 5, 6, 7, 8, 9, 6, 7, 8, 9 };
+
+static const unsigned char yyr1[] = {
+  0, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18 };
+
+static const unsigned char yyr2[] = {
+  0, 2, 1, 5, 3, 3, 3, 3, 3, 3, 2, 1, 1, 3 };
+
+int __gettextparse (void)
+{
+  int yystate = 0;
+  short yyssa[200];
+  short *yyss = yyss;
+  short *yyssp = yyssa;
+  YYSTYPE yyvsa[200];
+  YYSTYPE *yyvsp = yyvsa;
+  enum { yystacksize = 200 };
+  int yylen = 0;
+  goto yysetstate;
+ yynewstate: yyssp++;
+ yysetstate: *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      long unsigned int yysize = yyssp - yyss + 1;
+      {
+	short *yyss1 = yyss;
+	union yyalloc *yyptr = (union yyalloc *) __builtin_malloc ((yystacksize * (sizeof (short) + sizeof (YYSTYPE)) + (sizeof (union yyalloc) - 1)));
+	if (!yyptr) return 0;
+	__builtin_memcpy (&yyptr->yyss_alloc, yyss, yysize * sizeof *(yyss));
+	yyss = &yyptr->yyss_alloc;
+	if (yyss1 != yyssa) __builtin_free (yyss1);
+      }
+      if (yyss + yystacksize - 1 <= yyssp)
+	return 0;
+    }
+
+  int yyn = yypact[yystate];
+  if (yyn == -10)
+    goto yydefault;
+
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    goto yyreduce;
+
+ yydefault: yyn = yydefact[yystate];
+ yyreduce: yylen = yyr2[yyn];
+
+  YYSTYPE yyval;
+  if (yyn == 12 && (yyval.exp = new_exp_0 (0)) != 0)
+    (yyval.exp)->num = (yyvsp[0].num);
+
+  (yyvsp -= yylen, yyssp -= yylen);
+  yyn = yyr1[yyn];
+  yystate = yypgoto[yyn - 16] + *yyssp;
+  if (0 <= yystate && yystate <= 54 && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - 16];
+
+  goto yynewstate;
+}
+
+/* { dg-final { scan-rtl-dump-not "const_int 230584300921" "expand" } } */
+/* { dg-final { scan-assembler-not "yypgoto\\+230584300921" } } */
Index: gcc/testsuite/gcc.target/s390/pr89775-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/pr89775-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/s390/pr89775-1.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,17 @@
+/* PR target/89775 */
+/* { dg-do run } */
+/* { dg-options "-O0 -fomit-frame-pointer" } */
+/* { dg-additional-sources "pr89775-2.c" } */
+
+register void *sp __asm ("15");
+
+__attribute__((noipa)) int
+foo (const char *a, const char *b)
+{
+  while (1)
+    {
+      char c = *a++;
+      if (c != *b++) return 0;
+      if (c == '\0') return 1;
+    }
+}
Index: gcc/testsuite/gcc.target/s390/pr89775-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/pr89775-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/s390/pr89775-2.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,25 @@
+/* PR target/89775 */
+/* { dg-do compile } */
+
+extern int foo (const char *, const char *);
+
+__attribute__((noipa)) void
+bar (const char *p)
+{
+  static const char *x;
+  if (!x)
+    x = p;
+  else if (p != x)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  char a[8] = "abcdefg";
+  bar (a);
+  if (foo (a, a) != 1)
+    __builtin_abort ();
+  bar (a);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/s390/zvector/vec-addc-u128.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/zvector/vec-addc-u128.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/s390/zvector/vec-addc-u128.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,10 @@
+/* { dg-do compile { target { s390*-*-* } } } */
+/* { dg-options "-O3 -mzarch -march=z13 -mzvector -fno-asynchronous-unwind-tables" } */
+
+#include <vecintrin.h>
+
+vector unsigned char test(void)
+{
+   vector unsigned char a = { 0 };
+   return __builtin_s390_vec_addc_u128 (a, a);
+}
Index: gcc/testsuite/gcc.target/s390/zvector/xl-xst-align-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/zvector/xl-xst-align-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/s390/zvector/xl-xst-align-1.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,45 @@
+/* { dg-do compile { target { s390*-*-* } } } */
+/* { dg-options "-O3 -mzarch -march=z14 -mzvector" } */
+
+#include <vecintrin.h>
+
+vector float
+foo (float *a)
+{
+  return vec_xl (0, a);
+}
+
+vector float
+bar (const float *a)
+{
+  return vec_xl (0, a);
+}
+
+void
+baz (float *f, vector float a)
+{
+  vec_xst (a, 0, f);
+}
+
+vector float
+foo2 (float *a)
+{
+  return vec_xlw4 (0, a);
+}
+
+vector float
+bar2 (const float *a)
+{
+  return vec_xlw4 (0, a);
+}
+
+void
+baz2 (float *f, vector float a)
+{
+  vec_xstw4 (a, 0, f);
+}
+
+/* Make sure no alignment hints are generated.  */
+
+/* { dg-final { scan-assembler-not "vl.*,3" } } */
+/* { dg-final { scan-assembler-not "vst.*,3" } } */
Index: gcc/testsuite/gcc.target/s390/zvector/xl-xst-align-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/zvector/xl-xst-align-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/s390/zvector/xl-xst-align-2.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,48 @@
+/* { dg-do compile { target { s390*-*-* } } } */
+/* { dg-options "-O3 -mzarch -march=z14 -mzvector" } */
+
+#include <vecintrin.h>
+
+typedef float __attribute__((aligned(8))) float_aligned;
+
+vector float
+foo (float_aligned *a)
+{
+  return vec_xl (0, a);
+}
+
+vector float
+bar (const float_aligned *a)
+{
+  return vec_xl (0, a);
+}
+
+void
+baz (float_aligned *f, vector float a)
+{
+  vec_xst (a, 0, f);
+}
+
+vector float
+foo2 (float_aligned *a)
+{
+  return vec_xlw4 (0, a);
+}
+
+vector float
+bar2 (const float_aligned *a)
+{
+  return vec_xlw4 (0, a);
+}
+
+void
+baz2 (float_aligned *f, vector float a)
+{
+  vec_xstw4 (a, 0, f);
+}
+
+/* Make sure alignment hints are generated if the source or target
+   operand is properly aligned.  */
+
+/* { dg-final { scan-assembler-times "vl\t%v\[0-9\]*,0\\(%r2\\),3" 4 } } */
+/* { dg-final { scan-assembler-times "vst\t%v\[0-9\]*,0\\(%r2\\),3" 2 } } */
Index: gcc/testsuite/gcc.target/s390/vector/vec-shift-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/s390/vector/vec-shift-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/s390/vector/vec-shift-2.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,24 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -mzarch -march=z13 --save-temps" } */
+
+/* { dg-final { scan-assembler-times "veslf" 1 } } */
+
+typedef __attribute__((vector_size(16))) signed int v4si;
+
+v4si __attribute__((noinline,noclone))
+shift_left_by_scalar (v4si in, int shift_count)
+{
+  return in << (3 + shift_count);
+}
+
+int
+main ()
+{
+  v4si a = { 1, 2, 3, 4 };
+  v4si result = shift_left_by_scalar (a, 1);
+
+  if (result[1] != 32)
+    __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/mips/dwarfregtable-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/mips/dwarfregtable-3.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/mips/dwarfregtable-3.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,5 @@
+/* Check if content of dwarf reg size table matches the expected.  */
+/* { dg-do run } */
+/* { dg-options "-mabi=32 -mfp64" } */
+
+#include "dwarfregtable.h"
Index: gcc/testsuite/gcc.target/mips/dwarfregtable-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/mips/dwarfregtable-4.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/mips/dwarfregtable-4.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,5 @@
+/* Check if content of dwarf reg size table matches the expected.  */
+/* { dg-do run } */
+/* { dg-options "-mabi=32 -mfp64 -modd-spreg" } */
+
+#include "dwarfregtable.h"
Index: gcc/testsuite/gcc.target/mips/msa-fmadd-o32.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/mips/msa-fmadd-o32.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/mips/msa-fmadd-o32.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,101 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=32 -mfp64 -mhard-float -mmsa -EL -flax-vector-conversions" } */
+/* { dg-skip-if "uses global registers" { *-*-* } { "-O0" } { "" } } */
+
+typedef int v4i32 __attribute__ ((vector_size(16)));
+typedef float v4f32 __attribute__ ((vector_size(16)));
+typedef double v2f64 __attribute__ ((vector_size(16)));
+
+/* Test that MSA FMADD-like intrinsics do not use first operand for multiplication.  */
+
+register v4i32 a __asm__("$f20");
+register v4i32 b __asm__("$f22");
+register v4f32 c __asm__("$f24");
+register v4f32 d __asm__("$f26");
+register v2f64 e __asm__("$f28");
+register v2f64 f __asm__("$f30");
+
+void
+maddv_b_msa (void)
+{
+  a = __builtin_msa_maddv_b (a, b, b);
+}
+/* { dg-final { scan-assembler "maddv\\\.b\t\\\$w20,\\\$w22,\\\$w22" } }  */
+
+void
+maddv_h_msa (void)
+{
+  a = __builtin_msa_maddv_h (a, b, b);
+}
+/* { dg-final { scan-assembler "maddv\\\.h\t\\\$w20,\\\$w22,\\\$w22" } }  */
+
+void
+maddv_w_msa (void)
+{
+  a = __builtin_msa_maddv_w (a, b, b);
+}
+/* { dg-final { scan-assembler "maddv\\\.w\t\\\$w20,\\\$w22,\\\$w22" } }  */
+
+void
+maddv_d_msa (void)
+{
+  a = __builtin_msa_maddv_d (a, b, b);
+}
+/* { dg-final { scan-assembler "maddv\\\.d\t\\\$w20,\\\$w22,\\\$w22" } }  */
+
+void
+msubv_b_msa (void)
+{
+  a = __builtin_msa_msubv_b (a, b, b);
+}
+/* { dg-final { scan-assembler "msubv\\\.b\t\\\$w20,\\\$w22,\\\$w22" } }  */
+
+void
+msubv_h_msa (void)
+{
+  a = __builtin_msa_msubv_h (a, b, b);
+}
+/* { dg-final { scan-assembler "msubv\\\.h\t\\\$w20,\\\$w22,\\\$w22" } }  */
+
+void
+msubv_w_msa (void)
+{
+  a = __builtin_msa_msubv_w (a, b, b);
+}
+/* { dg-final { scan-assembler "msubv\\\.w\t\\\$w20,\\\$w22,\\\$w22" } }  */
+
+void
+msubv_d_msa (void)
+{
+  a = __builtin_msa_msubv_d (a, b, b);
+}
+/* { dg-final { scan-assembler "msubv\\\.d\t\\\$w20,\\\$w22,\\\$w22" } }  */
+
+void
+fmadd_w_msa (void)
+{
+  c = __builtin_msa_fmadd_w (c, d, d);
+}
+/* { dg-final { scan-assembler "fmadd\\\.w\t\\\$w24,\\\$w26,\\\$w26" } }  */
+
+void
+fmadd_d_msa (void)
+{
+  e = __builtin_msa_fmadd_d (e, f, f);
+}
+/* { dg-final { scan-assembler "fmadd\\\.d\t\\\$w28,\\\$w30,\\\$w30" } }  */
+
+void
+fmsub_w_msa (void)
+{
+  c = __builtin_msa_fmsub_w (c, d, d);
+}
+/* { dg-final { scan-assembler "fmsub\\\.w\t\\\$w24,\\\$w26,\\\$w26" } }  */
+
+void
+fmsub_d_msa (void)
+{
+  e = __builtin_msa_fmsub_d (e, f, f);
+}
+/* { dg-final { scan-assembler "fmsub\\\.d\t\\\$w28,\\\$w30,\\\$w30" } }  */
+
Index: gcc/testsuite/gcc.target/mips/msa-fmadd-n64.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/mips/msa-fmadd-n64.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/mips/msa-fmadd-n64.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,101 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=64 -mfp64 -mhard-float -mmsa -EL -flax-vector-conversions" } */
+/* { dg-skip-if "uses global registers" { *-*-* } { "-O0" } { "" } } */
+
+typedef int v4i32 __attribute__ ((vector_size(16)));
+typedef float v4f32 __attribute__ ((vector_size(16)));
+typedef double v2f64 __attribute__ ((vector_size(16)));
+
+/* Test that MSA FMADD-like intrinsics do not use first operand for multiplication.  */
+
+register v4i32 a __asm__("$f24");
+register v4i32 b __asm__("$f25");
+register v4f32 c __asm__("$f26");
+register v4f32 d __asm__("$f27");
+register v2f64 e __asm__("$f28");
+register v2f64 f __asm__("$f29");
+
+void
+maddv_b_msa (void)
+{
+  a = __builtin_msa_maddv_b (a, b, b);
+}
+/* { dg-final { scan-assembler "maddv\\\.b\t\\\$w24,\\\$w25,\\\$w25" } }  */
+
+void
+maddv_h_msa (void)
+{
+  a = __builtin_msa_maddv_h (a, b, b);
+}
+/* { dg-final { scan-assembler "maddv\\\.h\t\\\$w24,\\\$w25,\\\$w25" } }  */
+
+void
+maddv_w_msa (void)
+{
+  a = __builtin_msa_maddv_w (a, b, b);
+}
+/* { dg-final { scan-assembler "maddv\\\.w\t\\\$w24,\\\$w25,\\\$w25" } }  */
+
+void
+maddv_d_msa (void)
+{
+  a = __builtin_msa_maddv_d (a, b, b);
+}
+/* { dg-final { scan-assembler "maddv\\\.d\t\\\$w24,\\\$w25,\\\$w25" } }  */
+
+void
+msubv_b_msa (void)
+{
+  a = __builtin_msa_msubv_b (a, b, b);
+}
+/* { dg-final { scan-assembler "msubv\\\.b\t\\\$w24,\\\$w25,\\\$w25" } }  */
+
+void
+msubv_h_msa (void)
+{
+  a = __builtin_msa_msubv_h (a, b, b);
+}
+/* { dg-final { scan-assembler "msubv\\\.h\t\\\$w24,\\\$w25,\\\$w25" } }  */
+
+void
+msubv_w_msa (void)
+{
+  a = __builtin_msa_msubv_w (a, b, b);
+}
+/* { dg-final { scan-assembler "msubv\\\.w\t\\\$w24,\\\$w25,\\\$w25" } }  */
+
+void
+msubv_d_msa (void)
+{
+  a = __builtin_msa_msubv_d (a, b, b);
+}
+/* { dg-final { scan-assembler "msubv\\\.d\t\\\$w24,\\\$w25,\\\$w25" } }  */
+
+void
+fmadd_w_msa (void)
+{
+  c = __builtin_msa_fmadd_w (c, d, d);
+}
+/* { dg-final { scan-assembler "fmadd\\\.w\t\\\$w26,\\\$w27,\\\$w27" } }  */
+
+void
+fmadd_d_msa (void)
+{
+  e = __builtin_msa_fmadd_d (e, f, f);
+}
+/* { dg-final { scan-assembler "fmadd\\\.d\t\\\$w28,\\\$w29,\\\$w29" } }  */
+
+void
+fmsub_w_msa (void)
+{
+  c = __builtin_msa_fmsub_w (c, d, d);
+}
+/* { dg-final { scan-assembler "fmsub\\\.w\t\\\$w26,\\\$w27,\\\$w27" } }  */
+
+void
+fmsub_d_msa (void)
+{
+  e = __builtin_msa_fmsub_d (e, f, f);
+}
+/* { dg-final { scan-assembler "fmsub\\\.d\t\\\$w28,\\\$w29,\\\$w29" } }  */
+
Index: gcc/testsuite/gcc.target/mips/dwarfregtable-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/mips/dwarfregtable-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/mips/dwarfregtable-1.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,5 @@
+/* Check if content of dwarf reg size table matches the expected.  */
+/* { dg-do run } */
+/* { dg-options "-mabi=32 -mfp32" } */
+
+#include "dwarfregtable.h"
Index: gcc/testsuite/gcc.target/mips/dwarfregtable.h
===================================================================
--- a/src/gcc/testsuite/gcc.target/mips/dwarfregtable.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/mips/dwarfregtable.h	(.../branches/gcc-8-branch)
@@ -0,0 +1,22 @@
+
+typedef unsigned Unwind_Word __attribute__((__mode__(__unwind_word__)));
+
+#define DWARF_FRAME_REGISTERS 188
+
+static unsigned char ref_dwarf_reg_size_table[DWARF_FRAME_REGISTERS + 1] =
+  {
+    [0 ... 66] =  sizeof (Unwind_Word),
+    [80 ... 181] = sizeof (Unwind_Word)
+  };
+
+static unsigned char dwarf_reg_size_table[DWARF_FRAME_REGISTERS + 1] = {};
+
+int
+main (void)
+{
+  __builtin_init_dwarf_reg_size_table (dwarf_reg_size_table);
+  if (__builtin_memcmp (ref_dwarf_reg_size_table,
+                       dwarf_reg_size_table, DWARF_FRAME_REGISTERS + 1) != 0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/mips/dwarfregtable-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/mips/dwarfregtable-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/mips/dwarfregtable-2.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,5 @@
+/* Check if content of dwarf reg size table matches the expected.  */
+/* { dg-do run } */
+/* { dg-options "-mabi=32 -mfpxx" } */
+
+#include "dwarfregtable.h"
Index: gcc/testsuite/gcc.target/riscv/promote-type-for-libcall.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/riscv/promote-type-for-libcall.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/riscv/promote-type-for-libcall.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,37 @@
+/* { dg-do run } */
+/* { dg-options "-O1 -ftree-slp-vectorize -funroll-loops" } */
+
+#include <stdio.h>
+#include <stdlib.h>
+#define N 4
+volatile float f[N];
+int x[N] __attribute__((aligned(8)));
+int main() {
+  int i;
+  x[0] = -1;
+  x[1] = 2;
+  x[2] = -2;
+  x[3] = 2;
+
+  for (i=0;i<N;++i){
+    f[i] = x[i];
+  }
+
+  if (f[0] != -1.0f) {
+    abort();
+  }
+
+  if (f[1] != 2.0f) {
+    abort();
+  }
+
+  if (f[2] != -2.0f) {
+    abort();
+  }
+
+  if (f[3] != 2.0f) {
+    abort();
+  }
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/aarch64/options_set_9.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/options_set_9.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/options_set_9.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8-a+simd+fp" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\-a} 1 } } */
+
+ /* Check that grouping of bits that don't form a synthetic group don't turn
+    on the parent. e.g. rdma turns on simd+fp, but simd+fp does not turn on
+    rdma since rdma is it's own group.  crypto however turns on aes and sha2
+    and turning on sha2 and eas should turn on crypto!.  */
Index: gcc/testsuite/gcc.target/aarch64/options_set_1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/options_set_1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/options_set_1.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.2\-a\+crc} 1 } } */
+
+/* Check to see if crc is output by default.  */
Index: gcc/testsuite/gcc.target/aarch64/options_set_2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/options_set_2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/options_set_2.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+crypto" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.2\-a\+crypto\+crc} 1 } } */
+
+/* Check to see if crc and crypto are maintained if crypto specified.  */
Index: gcc/testsuite/gcc.target/aarch64/pr90075.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/pr90075.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/pr90075.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-O1" } */
+
+typedef struct {
+  float one, two;
+} twofloats;
+
+float
+bug (twofloats tf)
+{
+  float f1, f2;
+  union {
+    twofloats tfloats;
+    float arr[2];
+  } utfloats;
+
+  utfloats.tfloats = tf;
+  f1 = utfloats.arr[1];
+  f2 = __builtin_copysignf (0, f1);
+  return f2;
+}
Index: gcc/testsuite/gcc.target/aarch64/options_set_3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/options_set_3.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/options_set_3.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+aes+sha2+crypto" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.2\-a\+crypto\+crc} 1 } } */
+
+/* Check if smallest set is maintained when outputting. */
Index: gcc/testsuite/gcc.target/aarch64/options_set_4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/options_set_4.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/options_set_4.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+aes+sha2" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.2\-a\+crypto\+crc} 1 } } */
+
+/* Check if individual bits that make up a grouping is specified that only the
+   grouping is kept. */
\ No newline at end of file
Index: gcc/testsuite/gcc.target/aarch64/options_set_5.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/options_set_5.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/options_set_5.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+aes+sha2+nosha2" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.2\-a\+crc\+aes} 1 } } */
+
+/* Check if turning off feature bits works correctly and grouping is no
+   longer valid.   */
Index: gcc/testsuite/gcc.target/aarch64/options_set_10.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/options_set_10.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/options_set_10.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,11 @@
+/* { dg-do compile { target { { aarch64*-*-linux*} && native } } } */
+/* { dg-additional-options "-mcpu=native" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-not {\.arch .+\+profile.*} } } */
+
+ /* Check that an empty feature string is not detected during mcpu=native.  */
Index: gcc/testsuite/gcc.target/aarch64/options_set_6.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/options_set_6.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/options_set_6.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+crypto+nosha2" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.2\-a\+crypto\+crc} 1 } } */
+
+/* Group as a whole was requested to be turned on, crypto itself is a bit and so
+   just turning off one feature can't turn it off.   */
Index: gcc/testsuite/gcc.target/aarch64/options_set_7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/options_set_7.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/options_set_7.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.4-a+dotprod" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.4\-a} 1 } } */
+
+/* Checking if enabling default features drops the superfluous bits.   */
Index: gcc/testsuite/gcc.target/aarch64/options_set_8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/aarch64/options_set_8.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/aarch64/options_set_8.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.4-a+nodotprod" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.4\-a} 1 } } */
+
+/* Checking if trying to turn off default features propagates the commandline
+   option.  */
Index: gcc/testsuite/gcc.target/i386/pr70799-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr70799-5.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr70799-5.c	(.../branches/gcc-8-branch)
@@ -1,17 +0,0 @@
-/* PR target/pr70799 */
-/* { dg-do compile { target ia32 } } */
-/* { dg-options "-O2 -march=slm -mavx512vl -mno-stackrealign" } */
-/* { dg-final { scan-assembler "psllq" } } */
-/* { dg-final { scan-assembler "psraq" } } */
-
-long long a, b;
-
-void test1 (int c)
-{
-  a = b << c;
-}
-
-void test2 (int c)
-{
-  a = b >> c;
-}
Index: gcc/testsuite/gcc.target/i386/pr70799-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr70799-4.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr70799-4.c	(.../branches/gcc-8-branch)
@@ -1,17 +0,0 @@
-/* PR target/pr70799 */
-/* { dg-do compile { target ia32 } } */
-/* { dg-options "-O2 -march=slm -mno-stackrealign" } */
-/* { dg-final { scan-assembler "psllq" } } */
-/* { dg-final { scan-assembler "psrlq" } } */
-
-unsigned long long a, b;
-
-void test1 (int c)
-{
-  a = b << c;
-}
-
-void test2 (int c)
-{
-  a = b >> c;
-}
Index: gcc/testsuite/gcc.target/i386/pr52146.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr52146.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr52146.c	(.../branches/gcc-8-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32" } */
 
 void
Index: gcc/testsuite/gcc.target/i386/pr89523-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-4.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-4.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,36 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -march=haswell" } */
+/* { dg-final { scan-assembler-not "\tvgather" } } */
+/* { dg-final { scan-assembler "addr32 vgather" } } */
+
+typedef double __v2df __attribute__ ((__vector_size__ (16)));
+typedef int __v4si __attribute__ ((__vector_size__ (16)));
+typedef long long __v2di __attribute__ ((__vector_size__ (16)));
+
+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));
+
+extern __inline __m128d
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm_i32gather_pd (double const *__base, __m128i __index, const int __scale)
+{
+  __v2df __zero = { 0.0, 0.0 };
+  __v2df __mask = __builtin_ia32_cmpeqpd (__zero, __zero);
+  __v2df x = x;
+
+  return (__m128d) __builtin_ia32_gathersiv2df (x,
+						__base,
+						(__v4si)__index,
+						__mask,
+						__scale);
+}
+
+__m128d x;
+__m128i idx;
+
+void extern
+avx2_test (void)
+{
+  x = _mm_i32gather_pd ((void *) 0, idx, 1);
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,10 +13,12 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-times {jmp[ \t]*\.?LIND} 2 } } */
+/* { dg-final { scan-assembler-times {call[ \t]*\.?LIND} 2 } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk" } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,9 +12,11 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/pr52857-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr52857-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr52857-1.c	(.../branches/gcc-8-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-g -O -mx32 -maddress-mode=long" } */
 
 extern void get_BID128 (int *);
Index: gcc/testsuite/gcc.target/i386/pr52698.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr52698.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr52698.c	(.../branches/gcc-8-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long" } */
 
 extern void abort (void);
Index: gcc/testsuite/gcc.target/i386/ret-thunk-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-1.c	(.../branches/gcc-8-branch)
@@ -6,8 +6,8 @@
 {
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/cet-notrack-icf-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/cet-notrack-icf-3.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/cet-notrack-icf-3.c	(.../branches/gcc-8-branch)
@@ -3,8 +3,8 @@
 /* { dg-options "-O2 -fcf-protection=none" } */
 /* { dg-final { scan-assembler-not "endbr" } } */
 /* { dg-final { scan-assembler-not "fn2:" } } */
-/* { dg-final { scan-assembler "set\[ \t]+fn2,fn1" } } */
-/* { dg-final { scan-assembler "set\[ \t]+fn3,fn1" } } */
+/* { dg-final { scan-assembler "set\[ \t]+fn2,fn1" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "set\[ \t]+fn3,fn1" { target { ! *-*-darwin* } } } } */
 
 int (*foo)(int);
 
Index: gcc/testsuite/gcc.target/i386/ret-thunk-10.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-10.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-10.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=thunk-inline -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=thunk-inline -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -10,11 +11,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-times {\tpause} 2 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 2 } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "_?__x86_indirect_thunk_(r|e)ax:" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/pr55049-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr55049-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr55049-1.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile { target { ! ia32 } } } */
 /* { dg-require-effective-target fpic } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -fPIC -mx32" } */
 
 extern void __morestack_fail (const char *msg);
Index: gcc/testsuite/gcc.target/i386/pr54157.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr54157.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr54157.c	(.../branches/gcc-8-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long -ftree-vectorize" } */
 
 struct s2{
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,9 +13,11 @@
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-25.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-25.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-25.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* PR target/r84530 */
 /* { dg-do compile { target ia32 } } */
+/* { dg-skip-if "ABI differs for return complex value" { *-*-darwin* } } */
 /* { dg-options "-O2 -mfunction-return=thunk -fcheck-pointer-bounds -mmpx -fno-pic" } */
 
 struct s { _Complex unsigned short x; };
Index: gcc/testsuite/gcc.target/i386/ret-thunk-9.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-9.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-9.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=thunk -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=thunk -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -10,12 +11,14 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "__x86_return_thunk:" } } */
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
+/* { dg-final { scan-assembler {jmp[ \t]+\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]+\.?LIND} } } */
+/* { dg-final { scan-assembler "_?__x86_return_thunk:" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_bar} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_bar\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler-times {\tpause} 2 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 2 } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/pr89523-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-5.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-5.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,39 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512pf" } */
+/* { dg-final { scan-assembler "\tvgather" } } */
+/* { dg-final { scan-assembler-not "addr32 vgather" } } */
+
+typedef int __v8si __attribute__ ((__vector_size__ (32)));
+typedef long long __m256i __attribute__ ((__vector_size__ (32),
+					  __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_prefetch_i32gather_pd (__m256i __index, void const *__addr,
+			      int __scale, int __hint)
+{
+  __builtin_ia32_gatherpfdpd ((__mmask8) 0xFF, (__v8si) __index, __addr,
+			      __scale, __hint);
+}
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_mask_prefetch_i32gather_pd (__m256i __index, __mmask8 __mask,
+				   void const *__addr, int __scale, int __hint)
+{
+  __builtin_ia32_gatherpfdpd (__mask, (__v8si) __index, __addr, __scale,
+			      __hint);
+}
+
+volatile __m256i idx;
+volatile __mmask8 m8;
+void *base;
+
+void extern
+avx512pf_test (void)
+{
+  _mm512_prefetch_i32gather_pd (idx, base, 8, 3);
+  _mm512_mask_prefetch_i32gather_pd (idx, m8, base, 8, 3);
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,10 +13,12 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-times {jmp[ \t]*\.?LIND} 2 } } */
+/* { dg-final { scan-assembler-times {call[ \t]*\.?LIND} 2 } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,9 +12,11 @@
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/pr52857-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr52857-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr52857-2.c	(.../branches/gcc-8-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-g -O -mx32 -maddress-mode=long" } */
 
 void uw_init_context_1 (void *);
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-register-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-register-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-register-1.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mindirect-branch=thunk -mindirect-branch-register -fno-pic" } */
+/* { dg-options "-O2 -mindirect-branch=thunk -mindirect-branch-register " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,12 +12,12 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler "mov\[ \t\](%eax|%rax), \\((%esp|%rsp)\\)" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler-not "push(?:l|q)\[ \t\]*_?dispatch"  } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk\n" } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk_bnd\n" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk\n" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk_bnd\n" } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-2.c	(.../branches/gcc-8-branch)
@@ -6,8 +6,8 @@
 {
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
Index: gcc/testsuite/gcc.target/i386/cet-notrack-icf-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/cet-notrack-icf-4.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/cet-notrack-icf-4.c	(.../branches/gcc-8-branch)
@@ -3,7 +3,7 @@
 /* { dg-options "-O2 -fcf-protection" } */
 /* { dg-final { scan-assembler "endbr" } } */
 /* { dg-final { scan-assembler "fn2:" } } */
-/* { dg-final { scan-assembler "set\[ \t]+fn3,fn1" } } */
+/* { dg-final { scan-assembler "set\[ \t]+fn3,fn1" { target { ! *-*-darwin* } } } } */
 
 int (*foo)(int);
 
Index: gcc/testsuite/gcc.target/i386/ret-thunk-11.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-11.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-11.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=thunk-extern -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=thunk-extern -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -10,11 +11,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "_?__x86_indirect_thunk_(r|e)ax:" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/cet-sjlj-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/cet-sjlj-5.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/cet-sjlj-5.c	(.../branches/gcc-8-branch)
@@ -3,7 +3,7 @@
 /* { dg-final { scan-assembler-times "endbr32" 2 { target ia32 } } } */
 /* { dg-final { scan-assembler-times "endbr64" 2 { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler-times "call	_?setjmp" 1 } } */
-/* { dg-final { scan-assembler-times "call	longjmp" 1 } } */
+/* { dg-final { scan-assembler-times "call	_?longjmp" 1 } } */
 
 #include <stdio.h>
 #include <setjmp.h>
Index: gcc/testsuite/gcc.target/i386/pr89848.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89848.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89848.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,11 @@
+/* PR target/89848 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -msse2 -mtune=pentium3m" } */
+
+long long
+foo (long long x)
+{
+  x >>= 3;
+  x <<= x;
+  return x;
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -14,9 +15,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-times {jmp[ \t]*\.?LIND} 2 } } */
+/* { dg-final { scan-assembler-times {call[ \t]*\.?LIND} 2 } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
Index: gcc/testsuite/gcc.target/i386/pr90547.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr90547.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr90547.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,21 @@
+/* PR target/90547 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+foo ()
+{
+  void *g[] = {&&a, &&b};
+
+  for (unsigned c = 0x1F;; c >>= 1)
+    {
+      unsigned d = (long)("a"+1);
+      long e = 8;
+
+      while (e)
+        {
+          a: goto *g[c&d];
+          b: e--;
+        }
+    }
+}
Index: gcc/testsuite/gcc.target/i386/pr89523-6.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-6.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-6.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,38 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512pf" } */
+/* { dg-final { scan-assembler-not "\tvgather" } } */
+/* { dg-final { scan-assembler "addr32 vgather" } } */
+
+typedef int __v8si __attribute__ ((__vector_size__ (32)));
+typedef long long __m256i __attribute__ ((__vector_size__ (32),
+					  __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_prefetch_i32gather_pd (__m256i __index, void const *__addr,
+			      int __scale, int __hint)
+{
+  __builtin_ia32_gatherpfdpd ((__mmask8) 0xFF, (__v8si) __index, __addr,
+			      __scale, __hint);
+}
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_mask_prefetch_i32gather_pd (__m256i __index, __mmask8 __mask,
+				   void const *__addr, int __scale, int __hint)
+{
+  __builtin_ia32_gatherpfdpd (__mask, (__v8si) __index, __addr, __scale,
+			      __hint);
+}
+
+volatile __m256i idx;
+volatile __mmask8 m8;
+
+void extern
+avx512pf_test (void)
+{
+  _mm512_prefetch_i32gather_pd (idx, (void *) 0, 8, 3);
+  _mm512_mask_prefetch_i32gather_pd (idx, m8, (void *) 0, 8, 3);
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,9 +13,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/pr53698.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr53698.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr53698.c	(.../branches/gcc-8-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O -mx32 -maddress-mode=long -fno-tree-dominator-opts" } */
 
 extern char foo[];
Index: gcc/testsuite/gcc.target/i386/pr89827.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89827.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89827.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,11 @@
+/* PR target/89827 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -msse2 -mstv -mno-stackrealign" } */
+
+unsigned long long a;
+
+void
+foo (void)
+{
+  a >>= (unsigned short) a;
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-register-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-register-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-register-2.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mindirect-branch=thunk-inline -mindirect-branch-register -fno-pic" } */
+/* { dg-options "-O2 -mindirect-branch=thunk-inline -mindirect-branch-register " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,10 +12,10 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler "mov\[ \t\](%eax|%rax), \\((%esp|%rsp)\\)" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler-not "push(?:l|q)\[ \t\]*_?dispatch"  } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-3.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-3.c	(.../branches/gcc-8-branch)
@@ -6,7 +6,7 @@
 {
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-12.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-12.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-12.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -10,11 +11,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "_?__x86_indirect_thunk_(r|e)ax:" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fjump-tables" } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void func0 (void);
 void func1 (void);
@@ -36,7 +37,7 @@
 }
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk(_nt|)_(r|e)ax" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk(_nt|)_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*\.?LIND" } } */
Index: gcc/testsuite/gcc.target/i386/pr89965.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89965.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89965.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,39 @@
+/* PR rtl-optimization/89965 */
+/* { dg-do run } */
+/* { dg-options "-O -mtune=nano-x2 -fcaller-saves -fexpensive-optimizations -fno-tree-dce -fno-tree-ter" } */
+/* { dg-additional-options "-march=i386" { target ia32 } } */
+
+int a;
+
+__attribute__ ((noipa)) unsigned long long
+foo (unsigned char c, unsigned d, unsigned e, unsigned long long f,
+     unsigned char g, unsigned h, unsigned long long i)
+{
+  (void) d;
+  unsigned short j = __builtin_mul_overflow_p (~0, h, c);
+  e <<= e;
+  i >>= 7;
+  c *= i;
+  i /= 12;
+  a = __builtin_popcount (c);
+  __builtin_add_overflow (e, a, &f);
+  return c + f + g + j + h;
+}
+
+__attribute__ ((noipa)) void
+bar (void)
+{
+  char buf[64];
+  __builtin_memset (buf, 0x55, sizeof buf);
+  asm volatile ("" : : "r" (&buf[0]) : "memory");
+}
+
+int
+main (void)
+{
+  bar ();
+  unsigned long long x = foo (2, 0, 0, 0, 0, 0, 0);
+  if (x != 0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -13,9 +14,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-times {jmp[ \t]*\.?LIND} 2 } } */
+/* { dg-final { scan-assembler-times {call[ \t]*\.?LIND} 2 } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
Index: gcc/testsuite/gcc.target/i386/cet-notrack-5a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/cet-notrack-5a.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/cet-notrack-5a.c	(.../branches/gcc-8-branch)
@@ -2,7 +2,8 @@
 /* { dg-options "-O -fcf-protection" } */
 /* { dg-final { scan-assembler-times "endbr32" 1 { target ia32 } } } */
 /* { dg-final { scan-assembler-times "endbr64" 1 { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-not "\tcall\[ \t]+" } } */
+/* { dg-final { scan-assembler-not "\tcall\[ \t]+" { target { { ! ia32 } || { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler-times "\tcall\[ \t]+" 1 { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler-times "notrack call\[ \t]+" 1 } } */
 
 int (*fptr) (int) __attribute__ ((nocf_check));
Index: gcc/testsuite/gcc.target/i386/pr89523-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-7.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-7.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,42 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512f" } */
+/* { dg-final { scan-assembler "\tvscatter" } } */
+/* { dg-final { scan-assembler-not "addr32 vscatter" } } */
+
+typedef int __v8si __attribute__ ((__vector_size__ (32)));
+typedef double __v8df __attribute__ ((__vector_size__ (64)));
+typedef long long __m256i __attribute__ ((__vector_size__ (32),
+					  __may_alias__));
+typedef double __m512d __attribute__ ((__vector_size__ (64), __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_i32scatter_pd (void *__addr, __m256i __index, __m512d __v1,
+		      int __scale)
+{
+  __builtin_ia32_scattersiv8df (__addr, (__mmask8) 0xFF,
+				(__v8si) __index, (__v8df) __v1, __scale);
+}
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_mask_i32scatter_pd (void *__addr, __mmask8 __mask,
+			   __m256i __index, __m512d __v1, int __scale)
+{
+  __builtin_ia32_scattersiv8df (__addr, __mask, (__v8si) __index,
+				(__v8df) __v1, __scale);
+}
+
+volatile __m512d src;
+volatile __m256i idx;
+volatile __mmask8 m8;
+double *addr;
+
+void extern
+avx512f_test (void)
+{
+  _mm512_i32scatter_pd (addr, idx, src, 8);
+  _mm512_mask_i32scatter_pd (addr, m8, idx, src, 8);
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,9 +13,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-register-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-register-3.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-register-3.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mindirect-branch=thunk-extern -mindirect-branch-register -fno-pic" } */
+/* { dg-options "-O2 -mindirect-branch=thunk-extern -mindirect-branch-register " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,9 +12,9 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not "push(?:l|q)\[ \t\]*_?dispatch"  } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
 /* { dg-final { scan-assembler-not {\t(pause|pause|nop)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-4.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-4.c	(.../branches/gcc-8-branch)
@@ -6,7 +6,7 @@
 {
 }
 
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-13.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-13.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-13.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 extern int foo (void) __attribute__ ((function_return("thunk")));
@@ -11,11 +12,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-times {\tpause} 2 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 2 } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 3 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 3 } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler-times {jmp[ \t]*\.?LIND} 3 } } */
+/* { dg-final { scan-assembler-times {call[ \t]*\.?LIND} 3 } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -14,8 +15,10 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr52876.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr52876.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr52876.c	(.../branches/gcc-8-branch)
@@ -1,4 +1,5 @@
 /* { dg-do run { target x32 } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long" } */
 
 extern void abort (void);
Index: gcc/testsuite/gcc.target/i386/cet-notrack-5b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/cet-notrack-5b.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/cet-notrack-5b.c	(.../branches/gcc-8-branch)
@@ -3,7 +3,8 @@
 /* { dg-options "-O -fcf-protection" } */
 /* { dg-final { scan-assembler-times "endbr32" 1 { target ia32 } } } */
 /* { dg-final { scan-assembler-times "endbr64" 1 { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-times "\tcall\[ \t]+" 1 } } */
+/* { dg-final { scan-assembler-times "\tcall\[ \t]+" 1 { target { { ! ia32 } || { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler-times "\tcall\[ \t]+" 2 { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler-times "notrack call\[ \t]+" 1 } } */
 
 int (*fptr) (int) __attribute__ ((nocf_check));
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,8 +12,10 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr89523-8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-8.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-8.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,41 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512f" } */
+/* { dg-final { scan-assembler "\tvscatter" } } */
+/* { dg-final { scan-assembler-not "addr32 vscatter" } } */
+
+typedef long long __v8di __attribute__ ((__vector_size__ (64)));
+typedef double __v8df __attribute__ ((__vector_size__ (64)));
+typedef long long __m512i __attribute__ ((__vector_size__ (64), __may_alias__));
+typedef double __m512d __attribute__ ((__vector_size__ (64), __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_i64scatter_pd (void *__addr, __m512i __index, __m512d __v1,
+		      int __scale)
+{
+  __builtin_ia32_scatterdiv8df (__addr, (__mmask8) 0xFF,
+				(__v8di) __index, (__v8df) __v1, __scale);
+}
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_mask_i64scatter_pd (void *__addr, __mmask8 __mask,
+			   __m512i __index, __m512d __v1, int __scale)
+{
+  __builtin_ia32_scatterdiv8df (__addr, __mask, (__v8di) __index,
+				(__v8df) __v1, __scale);
+}
+
+volatile __m512d src;
+volatile __m512i idx;
+volatile __mmask8 m8;
+double *addr;
+
+void extern
+avx512f_test (void)
+{
+  _mm512_i64scatter_pd (addr, idx, src, 8);
+  _mm512_mask_i64scatter_pd (addr, m8, idx, src, 8);
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fjump-tables" } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void func0 (void);
 void func1 (void);
@@ -37,8 +38,8 @@
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
Index: gcc/testsuite/gcc.target/i386/pr89523-1a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-1a.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-1a.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,24 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-maddress-mode=short -mx32 -Ofast -funroll-loops -march=haswell" } */
+/* { dg-final { scan-assembler-not "\tvgather" } } */
+/* { dg-final { scan-assembler "addr32 vgather" } } */
+
+void foo (void);
+
+extern float *ncost;
+
+float
+bar (int type, int num)
+{
+  int i;
+  float cost;
+
+  cost = 0;
+  for (i = 0; i < num; i++)
+    if (type)
+      cost += ncost[i];
+    else
+      foo ();
+  return (cost);
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile { target { ! x32 } } } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fcheck-pointer-bounds -mmpx -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fcheck-pointer-bounds -mmpx" } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void (*dispatch) (char *);
 char buf[10];
@@ -11,8 +12,8 @@
 }
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk_bnd_rax" { target lp64 } } } */
-/* { dg-final { scan-assembler "bnd call\[ \t\]*__x86_indirect_thunk_bnd_eax" { target ia32 } } } */
+/* { dg-final { scan-assembler "bnd jmp\[ \t\]*_?__x86_indirect_thunk_bnd_rax" { target lp64 } } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*_?__x86_indirect_thunk_bnd_eax" { target ia32 } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd ret" } } */
Index: gcc/testsuite/gcc.target/i386/pr89945.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89945.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89945.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,21 @@
+/* PR target/89945 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+foo ()
+{
+  void *g[] = {&&a, &&b};
+
+  for (unsigned c = 0x1F;; c >>= 1)
+    {
+      unsigned d = (long)"a";
+      long e = 8;
+
+      while (e)
+        {
+          a: goto *g[c&d];
+          b: e--;
+        }
+    }
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-register-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-register-4.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-register-4.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mindirect-branch=keep -fno-pic" } */
+/* { dg-options "-O2 -mindirect-branch=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*func_p) (void);
 
Index: gcc/testsuite/gcc.target/i386/ret-thunk-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-5.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-5.c	(.../branches/gcc-8-branch)
@@ -8,8 +8,8 @@
 {
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/pr55093.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr55093.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr55093.c	(.../branches/gcc-8-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long" } */
 /* { dg-skip-if "different ABI" { x86_64-*-mingw* } } */
 
Index: gcc/testsuite/gcc.target/i386/ret-thunk-14.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-14.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-14.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -13,9 +14,11 @@
 
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?bar" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_bar} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_bar\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/pr90193.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr90193.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr90193.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,21 @@
+/* PR target/90193 *
+/* { dg-do link } */
+/* { dg-options "-O1" } */
+/* { dg-require-effective-target tls } */
+
+__thread int var;
+
+static int
+foo (void)
+{
+  asm goto ("jmp %l[l]\n\t" : : "m" (var) : : l);
+  return 0;
+l:
+  return 1;
+}
+
+int
+main ()
+{
+  return foo ();
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -13,8 +14,10 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr89902.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89902.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89902.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,13 @@
+/* PR target/89902 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -fno-tree-coalesce-vars -mavx512bitalg" } */
+
+void bar (void);
+
+int
+foo (long long x)
+{
+  x <<= (char) x;
+  bar ();
+  return x;
+}
Index: gcc/testsuite/gcc.target/i386/pr66470.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr66470.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr66470.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* PR target/66470 */
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long" } */
 /* { dg-require-effective-target tls } */
 
Index: gcc/testsuite/gcc.target/i386/pr59929.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr59929.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr59929.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-options "-O0 -mno-accumulate-outgoing-args" } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-additional-options "-mx32 -maddress-mode=short" { target x32 } } */
 
 void
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,8 +12,10 @@
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr89523-9.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-9.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-9.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,30 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512f" } */
+/* { dg-final { scan-assembler-not "\tvscatter" } } */
+/* { dg-final { scan-assembler "addr32 vscatter" } } */
+
+typedef int __v8si __attribute__ ((__vector_size__ (32)));
+typedef double __v8df __attribute__ ((__vector_size__ (64)));
+typedef long long __m256i __attribute__ ((__vector_size__ (32),
+					  __may_alias__));
+typedef double __m512d __attribute__ ((__vector_size__ (64), __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_i32scatter_pd (void *__addr, __m256i __index, __m512d __v1,
+		      int __scale)
+{
+  __builtin_ia32_scattersiv8df (__addr, (__mmask8) 0xFF,
+				(__v8si) __index, (__v8df) __v1, __scale);
+}
+
+volatile __m512d src;
+volatile __m256i idx;
+
+void extern
+avx512f_test (void)
+{
+  _mm512_i32scatter_pd ((void *) 0, idx, src, 8);
+}
Index: gcc/testsuite/gcc.target/i386/pr89523-1b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-1b.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-1b.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,7 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-maddress-mode=long -mx32 -Ofast -funroll-loops -march=haswell" } */
+/* { dg-final { scan-assembler-not "\tvgather" } } */
+/* { dg-final { scan-assembler "addr32 vgather" } } */
+
+#include "pr89523-1a.c"
Index: gcc/testsuite/gcc.target/i386/pr89684.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89684.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89684.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,23 @@
+/* PR ipa/89684 */
+/* { dg-do compile } */
+/* { dg-require-ifunc "" } */
+
+void bar (int, void (*) (void));
+
+__attribute__((target_clones ("default", "avx")))
+void foo (void)
+{
+  bar (0, foo);
+  bar (0, foo);
+}
+
+__attribute__((target_clones ("default", "avx", "avx2")))
+void baz (void)
+{
+  bar (0, foo);
+  bar (0, foo);
+  bar (0, foo);
+  bar (0, foo);
+  bar (0, foo);
+  bar (0, foo);
+}
Index: gcc/testsuite/gcc.target/i386/ret-thunk-22.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-22.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-22.c	(.../branches/gcc-8-branch)
@@ -6,10 +6,12 @@
 struct s gs = { 100 + 200i };
 struct s __attribute__((noinline)) foo (void) { return gs; }
 
-/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
-/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk_ecx" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk_ecx" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {call[ \t]*___x86.get_pc_thunk.cx} { target { *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {jmp[ \t]*___x86_return_thunk} { target { *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile { target { ! x32 } } } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fcheck-pointer-bounds -mmpx -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fcheck-pointer-bounds -mmpx" } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void (*dispatch) (char *);
 char buf[10];
@@ -12,8 +13,8 @@
 }
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "bnd call\[ \t\]*__x86_indirect_thunk_bnd_(r|e)ax" } } */
-/* { dg-final { scan-assembler "bnd call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*_?__x86_indirect_thunk_bnd_(r|e)ax" } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*\.?LIND" } } */
 /* { dg-final { scan-assembler "bnd ret" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-6.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-6.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-6.c	(.../branches/gcc-8-branch)
@@ -7,8 +7,8 @@
 {
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-15.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-15.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-15.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -11,11 +12,13 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?bar" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_bar} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_bar\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/cet-sjlj-6b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/cet-sjlj-6b.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/cet-sjlj-6b.c	(.../branches/gcc-8-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O -maddress-mode=long -fcf-protection -mx32" } */
 /* { dg-final { scan-assembler-times "endbr64" 2 } } */
 /* { dg-final { scan-assembler-times "movq\t.*buf\\+16" 1 } } */
Index: gcc/testsuite/gcc.target/i386/pr90899.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr90899.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr90899.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,6 @@
+/* PR middle-end/90899 */
+/* { dg-do compile } */
+/* { dg-require-ifunc "" } */
+
+__attribute__ ((target_clones ("default", "arch=slm"))) static int f () { return 0; }
+__attribute__ ((alias ("f"))) __typeof (f) g;
Index: gcc/testsuite/gcc.target/i386/pr89523-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-2.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,37 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -march=haswell" } */
+/* { dg-final { scan-assembler "\tvgather" } } */
+/* { dg-final { scan-assembler-not "addr32 vgather" } } */
+
+typedef double __v2df __attribute__ ((__vector_size__ (16)));
+typedef int __v4si __attribute__ ((__vector_size__ (16)));
+typedef long long __v2di __attribute__ ((__vector_size__ (16)));
+
+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));
+
+extern __inline __m128d
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm_i32gather_pd (double const *__base, __m128i __index, const int __scale)
+{
+  __v2df __zero = { 0.0, 0.0 };
+  __v2df __mask = __builtin_ia32_cmpeqpd (__zero, __zero);
+  __v2df x = x;
+
+  return (__m128d) __builtin_ia32_gathersiv2df (x,
+						__base,
+						(__v4si)__index,
+						__mask,
+						__scale);
+}
+
+__m128d x;
+double *base;
+__m128i idx;
+
+void extern
+avx2_test (void)
+{
+  x = _mm_i32gather_pd (base, idx, 1);
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,10 +12,12 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void func0 (void);
 void func1 (void);
@@ -37,7 +38,9 @@
 }
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk(_nt|)_(r|e)ax" } } */
+/* { dg-final { scan-assembler {leaq[ \t]*L[0-9]+\(%rip\)} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {addl[ \t]*L[0-9]+-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk(_nt|)_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr89903.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89903.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89903.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,14 @@
+/* PR target/89903 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -march=skylake" } */
+
+int a, b;
+
+void
+foo (void)
+{
+  unsigned long long d = 983040;
+  d += a;
+  d >>= (short) d;
+  b = d;
+}
Index: gcc/testsuite/gcc.target/i386/fpprec-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/fpprec-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/fpprec-1.c	(.../branches/gcc-8-branch)
@@ -11,6 +11,9 @@
 	0x1.0000000000001p-1, 0x1.fffffffffffffp-2,
 	0x1.0000000000001p+0, 0x1.fffffffffffffp-1,
 	0x1.8000000000001p+0, 0x1.7ffffffffffffp+0,
+	-0x1.0000000000001p-1, -0x1.fffffffffffffp-2,
+	-0x1.0000000000001p+0, -0x1.fffffffffffffp-1,
+	-0x1.8000000000001p+0, -0x1.7ffffffffffffp+0,
 	-0.0, 0.0, -0.5, 0.5, -1.0, 1.0, -1.5, 1.5, -2.0, 2.0,
 	-2.5, 2.5 };
 #define NUM (sizeof(x)/sizeof(double))
@@ -19,6 +22,7 @@
 	-0x1.fffffffffffffp+1023, 0x1.fffffffffffffp+1023,
 	-0.0, 0.0,
 	1.0, 0.0, 1.0, 1.0, 2.0, 1.0,
+	-1.0, -0.0, -1.0, -1.0, -2.0, -1.0,
 	-0.0, 0.0, -1.0, 1.0, -1.0, 1.0, -2.0, 2.0, -2.0, 2.0,
 	-3.0, 3.0 };
 
@@ -26,6 +30,7 @@
         -0x1.fffffffffffffp+1023, 0x1.fffffffffffffp+1023,
         -0.0, 0.0,
         1.0, 0.0, 1.0, 1.0, 2.0, 1.0,
+        -1.0, -0.0, -1.0, -1.0, -2.0, -1.0,
         -0.0, 0.0, -0.0, 0.0, -1.0, 1.0, -2.0, 2.0, -2.0, 2.0,
         -2.0, 2.0 };
 
@@ -33,6 +38,7 @@
         -0x1.fffffffffffffp+1023, 0x1.fffffffffffffp+1023,
         -1.0, 0.0,
         0.0, 0.0, 1.0, 0.0, 1.0, 1.0,
+        -1.0, -1.0, -2.0, -1.0, -2.0, -2.0,
         -0.0, 0.0, -1.0, 0.0, -1.0, 1.0, -2.0, 1.0, -2.0, 2.0,
         -3.0, 2.0 };
 
@@ -40,6 +46,7 @@
         -0x1.fffffffffffffp+1023, 0x1.fffffffffffffp+1023,
         -0.0, 1.0,
         1.0, 1.0, 2.0, 1.0, 2.0, 2.0,
+        -0.0, -0.0, -1.0, -0.0, -1.0, -1.0,
         -0.0, 0.0, -0.0, 1.0, -1.0, 1.0, -1.0, 2.0, -2.0, 2.0,
         -2.0, 3.0 };
 
@@ -47,6 +54,7 @@
         -0x1.fffffffffffffp+1023, 0x1.fffffffffffffp+1023,
         -0.0, 0.0,
         0.0, 0.0, 1.0, 0.0, 1.0, 1.0,
+        -0.0, -0.0, -1.0, -0.0, -1.0, -1.0,
         -0.0, 0.0, -0.0, 0.0, -1.0, 1.0, -1.0, 1.0, -2.0, 2.0,
         -2.0, 2.0 };
 
Index: gcc/testsuite/gcc.target/i386/cet-notrack-icf-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/cet-notrack-icf-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/cet-notrack-icf-1.c	(.../branches/gcc-8-branch)
@@ -3,8 +3,8 @@
 /* { dg-options "-O2 -fcf-protection=none" } */
 /* { dg-final { scan-assembler-not "endbr" } } */
 /* { dg-final { scan-assembler-not "fn3:" } } */
-/* { dg-final { scan-assembler "set\[ \t]+fn2,fn1" } } */
-/* { dg-final { scan-assembler "set\[ \t]+fn3,fn1" } } */
+/* { dg-final { scan-assembler "set\[ \t]+fn2,fn1" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "set\[ \t]+fn3,fn1" { target { ! *-*-darwin* } } } } */
 
 static __attribute__((noinline)) int
 fn1 (int x)
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,8 +13,10 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fjump-tables" } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void func0 (void);
 void func1 (void);
@@ -36,8 +37,10 @@
 }
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {leaq[ \t]*L[0-9]+\(%rip\)} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {addl[ \t]*L[0-9]+-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-23.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-23.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-23.c	(.../branches/gcc-8-branch)
@@ -6,10 +6,12 @@
 struct s gs = { 100 + 200i };
 struct s __attribute__((noinline)) foo (void) { return gs; }
 
-/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
-/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk_ecx" } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk_ecx" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {call[ \t]*___x86.get_pc_thunk.cx} { target { *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {jmp[ \t]*___x86_return_thunk} { target { *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler-not {\tpause} } } */
 /* { dg-final { scan-assembler-not {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/pr85860.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr85860.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr85860.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,23 @@
+/* { dg-do compile { target lp64 } } */
+/* { dg-options "-O2 -fno-guess-branch-probability -flive-range-shrinkage -mbmi2" } */
+
+int a, b, c, d, e;
+
+extern int bar(void);
+
+__int128
+foo (unsigned g, int h, long i, __int128 j, short k, __int128 l)
+{
+  unsigned __int128 m = j;
+  do
+    {
+      j %= 5;
+      c = c >> (m & 31);
+      e = __builtin_sub_overflow (b, 0, &m);
+      d = bar ();
+      l *= __builtin_mul_overflow_p ((unsigned) d, ~(unsigned __int128) 1,
+				     (unsigned __int128) 0);
+    }
+  while (a);
+  return m + j + k + l;
+}
Index: gcc/testsuite/gcc.target/i386/ret-thunk-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-7.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-7.c	(.../branches/gcc-8-branch)
@@ -7,7 +7,7 @@
 {
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-16.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-16.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-16.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mfunction-return=thunk-inline -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mfunction-return=thunk-inline -mindirect-branch=thunk-extern " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -11,8 +12,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler-not "__x86_return_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr55116-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr55116-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr55116-1.c	(.../branches/gcc-8-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long" } */
 
 int glob_int_arr[100];
Index: gcc/testsuite/gcc.target/i386/pr89523-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr89523-3.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr89523-3.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,36 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -march=haswell" } */
+/* { dg-final { scan-assembler "\tvgather" } } */
+/* { dg-final { scan-assembler-not "addr32 vgather" } } */
+
+typedef double __v2df __attribute__ ((__vector_size__ (16)));
+typedef int __v4si __attribute__ ((__vector_size__ (16)));
+typedef long long __v2di __attribute__ ((__vector_size__ (16)));
+
+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));
+
+extern __inline __m128d
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm_i64gather_pd (double const *__base, __m128i __index, const int __scale)
+{
+  __v2df __zero = { 0.0, 0.0 };
+  __v2df __mask = __builtin_ia32_cmpeqpd (__zero, __zero);
+
+  return (__m128d) __builtin_ia32_gatherdiv2df (__zero,
+						__base,
+						(__v2di)__index,
+						__mask,
+						__scale);
+}
+
+__m128d x;
+double *base;
+__m128i idx;
+
+void extern
+avx2_test (void)
+{
+  x = _mm_i64gather_pd (base, idx, 1);
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,10 +12,12 @@
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-8.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-8.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mfunction-return=keep -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void func0 (void);
 void func1 (void);
@@ -36,7 +37,7 @@
     }
 }
 
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/cet-notrack-6b.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/cet-notrack-6b.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/cet-notrack-6b.c	(.../branches/gcc-8-branch)
@@ -2,7 +2,8 @@
 /* { dg-options "-O0 -fcf-protection" } */
 /* { dg-final { scan-assembler-times "endbr32" 1 { target ia32 } } } */
 /* { dg-final { scan-assembler-times "endbr64" 1 { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-not "\tcall\[ \t]+" } } */
+/* { dg-final { scan-assembler-not "\tcall\[ \t]+" { target { { ! ia32 } || { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler-times "\tcall\[ \t]+" 1 { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler-times "notrack call\[ \t]+" 1 } } */
 
 int foo (int arg);
Index: gcc/testsuite/gcc.target/i386/cet-notrack-icf-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/cet-notrack-icf-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/cet-notrack-icf-2.c	(.../branches/gcc-8-branch)
@@ -3,7 +3,7 @@
 /* { dg-options "-O2 -fcf-protection" } */
 /* { dg-final { scan-assembler "endbr" } } */
 /* { dg-final { scan-assembler "fn3:" } } */
-/* { dg-final { scan-assembler "set\[ \t]+fn2,fn1" } } */
+/* { dg-final { scan-assembler "set\[ \t]+fn2,fn1" { target { ! *-*-darwin* } } } } */
 
 static __attribute__((noinline)) int
 fn1 (int x)
Index: gcc/testsuite/gcc.target/i386/cet-sjlj-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/cet-sjlj-3.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/cet-sjlj-3.c	(.../branches/gcc-8-branch)
@@ -3,7 +3,7 @@
 /* { dg-final { scan-assembler-times "endbr32" 4 { target ia32 } } } */
 /* { dg-final { scan-assembler-times "endbr64" 4 { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler-times "call	_?setjmp" 1 } } */
-/* { dg-final { scan-assembler-times "call	longjmp" 1 } } */
+/* { dg-final { scan-assembler-times "call	_?longjmp" 1 } } */
 
 #include <stdio.h>
 #include <setjmp.h>
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,7 +13,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
Index: gcc/testsuite/gcc.target/i386/pr55597.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr55597.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr55597.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile { target { ! ia32 } } } */
 /* { dg-require-effective-target fpic } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -fPIC -mx32 -maddress-mode=long" } */
 
 struct initial_sp
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c	(.../branches/gcc-8-branch)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -14,9 +15,11 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*l_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-24.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-24.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-24.c	(.../branches/gcc-8-branch)
@@ -6,10 +6,12 @@
 struct s gs = { 100 + 200i };
 struct s __attribute__((noinline)) foo (void) { return gs; }
 
-/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
-/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk_ecx" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk_ecx" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {call[ \t]*___x86.get_pc_thunk.cx} { target { *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*___x86_return_thunk} { target { *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-8.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/ret-thunk-8.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/ret-thunk-8.c	(.../branches/gcc-8-branch)
@@ -8,7 +8,7 @@
 {
 }
 
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr55116-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr55116-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr55116-2.c	(.../branches/gcc-8-branch)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long" } */
 
 typedef struct rtx_def *rtx;
Index: gcc/testsuite/lib/scanasm.exp
===================================================================
--- a/src/gcc/testsuite/lib/scanasm.exp	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/lib/scanasm.exp	(.../branches/gcc-8-branch)
@@ -504,7 +504,10 @@
 	}
     }
 
-    if { [istarget hppa*-*-*] } {
+    if { [istarget hppa*-*-linux*] } {
+	set pattern [format {%s:\n\t.PROC\n\t.CALLINFO.*\n\t.ENTRY\n.L.*:\n(\t.file[^\t]*)*\t[^:]+:%d(:[0-9]+)?\n} \
+                     $symbol $line]
+    } elseif { [istarget hppa*-*-*] } {
 	set pattern [format {\t;[^:]+:%d(:[0-9]+)?\n(\t[^\t]+\n)+%s:\n\t.PROC} \
                      $line $symbol]
     } elseif { [istarget mips*-*-*] } {
Index: gcc/testsuite/gfortran.dg/transfer_simplify_12.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/transfer_simplify_12.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/transfer_simplify_12.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,27 @@
+! { dg-do run }
+! { dg-options "-O -std=legacy" }
+!
+! Test fixes for some findings while resolving PR fortran/89077
+
+program test
+  implicit none
+  integer :: i
+  character(*)  ,parameter :: s =  'abcdef'   ! Length will be 6
+  character(*)  ,parameter :: h = 6Habcdef    ! Length will be 8 (Hollerith!)
+  character(10) ,parameter :: k = 6Habcdef
+  character(10) ,parameter :: t = transfer (s, s)
+  character(10) ,save      :: u = transfer (s, s)
+  character(10) ,parameter :: v = transfer (h, h)
+  character(10) ,save      :: w = transfer (h, h)
+  character(10) ,parameter :: x = transfer ([(s(i:i),i=len(s),1,-1)], s)
+  character(10) ,save      :: y = transfer ([(s(i:i),i=len(s),1,-1)], s)
+  if (len (h) /= 8) stop 1
+  if (h /= s) stop 2
+  if (k /= s) stop 3
+  if (t /= s) stop 4
+  if (u /= s) stop 5
+  if (v /= s) stop 6
+  if (w /= s) stop 7
+  if (x /= "fedcba") stop 8
+  if (y /= x) stop 9
+end program test
Index: gcc/testsuite/gfortran.dg/gomp/pr89651.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/gomp/pr89651.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/gomp/pr89651.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,21 @@
+! PR fortran/89651
+! { dg-do compile }
+! { dg-additional-options "-Wuninitialized" }
+
+program pr89651
+  integer :: n
+  real, allocatable :: t(:)
+  n = 10
+  allocate (t(n), source = 0.0)
+!$omp parallel firstprivate(t)
+  print *, sum (t) ! { dg-bogus "lbound' may be used uninitialized in this function" }
+                   ! { dg-bogus "ubound' may be used uninitialized in this function" "" { target *-*-* } .-1 }
+                   ! { dg-bogus "offset' may be used uninitialized in this function" "" { target *-*-* } .-2 }
+!$omp end parallel
+!$omp parallel private(t)
+  t = 0.0
+  print *, sum (t) ! { dg-bogus "lbound' may be used uninitialized in this function" }
+                   ! { dg-bogus "ubound' may be used uninitialized in this function" "" { target *-*-* } .-1 }
+                   ! { dg-bogus "offset' may be used uninitialized in this function" "" { target *-*-* } .-2 }
+!$omp end parallel
+end program pr89651
Index: gcc/testsuite/gfortran.dg/gomp/pr89621.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/gomp/pr89621.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/gomp/pr89621.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,18 @@
+! PR middle-end/89621
+! { dg-do compile }
+
+subroutine sub(str)
+  character(*), intent(in) :: str
+end subroutine sub
+
+program pr89621
+  implicit none
+  integer i
+  character(len=:), allocatable :: str
+  str = "test"
+  !$omp parallel do
+  do i = 1, 10
+    call sub(str)
+  enddo
+  !$omp end parallel do
+end program pr89621
Index: gcc/testsuite/gfortran.dg/substr_8.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/substr_8.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/substr_8.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,15 @@
+! { dg-do run }
+! PR fortran/71203 - used to ICE on zero-length arrays or substrings
+! Derived from original test cases by Gerhard Steinmetz
+
+program p
+  implicit none
+  character(3), parameter :: a(4) = ' '
+  character(*), parameter :: b(4) = 'abc'
+  character(*), parameter :: x(*) = a(2:2)(3:1)
+  character(*), parameter :: y(*) = a(2:1)(3:1)
+  character(*), parameter :: z(*) = b(2:1)(2:3)
+  if (size (x) /= 1 .or. len(x) /= 0) stop 1
+  if (size (y) /= 0 .or. len(y) /= 0) stop 2
+  if (size (z) /= 0 .or. len(z) /= 2) stop 3
+end
Index: gcc/testsuite/gfortran.dg/allocate_with_mold_3.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/allocate_with_mold_3.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/allocate_with_mold_3.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,21 @@
+! { dg-do  run }
+! PR fortran/89174 - this used to segfault on execution.
+! Test case by Neil Carlson.
+module mod
+  type :: array_data
+    class(*), allocatable :: mold
+  contains
+    procedure :: push
+  end type
+contains
+  subroutine push(this, value)
+    class(array_data), intent(inout) :: this
+    class(*), intent(in) :: value
+    allocate(this%mold, mold=value) ! <== SEGFAULTS HERE
+  end subroutine
+end module
+
+use mod
+type(array_data) :: foo
+call foo%push(42)
+end
Index: gcc/testsuite/gfortran.dg/pointer_array_11.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pointer_array_11.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pointer_array_11.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,90 @@
+! { dg-do run }
+!
+! Test the fix for PR91077 - both the original test and that in comment #4 of the PR.
+!
+! Contribute by Ygal Klein  <ygalklein@gmail.com>
+!
+program test
+  implicit none
+  call original
+  call comment_4
+contains
+  subroutine original
+    integer, parameter :: length = 9
+    real(8), dimension(2) :: a, b
+    integer :: i
+    type point
+       real(8) :: x
+    end type point
+
+    type stored
+       type(point), dimension(:), allocatable :: np
+    end type stored
+    type(stored), dimension(:), pointer :: std =>null()
+    allocate(std(1))
+    allocate(std(1)%np(length))
+    std(1)%np(1)%x = 0.3d0
+    std(1)%np(2)%x = 0.3555d0
+    std(1)%np(3)%x = 0.26782d0
+    std(1)%np(4)%x = 0d0
+    std(1)%np(5)%x = 1.555d0
+    std(1)%np(6)%x = 7.3d0
+    std(1)%np(7)%x = 7.8d0
+    std(1)%np(8)%x = 6.3d0
+    std(1)%np(9)%x = 5.5d0
+!    do i = 1, 2
+!       write(*, "('std(1)%np(',i1,')%x = ',1e22.14)") i, std(1)%np(i)%x
+!    end do
+!    do i = 1, 2
+!       write(*, "('std(1)%np(1:',i1,') = ',9e22.14)") i, std(1)%np(1:i)%x
+!    end do
+    a = std(1)%np(1:2)%x
+    b = [std(1)%np(1)%x, std(1)%np(2)%x]
+!    print *,a
+!    print *,b
+    if (allocated (std(1)%np)) deallocate (std(1)%np)
+    if (associated (std)) deallocate (std)
+    if (norm2(a - b) .gt. 1d-3) stop 1
+  end subroutine
+
+  subroutine comment_4
+    integer, parameter :: length = 2
+    real(8), dimension(length) :: a, b
+    integer :: i
+
+    type point
+       real(8) :: x
+    end type point
+
+    type points
+       type(point), dimension(:), pointer :: np=>null()
+    end type points
+
+    type stored
+       integer :: l
+       type(points), pointer :: nfpoint=>null()
+    end type stored
+
+    type(stored), dimension(:), pointer :: std=>null()
+
+
+    allocate(std(1))
+    allocate(std(1)%nfpoint)
+    allocate(std(1)%nfpoint%np(length))
+    std(1)%nfpoint%np(1)%x = 0.3d0
+    std(1)%nfpoint%np(2)%x = 0.3555d0
+
+!    do i = 1, length
+!       write(*, "('std(1)%nfpoint%np(',i1,')%x = ',1e22.14)") i, std(1)%nfpoint%np(i)%x
+!    end do
+!    do i = 1, length
+!       write(*, "('std(1)%nfpoint%np(1:',i1,')%x = ',2e22.14)") i, std(1)%nfpoint%np(1:i)%x
+!    end do
+    a = std(1)%nfpoint%np(1:2)%x
+    b = [std(1)%nfpoint%np(1)%x, std(1)%nfpoint%np(2)%x]
+    if (associated (std(1)%nfpoint%np)) deallocate (std(1)%nfpoint%np)
+    if (associated (std(1)%nfpoint)) deallocate (std(1)%nfpoint)
+    if (associated (std)) deallocate (std)
+    if (norm2(a - b) .gt. 1d-3) stop 2
+    end subroutine
+end program test
Index: gcc/testsuite/gfortran.dg/c_ptr_tests_19.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/c_ptr_tests_19.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/c_ptr_tests_19.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,36 @@
+! { dg-do run }
+
+! PR 71544 - this failed with some optimization options due to a
+! pointer not being marked as escaping.
+
+module store_cptr
+    use, intrinsic :: iso_c_binding
+    implicit none
+    public
+    type(c_ptr), save :: cptr
+end module store_cptr
+
+subroutine init()
+    use, intrinsic :: iso_c_binding
+    implicit none
+    integer(c_int), pointer :: a
+    allocate(a)
+    call save_cptr(c_loc(a))
+    a = 100
+end subroutine init
+
+subroutine save_cptr(cptr_in)
+    use store_cptr
+    implicit none
+    type(c_ptr), intent(in) :: cptr_in
+    cptr = cptr_in
+end subroutine save_cptr
+
+program init_fails
+    use store_cptr
+    implicit none
+    integer(c_int), pointer :: val
+    call init()
+    call c_f_pointer(cptr,val)
+    if (val /= 100) stop 1
+end program init_fails
Index: gcc/testsuite/gfortran.dg/public_private_module_10.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/public_private_module_10.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/public_private_module_10.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! PR 87734 - this used to issue spurious errors.
+
+module m_vstring
+  implicit none
+
+  public :: vstring_length
+
+contains
+
+  subroutine vstring_cast()
+    character ( len = vstring_length() ) :: char_string
+  end subroutine
+
+  pure integer function vstring_length ()
+  end function
+
+end module
Index: gcc/testsuite/gfortran.dg/entry_22.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/entry_22.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/entry_22.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! { dg-additional-options "-pedantic" }
+! PR fortran/89981 - this used to give a wrong warning (error with
+! -pedantic)
+program main
+  call bar(i)
+  call baz(i) ! { dg-error "Type mismatch in argument" }
+end program main
+subroutine foo(r)
+  entry bar(i)
+  entry baz(r)
+end subroutine foo
Index: gcc/testsuite/gfortran.dg/proc_ptr_51.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/proc_ptr_51.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/proc_ptr_51.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,38 @@
+! { dg-do run }
+!
+! Test the fix for PR90786.
+!
+! Contributed by Andrew benson  <abensonca@gmail.com>
+!
+module f
+procedure(c), pointer :: c_
+
+ type :: s
+   integer :: i = 42
+ end type s
+ class(s), pointer :: res, tgt
+
+contains
+
+ function c()
+   implicit none
+   class(s), pointer ::  c
+   c => tgt
+   return
+ end function c
+
+ subroutine fs()
+   implicit none
+   c_ => c  ! This used to ICE
+   return
+ end subroutine fs
+
+end module f
+
+  use f
+  allocate (tgt, source = s(99))
+  call fs()
+  res => c_()
+  if (res%i .ne. 99) stop 1
+  deallocate (tgt)
+end
Index: gcc/testsuite/gfortran.dg/dependency_53.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/dependency_53.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/dependency_53.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,25 @@
+! { dg-do run }
+! PR fortran/66089 - used to ICE and, after that ICE was fixed,
+! gave wrong results.
+  type :: t
+    integer :: c
+  end type t
+
+  class(t), dimension(:), allocatable :: b,c
+
+  allocate (b(5), source=t(7))
+  allocate(c(5), source=t(13))
+  c = plus(c(1), b)
+  if (any(c%c /= 20)) stop 1
+  c = t(13)
+  c = plus(b, c(1))
+  if (any(c%c /= 20)) stop 2
+contains
+
+  elemental function plus(lhs, rhs)
+    class(t), intent(in) :: lhs, rhs
+    type(t)             :: plus
+    plus%c = lhs%c + rhs%c
+  end function plus
+
+end
Index: gcc/testsuite/gfortran.dg/binding_label_tests_30.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/binding_label_tests_30.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/binding_label_tests_30.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! Make sure this error is flagged.
+subroutine foo() ! { dg-error "is already being used as a SUBROUTINE" }
+end subroutine foo
+
+subroutine bar() bind(C,name="foo") ! { dg-error "is already being used as a SUBROUTINE" }
+end subroutine bar
Index: gcc/testsuite/gfortran.dg/class_70.f03
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/class_70.f03	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/class_70.f03	(.../branches/gcc-8-branch)
@@ -0,0 +1,38 @@
+! { dg-do run }
+!
+! Test the fix for PR57284 - [OOP] ICE with find_array_spec for polymorphic
+! arrays. Once thw ICE was fixed, work was needed to fix a segfault while
+! determining the size of 'z'.
+!
+! Contributed by Lorenz Huedepohl  <bugs@stellardeath.org>
+!
+module testmod
+  type type_t
+    integer :: idx
+  end type type_t
+  type type_u
+     type(type_t), allocatable :: cmp(:)
+  end type
+contains
+  function foo(a, b) result(add)
+    class(type_t), intent(in) :: a(:), b(size(a))
+    type(type_t) :: add(size(a))
+    add%idx = a%idx + b%idx
+  end function
+end module testmod
+program p
+  use testmod
+  class(type_t), allocatable, dimension(:) :: x, y, z
+  class(type_u), allocatable :: w
+  allocate (x, y, source = [type_t (1), type_t(2)])
+  z = foo (x, y)
+  if (any (z%idx .ne. [2, 4])) stop 1
+
+! Try something a bit more complicated than the original.
+
+  allocate (w)
+  allocate (w%cmp, source = [type_t (2), type_t(3)])
+  z = foo (w%cmp, y)
+  if (any (z%idx .ne. [3, 5])) stop 2
+  deallocate (w, x, y, z)
+end program
Index: gcc/testsuite/gfortran.dg/transpose_optimization_2.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/transpose_optimization_2.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/transpose_optimization_2.f90	(.../branches/gcc-8-branch)
@@ -61,4 +61,4 @@
 ! The check below for temporaries gave 14 and 33 for "parm" and "atmp".
 !
 ! { dg-final { scan-tree-dump-times "parm" 72 "original" } }
-! { dg-final { scan-tree-dump-times "atmp" 12 "original" } }
+! { dg-final { scan-tree-dump-times "atmp" 13 "original" } }
Index: gcc/testsuite/gfortran.dg/external_procedures_4.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/external_procedures_4.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/external_procedures_4.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,28 @@
+! { dg-do run }
+!
+! Test the fix for PR87127 in which the references to exfunc cause
+! the error "exfunc at (1) is not a function".
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+function exfunc(i)
+  implicit none
+  integer :: exfunc,i
+  exfunc = 2*i
+end function
+
+! contents of test.f90
+program test
+  implicit none
+  integer :: exfunc,i
+  integer,parameter :: array(2)=[6,7]
+  associate(i=>array(2))            ! Original bug
+    if (exfunc(i) .ne. 2*i) stop 1
+  end associate
+  i = 99
+  call foo
+contains
+  subroutine foo()                  ! Comment #3
+    if (exfunc(i) .ne. 2*i) stop 2
+  end subroutine foo
+end program
Index: gcc/testsuite/gfortran.dg/whole_file_3.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/whole_file_3.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/whole_file_3.f90	(.../branches/gcc-8-branch)
@@ -14,8 +14,8 @@
 
       program test
       EXTERNAL R
-      call PHLOAD (R, 1) ! { dg-warning "Missing alternate return spec" }
-      CALL PHLOAD (R, 2) ! { dg-warning "Missing alternate return spec" }
+      call PHLOAD (R, 1) ! { dg-error "Missing alternate return specifier" }
+      CALL PHLOAD (R, 2) ! { dg-error "Missing alternate return specifier" }
       CALL PHLOAD (R, *999) ! This one is OK
  999  continue
       END program test
Index: gcc/testsuite/gfortran.dg/pr85797.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr85797.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr85797.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,31 @@
+! { dg-do compile }
+! PR fortran/83515 - ICE: Invalid expression in gfc_element_size 
+! PR fortran/85797 - ICE in gfc_element_size, at fortran/target-memory.c:126
+! PR fortran/89904 - ICE in gfortran starting with r270045
+
+recursive subroutine a
+  c = transfer (a, b)           ! { dg-error "'SOURCE' argument of 'TRANSFER'" }
+end
+
+recursive subroutine d
+  c = transfer (b, d)           ! { dg-error "'MOLD' argument of 'TRANSFER'" }
+end
+
+subroutine f
+  use, intrinsic :: iso_c_binding
+  integer(c_intptr_t) :: b, c
+  procedure(), pointer :: a
+  c = transfer (a, b)
+  c = transfer (transfer (b, a), b)
+end
+
+module m
+contains
+  function f () result (z)
+    class(*), pointer :: z
+  end function f
+  recursive subroutine s (q)
+    procedure(f) :: q
+    call s (q)
+  end subroutine s
+end
Index: gcc/testsuite/gfortran.dg/dtio_34.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/dtio_34.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/dtio_34.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,32 @@
+! { dg-do run }
+! PR84387 Defined output does not work for a derived type that
+! has no components 
+module m
+   type :: t
+      private
+      !integer :: m_i = 0  !<-- ***
+   contains
+      private
+      procedure, pass(this) :: write_t
+      generic, public :: write(formatted) => write_t
+   end type
+contains
+   subroutine write_t(this, lun, iotype, vlist, istat, imsg)
+      ! argument definitions
+      class(t), intent(in)            :: this
+      integer, intent(in)             :: lun
+      character(len=*), intent(in)    :: iotype
+      integer, intent(in)             :: vlist(:)
+      integer, intent(out)            :: istat
+      character(len=*), intent(inout) :: imsg
+      write(lun, fmt=*, iostat=istat, iomsg=imsg) "Hello World!"
+      return
+   end subroutine write_t
+
+end module
+
+program p
+   use m, only : t
+   type(t) :: foo
+   print "(dt)", foo ! { dg-output " Hello World!" }
+end program
Index: gcc/testsuite/gfortran.dg/associate_48.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/associate_48.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/associate_48.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,41 @@
+! { dg=do run }
+!
+! Test the fix for PR90498.
+!
+! Contributed by Vladimir Fuka  <vladimir.fuka@gmail.com>
+!
+  type field_names_a
+    class(*), pointer :: var(:) =>null()
+  end type
+
+  type(field_names_a),pointer :: a(:)
+  allocate (a(2))
+
+  allocate (a(1)%var(2), source = ["hello"," vlad"])
+  allocate (a(2)%var(2), source = ["HELLO"," VLAD"])
+  call s(a)
+  deallocate (a(1)%var)
+  deallocate (a(2)%var)
+  deallocate (a)
+contains
+  subroutine s(a)
+
+    type(field_names_a) :: a(:)
+
+    select type (var => a(1)%var)
+      type is (character(*))
+        if (any (var .ne. ["hello"," vlad"])) stop 1
+      class default
+        stop
+    end select
+
+    associate (var => a(2)%var)
+      select type (var)
+        type is (character(*))
+          if (any (var .ne. ["HELLO"," VLAD"])) stop 2
+        class default
+          stop
+      end select
+    end associate
+  end
+end
Index: gcc/testsuite/gfortran.dg/coarray_data_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/coarray_data_1.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/coarray_data_1.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,11 @@
+! { dg-do  run }
+! { dg-options "-fcoarray=lib -lcaf_single " }
+! PR 71066 - this used to ICE
+program p
+   real :: a(2,2)[*]
+   integer :: b(2,2)[*]
+   data a /4*0.0/
+   data b /1234, 2345, 3456, 4567/
+   if (any (a /= 0.0)) stop 1
+   if (any (b /= reshape([1234, 2345, 3456, 4567],[2,2]))) stop 2
+end
Index: gcc/testsuite/gfortran.dg/deferred_character_33.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/deferred_character_33.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/deferred_character_33.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,35 @@
+! { dg-do run }
+! { dg-additional-sources deferred_character_33a.f90 }
+! PR fortran/90744 - this used to pass a wrong length
+! to an external function without a prototype.
+! Original test case by Tom Trnka.
+module StringModule
+   implicit none
+
+contains
+   function getstr()
+      character(:), allocatable :: getstr
+
+      getstr = 'OK'
+   end function
+end module
+module TestModule
+   use StringModule
+   implicit none
+
+contains
+   subroutine DoTest()
+      if (.false.) then
+         call convrs('A',getstr())
+      else
+         call convrs('B',getstr())
+      end if
+   end subroutine
+end module
+program external_char_length
+   use TestModule
+
+   implicit none
+
+   call DoTest()
+end program
Index: gcc/testsuite/gfortran.dg/transfer_check_5.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/transfer_check_5.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/transfer_check_5.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,14 @@
+! { dg-do compile }
+! { dg-options "-Wsurprising" }
+!
+! PR fortran/89516 - ICE in gfc_calculate_transfer_sizes at gcc/fortran/check.c:5506
+! Found by Martin Lika
+
+program test
+  character(*), parameter :: n = ''
+  character(*), parameter :: o = transfer ([''], n)
+  print *, transfer(1,'',size=0) ! No warning
+  print *, transfer(1,'',size=1) ! No warning
+  print *, transfer('',1,size=0) ! No warning
+  print *, transfer('',1,size=1) ! { dg-warning "has partly undefined result" }
+end program test
Index: gcc/testsuite/gfortran.dg/pr89492.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr89492.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr89492.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,27 @@
+! { dg-do compile }
+!
+! PR fortran/89492 - Endless compilation of an invalid TRANSFER after r269177
+! Test error recovery for invalid uses of TRANSFER
+! Test proper simplification for MOLD with size 0
+!
+! Derived from original testcase by Dominique d'Humieres
+
+program bug4a
+  implicit none
+  type bug4
+! Intentionally left empty
+  end type bug4
+  integer, parameter :: k = size(transfer('',['']))  ! k = 0
+  integer, parameter :: i = len (transfer('',['']))  ! i = 0
+  integer, parameter :: l = len (transfer('', '' ))  ! l = 0
+  integer, parameter :: m(k) = k
+  integer, parameter :: j(i) = i
+  integer, parameter :: n(l) = l
+  print *, k,i,l,m,j,n
+  print *,      transfer(1,[''])                ! { dg-error "shall not have storage size 0" }
+  print *,      transfer(1, '' )                ! No error
+  print *, size(transfer(1,['']))               ! { dg-error "shall not have storage size 0" }
+  print *, len (transfer(1, '' ))               ! No error
+  print *, size(transfer([1],[bug4()]))         ! { dg-error "shall not have storage size 0" }
+  print *, transfer(transfer([1],[bug4()]),[1]) ! { dg-error "shall not have storage size 0" }
+end program bug4a
Index: gcc/testsuite/gfortran.dg/external_procedure_4.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/external_procedure_4.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/external_procedure_4.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! PR fortran/90937 - this used to cause an ICE.
+! Original test case by Toon Moene.
+subroutine lfidiff
+
+   implicit none
+
+   contains 
+
+      subroutine grlfi(cdnom)
+
+         character(len=*) cdnom(:)
+         character(len=len(cdnom)) clnoma
+
+         call lficas(clnoma)
+
+      end subroutine grlfi
+
+end subroutine lfidiff
Index: gcc/testsuite/gfortran.dg/assign_10.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/assign_10.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/assign_10.f90	(.../branches/gcc-8-branch)
@@ -24,4 +24,4 @@
 ! Note that it is the kind conversion that generates the temp.
 !
 ! { dg-final { scan-tree-dump-times "parm" 20 "original" } }
-! { dg-final { scan-tree-dump-times "atmp" 18 "original" } }
+! { dg-final { scan-tree-dump-times "atmp" 20 "original" } }
Index: gcc/testsuite/gfortran.dg/deferred_character_33a.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/deferred_character_33a.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/deferred_character_33a.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,9 @@
+! { dg-do compile }
+subroutine convrs(quanty,fromto)
+   implicit none
+
+   character(*), intent(in) :: quanty,fromto
+
+   if (len(fromto) /= 2) stop 1
+   if (fromto /= 'OK') stop 2
+end subroutine
Index: gcc/testsuite/gfortran.dg/coarray_allocate_11.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/coarray_allocate_11.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/coarray_allocate_11.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! { dg-additional-options -fcoarray=single }
+program p
+   integer, allocatable :: z[:,:]
+   integer :: i
+   allocate (z[1:,*]) ! { dg-error "Bad array specification in ALLOCATE statement" }
+   allocate (z[:2,*]) ! { dg-error "Bad array specification in ALLOCATE statement" }
+   allocate (z[2:1,*]) ! { dg-error "Upper cobound is less than lower cobound" }
+   allocate (z[:0,*]) ! { dg-error "Bad array specification in ALLOCATE statement" }
+   allocate (z[0,*]) ! { dg-error "Upper cobound is less than lower cobound" }
+   allocate (z[1,*]) ! This is OK
+   allocate (z[1:1,*]) ! This is OK
+   allocate (z[i:i,*]) ! This is OK
+   allocate (z[i:i-1,*]) ! { dg-error "Upper cobound is less than lower cobound" }
+end
Index: gcc/testsuite/gfortran.dg/pointer_intent_8.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pointer_intent_8.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pointer_intent_8.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,22 @@
+! { dg-do run }
+! PR 85797 - this used to get wrong results.
+
+
+PROGRAM testfortran2
+  IMPLICIT NONE
+
+  INTEGER, DIMENSION(10), TARGET :: i4array
+
+  i4array = (/ 1,2,3,4,5,6,7,8,9,10 /)
+
+  call InRef(i4array)
+
+CONTAINS
+
+  subroutine InRef(v)
+    INTEGER, DIMENSION(:), POINTER, INTENT(in) :: v
+    INTEGER :: i
+    if (any (v /= [(i,i=1,10)])) stop 1
+  END subroutine
+
+END
Index: gcc/testsuite/gfortran.dg/ieee/ieee.exp
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/ieee/ieee.exp	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/ieee/ieee.exp	(.../branches/gcc-8-branch)
@@ -22,15 +22,15 @@
 load_lib gfortran-dg.exp
 load_lib target-supports.exp
 
-# Initialize `dg'.
-dg-init
-
-# Flags specified in each test
+# If a testcase doesn't have special options, use these.
 global DEFAULT_FFLAGS
 if ![info exists DEFAULT_FFLAGS] then {
-    set DEFAULT_FFLAGS ""
+    set DEFAULT_FFLAGS " -pedantic-errors"
 }
 
+# Initialize `dg'.
+dg-init
+
 # Flags for finding the IEEE modules
 if [info exists TOOL_OPTIONS] {
    set specpath [get_multilibs ${TOOL_OPTIONS}]
Index: gcc/testsuite/gfortran.dg/binding_label_tests_33.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/binding_label_tests_33.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/binding_label_tests_33.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,39 @@
+! { dg-do run }
+! PR 79485 - used to crash because the wrong routine was called.
+module fmod1
+
+  contains
+
+  subroutine foo(i)
+    implicit none
+
+    integer, intent(inout) :: i
+
+    i=i+1
+
+  end subroutine foo
+
+end module fmod1
+
+module fmod2
+  use iso_c_binding
+  use fmod1, only : foo_first => foo
+
+  contains
+
+  subroutine foo(i) bind(c)
+    implicit none
+
+    integer, intent(inout) :: i
+
+    i=i+2
+    call foo_first(i)
+
+  end subroutine foo
+
+end module fmod2
+
+  use fmod2
+  
+  call foo(i)
+end
Index: gcc/testsuite/gfortran.dg/charlen_17.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/charlen_17.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/charlen_17.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,14 @@
+! { dg-do compile }
+! PR 87673 - used to cause errors about non-pure functions.
+
+module x
+  implicit none
+contains
+  pure function foo() result(res)
+    character(len=:), allocatable :: res
+    allocate (character(bar()) :: res)
+  end function foo
+  pure integer function bar()
+    bar = 1
+  end function bar
+end module x
Index: gcc/testsuite/gfortran.dg/deferred_character_32.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/deferred_character_32.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/deferred_character_32.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,13 @@
+! { dg-do run }
+!
+! Test the fix for PR88117.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+program p
+   character(:), pointer :: z(:)
+   allocate (z, source  = ['abcd', 'bcde'])
+   z = (z) ! gimplifier choked here.
+   if (any (z .ne. ['abcd', 'bcde'])) stop 1
+   deallocate (z)
+end
Index: gcc/testsuite/gfortran.dg/do_subscript_5.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/do_subscript_5.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/do_subscript_5.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,20 @@
+! { dg-do compile }
+! { dg-additional-options "-Wdo-subscript" }
+! PR 90563 - this used to be rejected, wrongly
+! Original test case by Tobias Neumann
+program test
+      implicit none
+      integer, parameter :: swap(4) = [2,1,3,4]
+      real :: p(20)
+      integer :: j
+
+      p = 0.0
+
+      ! The following warnings are actually bogus, but we are not yet
+      ! clever enough to suppress them.
+      do j=1,6 ! { dg-warning "out of bounds" }
+          if (j<5) then
+              p(j) = p(swap(j)) ! { dg-warning "out of bounds" }
+          endif
+      enddo
+end program
Index: gcc/testsuite/gfortran.dg/dg.exp
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/dg.exp	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/dg.exp	(.../branches/gcc-8-branch)
@@ -36,7 +36,7 @@
     global gfortran_test_path
     global gfortran_aux_module_flags
     if { [llength $args] != 2 } {
-	error "dg-set-target-env-var: needs one argument"
+	error "dg-compile-aux-modules: needs one argument"
 	return
     }
 
Index: gcc/testsuite/gfortran.dg/finalize_28.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/finalize_28.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/finalize_28.f90	(.../branches/gcc-8-branch)
@@ -21,4 +21,4 @@
     integer, intent(out) :: edges(:,:)
   end subroutine coo_dump_edges
 end module coo_graphs
-! { dg-final { scan-tree-dump-times "__builtin_free" 6 "original" } }
+! { dg-final { scan-tree-dump-times "__builtin_free" 5 "original" } }
Index: gcc/testsuite/gfortran.dg/substr_simplify.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/substr_simplify.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/substr_simplify.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,20 @@
+! { dg-do run }
+!
+! Test fixes for substring simplications derived from
+! PR fortran/89077 - ICE using * as len specifier for character parameter
+
+program test
+  implicit none
+  integer :: i
+  character(*), parameter :: s = 'abcdef', y = 'efcdab'
+  character(6), save      :: t = transfer ([(s(i:i),  i=1,len(s)  )], s)
+  character(*), parameter :: u = transfer ([(s(i:i+2),i=1,len(s),3)], s)
+  character(6), save      :: v = transfer ([(s(i:i+2),i=1,len(s),3)], s)
+  character(*), parameter :: w = transfer ([(y(i:i+1),i=len(s)-1,1,-2)], s)
+  character(6), save      :: x = transfer ([(y(i:i+1),i=len(s)-1,1,-2)], s)
+  if (len (t) /= len (s) .or. t /= s) stop 1
+  if (len (u) /= len (s) .or. u /= s) stop 2
+  if (len (v) /= len (s) .or. v /= s) stop 3
+  if (len (w) /= len (s) .or. w /= s) stop 4
+  if (len (x) /= len (s) .or. x /= s) stop 5
+end
Index: gcc/testsuite/gfortran.dg/altreturn_10.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/altreturn_10.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/altreturn_10.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! { dg-options -Os }
+! PR 78865 - this used to ICE.
+program p
+   call sub (3)
+end
+subroutine sub (x)
+   integer :: x, i, n
+   do i = 1, x
+      if ( n /= 0 ) stop
+      call sub2
+   end do
+   print *, x, n
+end
+subroutine sub2
+   call sub (*99) ! { dg-error "Unexpected alternate return specifier" }
+   call sub (99.) ! { dg-warning "Type mismatch in argument" }
+99 stop
+end
Index: gcc/testsuite/gfortran.dg/altreturn_9_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/altreturn_9_1.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/altreturn_9_1.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! { dg-options "-std=gnu" }
+! See altreturn_9_0.f90
+subroutine sub(i, *, j)
+  if (i == 10 .and. j == 20) return 1
+  return
+end subroutine sub
Index: gcc/testsuite/gfortran.dg/binding_label_tests_32.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/binding_label_tests_32.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/binding_label_tests_32.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,35 @@
+! { dg-do run }
+! PR 77746 - this used to crash during execution.
+! Original test case by Vladimir Fuka.
+module first
+  private
+  public execute
+  
+  interface execute
+    module procedure random_name
+  end interface
+  
+contains
+
+  subroutine random_name()
+  end subroutine
+end module
+
+module test
+  use first
+
+  implicit none
+
+contains
+
+  subroutine p_execute(i)  bind(C, name="random_name")
+    integer :: i
+
+    call execute()
+  end subroutine
+  
+end module
+
+  use test
+  call p_execute(1)
+end
Index: gcc/testsuite/gfortran.dg/interface_abstract_5.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/interface_abstract_5.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/interface_abstract_5.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,32 @@
+! { dg-do compile }
+!
+! PR 71861: [7/8/9 Regression] [F03] ICE in write_symbol(): bad module symbol
+!
+! Contributed by Gerhard Steinmetz <gerhard.steinmetz.fortran@t-online.de>
+
+module m1
+   intrinsic abs
+   abstract interface
+      function abs(x)    ! { dg-error "ABSTRACT attribute conflicts with INTRINSIC attribute" }
+         real :: abs, x
+      end
+   end interface
+end
+
+module m2
+   abstract interface
+      function abs(x)
+         real :: abs, x
+      end
+   end interface
+   intrinsic abs    ! { dg-error "ABSTRACT attribute conflicts with INTRINSIC attribute" }
+end
+
+module m3
+   abstract interface
+      function f(x)
+         real :: f, x
+      end
+   end interface
+   intrinsic f    ! { dg-error "ABSTRACT attribute conflicts with INTRINSIC attribute" }
+end
Index: gcc/testsuite/gfortran.dg/pr89266.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr89266.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr89266.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,25 @@
+! { dg-do run }
+!
+! PR fortran/89266 - ICE with TRANSFER of len=0 character array constructor
+
+program test
+  implicit none
+  character(*), parameter :: n = ''
+  character(*), parameter :: o = transfer ([''], n)
+  character(*), parameter :: p = transfer ( n , n)
+  character(*), parameter :: q = transfer ([n], n)
+  character(6), save      :: r = transfer ([''], n)
+  character(6), save      :: s = transfer ( n , n)
+  character(6), save      :: t = transfer ([n], n)
+  integer,      parameter :: a(0) = 0
+  integer,      parameter :: b(0) = transfer (a, a)
+  integer,      save      :: c(0) = transfer (a, a)
+  if (len (o) /= 0) stop 1
+  if (len (p) /= 0) stop 2
+  if (len (q) /= 0) stop 3
+  if (r /= "") stop 4
+  if (s /= "") stop 5
+  if (t /= "") stop 6
+  if (size (b) /= 0 .or. any (b /= 0)) stop 7
+  if (size (c) /= 0 .or. any (c /= 0)) stop 8
+end program test
Index: gcc/testsuite/gfortran.dg/coarray/caf.exp
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/coarray/caf.exp	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/coarray/caf.exp	(.../branches/gcc-8-branch)
@@ -51,11 +51,21 @@
     global gfortran_test_path
     global gfortran_aux_module_flags
     if { [llength $args] != 2 } {
-	error "dg-set-target-env-var: needs one argument"
+	error "dg-compile-aux-modules: needs one argument"
 	return
     }
+
+    set level [info level]
+    if { [info procs dg-save-unknown] != [list] } {
+	rename dg-save-unknown dg-save-unknown-level-$level
+    }
+
     dg-test $gfortran_test_path/[lindex $args 1] "" $gfortran_aux_module_flags
-    # cleanup-modules isn't intentionally invoked here.
+    # cleanup-modules is intentionally not invoked here.
+
+    if { [info procs dg-save-unknown-level-$level] != [list] } {
+	rename dg-save-unknown-level-$level dg-save-unknown
+    }
 }
 
 # Add -latomic only where supported.  Assume built-in support elsewhere.
Index: gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90	(.../branches/gcc-8-branch)
@@ -1,5 +1,5 @@
 ! { dg-lto-do link }
-! { dg-extra-ld-options "-r -nostdlib -finline-functions" }
+! { dg-extra-ld-options "-r -nostdlib -finline-functions -Wno-lto-type-mismatch" }
 
 SUBROUTINE int_gen_ti_header_char( hdrbuf, hdrbufsize, itypesize, &
                               DataHandle, Element, VarName, Data, code )
Index: gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90	(.../branches/gcc-8-branch)
@@ -1,5 +1,5 @@
 ! { dg-lto-do link }
-! { dg-extra-ld-options "-r -nostdlib -finline-functions" }
+! { dg-extra-ld-options "-r -nostdlib -finline-functions -Wno-lto-type-mismatch" }
 
 SUBROUTINE int_gen_ti_header_char( hdrbuf, hdrbufsize, itypesize, &
                               DataHandle, Element, VarName, Data, code )
Index: gcc/testsuite/gfortran.dg/lto/pr87689_0.f
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/lto/pr87689_0.f	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/lto/pr87689_0.f	(.../branches/gcc-8-branch)
@@ -0,0 +1,13 @@
+! { dg-lto-run }
+! PR 87689 - this used to fail for POWER, plus it used to
+! give warnings about mismatches with LTO.
+! Original test case by Judical Grasset.
+      program main
+        implicit none
+        character :: c
+        character(len=20) :: res, doesntwork_p8
+        external doesntwork_p8
+        c = 'o'
+        res = doesntwork_p8(c,1,2,3,4,5,6)
+        if (res /= 'foo') stop 3
+      end program main
Index: gcc/testsuite/gfortran.dg/lto/pr87689_1.f
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/lto/pr87689_1.f	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/lto/pr87689_1.f	(.../branches/gcc-8-branch)
@@ -0,0 +1,11 @@
+      function doesntwork_p8(c,a1,a2,a3,a4,a5,a6)
+        implicit none
+        character(len=20) :: doesntwork_p8
+        character :: c
+        integer :: a1,a2,a3,a4,a5,a6
+        if (a1 /= 1 .or. a2 /= 2 .or. a3 /= 3 .or. a4 /= 4 .or. a5 /= 5
+     &       .or. a6 /= 6) stop 1
+       if (c /= 'o ') stop 2
+       doesntwork_p8 = 'foo'
+       return
+       end
Index: gcc/testsuite/gfortran.dg/finalize_34.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/finalize_34.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/finalize_34.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,25 @@
+! { dg-do compile }
+! { dg-additional-options "-fdump-tree-original" }
+! PR 87352 - this used to cause an excessive number of deallocations.
+module testmodule
+  implicit none
+  public
+
+  type :: evtlist_type
+     real,  allocatable, dimension(:) :: p1
+     real,  allocatable, dimension(:) :: p2
+     real,  allocatable, dimension(:) :: p3
+     real,  allocatable, dimension(:) :: p4
+  end type evtlist_type
+
+  type :: evtlistlist_type
+     type(evtlist_type)  :: evtlist(1:1)
+  end type evtlistlist_type
+
+end module testmodule 
+
+program main
+  use testmodule
+  type(evtlist_type), dimension(10) :: a
+end program main
+! { dg-final  { scan-tree-dump-times "__builtin_free" 8 "original" } }
Index: gcc/testsuite/gfortran.dg/pr89664.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr89664.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr89664.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,24 @@
+! { dg-do compile }
+! { dg-options "-Ofast" }
+
+subroutine s (x)
+   real :: x
+   call sub (x)
+end
+subroutine sub (x)
+   real :: x, y
+   logical :: a, b
+   real :: f1, f2, f3, f4
+   y = f1()
+   a = .false.
+   if ( f2() > f3() ) a = .true.
+   b = .false.
+   if ( f2() > f4() ) b = .true.
+   if ( a ) then
+      x = 1.0
+   else if ( b ) then
+      x = 1.0/y**2
+   else
+      x = 1.0/y - y**2
+   end if
+end
Index: gcc/testsuite/gfortran.dg/no_arg_check_2.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/no_arg_check_2.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/no_arg_check_2.f90	(.../branches/gcc-8-branch)
@@ -139,7 +139,7 @@
 ! { dg-final { scan-tree-dump-times "sub_scalar .\\(struct t1 .\\) array_class_t1_alloc._data.data" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_scalar .\\(struct t1 .\\) \\(array_class_t1_ptr._data.dat" 1 "original" } }
 
-! { dg-final { scan-tree-dump-times "sub_array_assumed \\(D" 3 "original" } }
+! { dg-final { scan-tree-dump-times "sub_array_assumed \\(D" 4 "original" } }
 ! { dg-final { scan-tree-dump-times " = _gfortran_internal_pack \\(&parm" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(&array_int\\)" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(real\\(kind=4\\).0:. . restrict\\) array_real_alloc.data" 1 "original" } }
@@ -148,5 +148,5 @@
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) parm" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t2.0:. . restrict\\) array_t2_alloc.data\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. . restrict\\) array_class_t1_alloc._data.data\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 0 "original" } }
 
Index: gcc/testsuite/gfortran.dg/pr77583.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr77583.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr77583.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,10 @@
+! { dg-do compile }
+!
+! PR fortran/77583 - ICE in pp_quoted_string, at pretty-print.c:966
+! Contributed by Gerhard Steinmetz <gerhard.steinmetz.fortran@t-online.de>
+
+pure subroutine sub(s)
+contains
+   pure subroutine s  ! { dg-error "conflicts with DUMMY argument" }
+   end
+end
Index: gcc/testsuite/gfortran.dg/blockdata_11.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/blockdata_11.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/blockdata_11.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,33 @@
+! { dg-do run }
+! PR 84394 - this used to complain about private procedures in
+! BLOCK data.
+module mod1
+   implicit none
+   type :: type1
+      integer :: i1
+   end type type1
+end module
+
+module mod2
+   implicit none
+   contains
+      subroutine sub1
+         integer vals
+         common /block1/ vals(5)
+         if (any(vals /= [1, 2, 3, 4, 5])) stop 1
+      end subroutine
+end module
+
+block data blkdat
+  use mod1
+  integer vals
+  common /block1/ vals(5)
+  data vals/1, 2, 3, 4, 5/
+end block data blkdat
+
+program main
+  use mod2, only: sub1
+  implicit none
+  call sub1
+end program
+
Index: gcc/testsuite/gfortran.dg/altreturn_9_0.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/altreturn_9_0.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/altreturn_9_0.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,10 @@
+! { dg-do  run }
+! { dg-options -std=gnu }
+! { dg-additional-sources altreturn_9_1.f90 }
+! PR 89496 - wrong type for alternate return was generated
+
+program main
+  call sub(10, *10, 20)
+  stop 1
+10 continue
+end program main
Index: gcc/testsuite/gfortran.dg/binding_label_tests_31.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/binding_label_tests_31.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/binding_label_tests_31.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! PR fortran/66695 - this used to ICE.
+! Original test case by Vladimir Fuka.
+module mod
+  implicit none
+contains
+    integer function F()
+    end function
+end module
+    
+module mod_C
+  use mod
+  implicit none
+contains
+  subroutine s()  bind(C, name="f")
+    integer :: x
+      x = F()
+  end subroutine
+end module
Index: gcc/testsuite/gfortran.dg/pr88326.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88326.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88326.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,11 @@
+! { dg-do compile }
+!
+! PR fortran/88326 - ICE in gfc_conv_array_initializer
+
+program p
+  character, parameter :: x(3) = ['a','b','c']
+  character    :: y(1) = transfer('', x) ! { dg-error "Different shape for array assignment" }
+  character(0) :: z(1) = transfer('', x) ! { dg-error "Different shape for array assignment" }
+  character    :: u(0) = transfer('', x)
+  print *, y, z, u
+end
Index: gcc/testsuite/gfortran.dg/warn_conversion_11.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/warn_conversion_11.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/warn_conversion_11.f90	(.../branches/gcc-8-branch)
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! { dg-options "-Wconversion" }
+! PR 86119 - this used to warn.
+program proglen
+
+implicit none
+
+   class(*), allocatable :: s
+   integer :: l2
+
+   allocate(s, source = '123  ')
+
+   select type(s)
+   type is (character(len=*))
+      l2 = len(s)
+   end select
+
+end program proglen
Index: gcc/testsuite/gfortran.dg/assumed_type_2.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/assumed_type_2.f90	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/assumed_type_2.f90	(.../branches/gcc-8-branch)
@@ -157,7 +157,7 @@
 ! { dg-final { scan-tree-dump-times "sub_scalar .\\(struct t1 .\\) array_class_t1_alloc._data.data" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_scalar .\\(struct t1 .\\) \\(array_class_t1_ptr._data.dat" 1 "original" } }
 
-! { dg-final { scan-tree-dump-times "sub_array_assumed \\(D" 3 "original" } }
+! { dg-final { scan-tree-dump-times "sub_array_assumed \\(D" 4 "original" } }
 ! { dg-final { scan-tree-dump-times " = _gfortran_internal_pack \\(&parm" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(&array_int\\)" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(real\\(kind=4\\).0:. . restrict\\) array_real_alloc.data" 1 "original" } }
@@ -166,7 +166,7 @@
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) parm" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t2.0:. . restrict\\) array_t2_alloc.data\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. . restrict\\) array_class_t1_alloc._data.data\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 0 "original" } }
 
 ! { dg-final { scan-tree-dump-times "sub_array_shape \\(&array_real_alloc," 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_shape \\(&array_char_ptr," 1 "original" } }
Index: gcc/testsuite/gcc.c-torture/execute/20190228-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/20190228-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/20190228-1.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,16 @@
+/* PR tree-optimization/89536 */
+/* Testcase by Zhendong Su <su@cs.ucdavis.edu> */
+
+int a = 1;
+
+int main (void)
+{
+  a = ~(a && 1); 
+  if (a < -1)
+    a = ~a;
+  
+  if (!a)
+    __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr90949.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr90949.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr90949.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,42 @@
+void __attribute__ ((noipa, noinline)) my_puts (const char *str) { }
+
+void __attribute__ ((noipa, noinline)) my_free (void *p) { }
+
+
+struct Node
+{
+  struct Node *child;
+};
+
+struct Node space[2] = { };
+
+struct Node * __attribute__ ((noipa, noinline)) my_malloc (int bytes)
+{
+  return &space[0];
+}
+
+void
+walk (struct Node *module, int cleanup)
+{
+  if (module == 0)
+    {
+      return;
+    }
+  if (!cleanup)
+    {
+      my_puts ("No cleanup");
+    }
+  walk (module->child, cleanup);
+  if (cleanup)
+    {
+      my_free (module);
+    }
+}
+
+int
+main ()
+{
+  struct Node *node = my_malloc (sizeof (struct Node));
+  node->child = 0;
+  walk (node, 1);
+}
Index: gcc/testsuite/gcc.c-torture/execute/builtins/builtins.exp
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/builtins/builtins.exp	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/builtins/builtins.exp	(.../branches/gcc-8-branch)
@@ -37,7 +37,7 @@
 torture-init
 set-torture-options $C_TORTURE_OPTIONS {{}} $LTO_TORTURE_OPTIONS
 
-set additional_flags "-fno-tree-loop-distribute-patterns -fno-tracer"
+set additional_flags "-fno-tree-loop-distribute-patterns -fno-tracer -fno-ipa-ra"
 if [istarget "powerpc-*-darwin*"] {
    lappend additional_flags "-Wl,-multiply_defined,suppress"
 }
Index: gcc/testsuite/gcc.c-torture/compile/pr89703-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr89703-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr89703-2.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,13 @@
+/* PR tree-optimization/89703 */
+
+typedef __SIZE_TYPE__ size_t;
+extern void *memcpy (void *, const void *, size_t);
+extern char *strlen (const char *);
+extern char c[2];
+
+void
+foo (char **q)
+{
+  memcpy (c, "a", 2);
+  q[0] = strlen (c);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr89998-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr89998-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr89998-2.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,4 @@
+/* PR tree-optimization/89998 */
+/* { dg-additional-options "-fno-printf-return-value" } */
+
+#include "pr89998-1.c"
Index: gcc/testsuite/gcc.c-torture/compile/pr89663-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr89663-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr89663-1.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,81 @@
+/* PR middle-end/89663 */
+
+int irint ();
+long lrint ();
+long long llrint ();
+int iround ();
+long lround ();
+long long llround ();
+int iceil ();
+long lceil ();
+long long llceil ();
+int ifloor ();
+long lfloor ();
+long long llfloor ();
+int irintf ();
+long lrintf ();
+long long llrintf ();
+int iroundf ();
+long lroundf ();
+long long llroundf ();
+int iceilf ();
+long lceilf ();
+long long llceilf ();
+int ifloorf ();
+long lfloorf ();
+long long llfloorf ();
+int irintl ();
+long lrintl ();
+long long llrintl ();
+int iroundl ();
+long lroundl ();
+long long llroundl ();
+int iceill ();
+long lceill ();
+long long llceill ();
+int ifloorl ();
+long lfloorl ();
+long long llfloorl ();
+
+void
+foo (long long *p)
+{
+  int n = 0;
+#define T(f) p[n++] = f (1);
+  T (irint)
+  T (lrint)
+  T (llrint)
+  T (iround)
+  T (lround)
+  T (llround)
+  T (iceil)
+  T (lceil)
+  T (llceil)
+  T (ifloor)
+  T (lfloor)
+  T (llfloor)
+  T (irintf)
+  T (lrintf)
+  T (llrintf)
+  T (iroundf)
+  T (lroundf)
+  T (llroundf)
+  T (iceilf)
+  T (lceilf)
+  T (llceilf)
+  T (ifloorf)
+  T (lfloorf)
+  T (llfloorf)
+  T (irintl)
+  T (lrintl)
+  T (llrintl)
+  T (iroundl)
+  T (lroundl)
+  T (llroundl)
+  T (iceill)
+  T (lceill)
+  T (llceill)
+  T (ifloorl)
+  T (lfloorl)
+  T (llfloorl)
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr89703-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr89703-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr89703-1.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,13 @@
+/* PR tree-optimization/89703 */
+
+typedef __SIZE_TYPE__ size_t;
+extern char *strlen (const char *);
+extern char *strnlen (const char *, size_t);
+extern char c[2];
+
+void
+foo (char **q)
+{
+  q[0] = strlen (c);
+  q[1] = strnlen (c, 2);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr89655.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr89655.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr89655.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,15 @@
+/* PR middle-end/89655 */
+
+int a, b, d;
+char *c;
+
+void
+foo (void)
+{
+  int f = a;
+  for (;;)
+    {
+      for (f = 0; f < (a > 3 ? : a); f++)
+	b = c[f] ? c[(f + 2 > a - 1 ? a - 1 : 2) * d] : 0;
+    }
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr89998-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr89998-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr89998-1.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,42 @@
+/* PR tree-optimization/89998 */
+
+unsigned int sprintf (char *str, const char *fmt, ...);
+unsigned int snprintf (char *str, __SIZE_TYPE__ len, const char *fmt, ...);
+
+int
+f1 (char *s)
+{
+  return sprintf (s, "foo");
+}
+
+int
+f2 (char *s)
+{
+  return sprintf (s, "%d", 123);
+}
+
+int
+f3 (int *p, char *s)
+{
+  const char *t = "bar";
+  return sprintf (s, "%s", t);
+}
+
+int
+f4 (char *s)
+{
+  return snprintf (s, 8, "foo");
+}
+
+int
+f5 (char *s)
+{
+  return snprintf (s, 8, "%d", 123);
+}
+
+int
+f6 (int *p, char *s)
+{
+  const char *t = "bar";
+  return snprintf (s, 8, "%s", t);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr89412.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr89412.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr89412.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,16 @@
+/* PR middle-end/89412 */
+
+struct S { double a, b; } d;
+int e;
+double f;
+
+void
+foo ()
+{
+  _Complex double h;
+  while (e)
+    {
+      f = h;
+      *(struct S *) &h = d;
+    }
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr89663-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr89663-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr89663-2.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,82 @@
+/* PR middle-end/89663 */
+
+int irint (double);
+long lrint (double);
+long long llrint (double);
+int iround (double);
+long lround (double);
+long long llround (double);
+int iceil (double);
+long lceil (double);
+long long llceil (double);
+int ifloor (double);
+long lfloor (double);
+long long llfloor (double);
+int irintf (float);
+long lrintf (float);
+long long llrintf (float);
+int iroundf (float);
+long lroundf (float);
+long long llroundf (float);
+int iceilf (float);
+long lceilf (float);
+long long llceilf (float);
+int ifloorf (float);
+long lfloorf (float);
+long long llfloorf (float);
+int irintl (long double);
+long lrintl (long double);
+long long llrintl (long double);
+int iroundl (long double);
+long lroundl (long double);
+long long llroundl (long double);
+int iceill (long double);
+long lceill (long double);
+long long llceill (long double);
+int ifloorl (long double);
+long lfloorl (long double);
+long long llfloorl (long double);
+
+void
+foo (long long *p)
+{
+  int (*fn) (int);
+  int n = 0;
+#define T(f) fn = (int (*) (int)) f; p[n++] = fn (1);
+  T (irint)
+  T (lrint)
+  T (llrint)
+  T (iround)
+  T (lround)
+  T (llround)
+  T (iceil)
+  T (lceil)
+  T (llceil)
+  T (ifloor)
+  T (lfloor)
+  T (llfloor)
+  T (irintf)
+  T (lrintf)
+  T (llrintf)
+  T (iroundf)
+  T (lroundf)
+  T (llroundf)
+  T (iceilf)
+  T (lceilf)
+  T (llceilf)
+  T (ifloorf)
+  T (lfloorf)
+  T (llfloorf)
+  T (irintl)
+  T (lrintl)
+  T (llrintl)
+  T (iroundl)
+  T (lroundl)
+  T (llroundl)
+  T (iceill)
+  T (lceill)
+  T (llceill)
+  T (ifloorl)
+  T (lfloorl)
+  T (llfloorl)
+}
Index: gcc/testsuite/gnat.dg/unchecked_convert13.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/unchecked_convert13.adb	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gnat.dg/unchecked_convert13.adb	(.../branches/gcc-8-branch)
@@ -0,0 +1,30 @@
+-- { dg-do compile }
+
+with Ada.Unchecked_Conversion;
+
+procedure Unchecked_Convert13 is
+
+  type B16_T is mod 2 ** 16;
+  for B16_T'Size use 16;
+  for B16_T'Alignment use 1;
+
+  type Rec_T is record
+    A : Short_Integer;
+  end record;
+  for Rec_T use record
+    A at 0 range 0 .. 15;
+  end record;
+  for Rec_T'Size use 16;
+
+  Rec : constant Rec_T := (A => 0);
+
+  function Rec_To_B16 is new Ada.Unchecked_Conversion (Rec_T, B16_T);
+
+  procedure Nested (B16 : B16_T) is
+  begin
+    null;
+  end;
+
+begin
+  Nested (Rec_To_B16 (Rec));
+end;
Index: gcc/testsuite/gnat.dg/opt77.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt77.adb	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt77.adb	(.../branches/gcc-8-branch)
@@ -0,0 +1,14 @@
+-- { dg-do run }
+-- { dg-options "-O -fno-inline" }
+
+with Opt77_Pkg; use Opt77_Pkg;
+
+procedure Opt77 is
+  N : Natural := 0;
+  To_Add : Boolean;
+begin
+  Proc ("One", N, To_Add);
+  if To_Add then
+    raise Program_Error;
+  end if;
+end;
Index: gcc/testsuite/gnat.dg/opt78.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt78.adb	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt78.adb	(.../branches/gcc-8-branch)
@@ -0,0 +1,16 @@
+-- { dg-do compile }
+-- { dg-options "-O" }
+
+package body Opt78 is
+
+   procedure Proc (P : UC; Msg : String) is
+      Default : UC := (1, "!");
+   begin
+      if P = Default then
+         raise Program_Error;
+      else
+         raise Constraint_Error;
+      end if;
+   end;
+
+end Opt78;
Index: gcc/testsuite/gnat.dg/opt78.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt78.ads	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt78.ads	(.../branches/gcc-8-branch)
@@ -0,0 +1,13 @@
+package Opt78 is
+
+   subtype Reasonable is Integer range 1..10;
+
+   type UC (D: Reasonable := 2) is record
+      S: String (1 .. D) := "Hi";
+   end record;
+
+   type AUC is access all UC;
+
+   procedure Proc (P : UC; Msg : String);
+
+end Opt78;
Index: gcc/testsuite/gnat.dg/opt79.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt79.adb	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt79.adb	(.../branches/gcc-8-branch)
@@ -0,0 +1,28 @@
+-- { dg-do compile }
+-- { dg-options "-O" }
+
+package body Opt79 is
+
+  function F (I : Integer) return Arr is
+    A : Arr;
+
+    procedure Nested is
+
+      procedure Inner is
+      begin
+        A (1) := 0;
+      end;
+
+    begin
+       Inner;
+    end;
+
+  begin
+    Nested;
+    for J in A'Range loop
+      A (J) := I;
+    end loop;
+    return A;
+  end;
+
+end Opt79;
Index: gcc/testsuite/gnat.dg/opt79.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt79.ads	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt79.ads	(.../branches/gcc-8-branch)
@@ -0,0 +1,7 @@
+package Opt79 is
+
+  type Arr is array (1 .. 8) of Integer;
+
+  function F (I : Integer) return Arr;
+
+end Opt79;
Index: gcc/testsuite/gnat.dg/opt77_pkg.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt77_pkg.adb	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt77_pkg.adb	(.../branches/gcc-8-branch)
@@ -0,0 +1,28 @@
+package body Opt77_Pkg is
+
+  function Compare (S : String) return Boolean is
+  begin
+    return S = "Two";
+  end;
+
+  procedure Proc (S : String; N : in out Natural; To_Add : out Boolean) is
+    To_Take : Boolean := False;
+    To_Read : Boolean := False;
+  begin
+    To_Add := False;
+
+    if S = "One" then
+      To_Read := True;
+      To_Take := Compare (S);
+    end if;
+
+    if To_Read and not To_Take then
+      N := N + 1;
+    end if;
+
+    if To_Take then
+      To_Add := True;
+    end if;
+  end;
+
+end Opt77_Pkg;
Index: gcc/testsuite/gnat.dg/opt77_pkg.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt77_pkg.ads	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gnat.dg/opt77_pkg.ads	(.../branches/gcc-8-branch)
@@ -0,0 +1,5 @@
+package Opt77_Pkg is
+
+  procedure Proc (S : String; N : in out Natural; To_Add : out Boolean);
+
+end Opt77_Pkg;
Index: gcc/testsuite/gnat.dg/specs/array5_pkg2-g.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/specs/array5_pkg2-g.ads	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gnat.dg/specs/array5_pkg2-g.ads	(.../branches/gcc-8-branch)
@@ -0,0 +1,13 @@
+with System.Address_To_Access_Conversions;
+
+generic
+
+  type T is new Root with private;
+
+package Array5_Pkg2.G is
+
+  package Ptr is new System.Address_To_Access_Conversions (T);
+
+  Data : Ptr.Object_Pointer;
+
+end Array5_Pkg2.G;
Index: gcc/testsuite/gnat.dg/specs/array5_pkg2.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/specs/array5_pkg2.ads	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gnat.dg/specs/array5_pkg2.ads	(.../branches/gcc-8-branch)
@@ -0,0 +1,5 @@
+package Array5_Pkg2 is
+
+  type Root is tagged null record;
+
+end Array5_Pkg2;
Index: gcc/testsuite/gnat.dg/specs/array5.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/specs/array5.ads	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gnat.dg/specs/array5.ads	(.../branches/gcc-8-branch)
@@ -0,0 +1,9 @@
+-- { dg-do compile }
+
+with Array5_Pkg1; use Array5_Pkg1;
+
+package Array5 is
+
+  C : constant Integer := Arr'Last;
+
+end Array5;
Index: gcc/testsuite/gnat.dg/specs/array5_pkg1.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/specs/array5_pkg1.ads	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gnat.dg/specs/array5_pkg1.ads	(.../branches/gcc-8-branch)
@@ -0,0 +1,14 @@
+with Array5_Pkg2; use Array5_Pkg2;
+with Array5_Pkg2.G;
+
+package Array5_Pkg1 is
+
+  type Derived is new Root with record
+    N : Integer;
+  end record;
+
+  package My_G is new Array5_Pkg2.G (Derived);
+
+  type Arr is array (1 .. My_G.Data.N) of Integer;
+
+end Array5_Pkg1;
Index: gcc/testsuite/gnat.dg/specs/array4.ads
===================================================================
--- a/src/gcc/testsuite/gnat.dg/specs/array4.ads	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gnat.dg/specs/array4.ads	(.../branches/gcc-8-branch)
@@ -0,0 +1,17 @@
+-- { dg-do compile }
+-- { dg-skip-if "missing -gsplit-dwarf support" { *-*-darwin* } }
+-- { dg-options "-gsplit-dwarf" }
+
+package Array4 is
+
+  type Arr1 is array (Positive range <>) of Boolean;
+
+  Size : Positive := 20;
+
+  type Rec is record
+    A : Arr1 (1 .. Size);
+  end record;
+
+  type Arr2 is array (Positive range <>) of Rec;
+
+end Array4;
Index: gcc/testsuite/gcc.dg/gomp/pr89796.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/gomp/pr89796.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/gomp/pr89796.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,23 @@
+/* PR c++/89796 */
+/* { dg-do compile } */
+/* { dg-additional-options "-Wunused-value" } */
+
+int
+f1 (int *p)
+{
+  int r;
+  #pragma omp atomic capture		/* { dg-bogus "value computed is not used" } */
+  { r = *p; (*p)++; }
+  return r;
+}
+
+int
+f2 (int *p)
+{
+  int s
+    = ({ int r;
+	 #pragma omp atomic capture	/* { dg-bogus "value computed is not used" } */
+	 { r = *p; (*p)++; }
+	 r; });
+  return s;
+}
Index: gcc/testsuite/gcc.dg/pr89521-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89521-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89521-1.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,13 @@
+/* PR c/89521 */
+/* { dg-do compile } */
+/* { dg-options "-Ofast -w" } */
+
+#define A(name) __typeof (__builtin_##name (0)) name (); long name##1 () { return name (1); }
+#define B(name) A(name) A(name##f) A(name##l)
+B (ceil)
+B (floor)
+B (round)
+B (trunc)
+B (nearbyint)
+B (rint)
+B (logb)
Index: gcc/testsuite/gcc.dg/debug/pr89704.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/debug/pr89704.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/debug/pr89704.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,14 @@
+/* PR debug/89704 */
+/* { dg-do compile } */
+
+typedef __INTPTR_TYPE__ intptr_t;
+
+int
+foo (void)
+{
+  lab1:;
+  lab2:;
+  static int i = (intptr_t) &&lab1 - (intptr_t) &&lab2;
+  static int j = (intptr_t) &&lab1 - (intptr_t) &&lab2;
+  return i;
+}
Index: gcc/testsuite/gcc.dg/pr89521-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89521-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89521-2.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,42 @@
+/* PR c/89521 */
+/* { dg-do compile } */
+/* { dg-options "-Ofast -w" } */
+
+#define A(name) __typeof (__builtin_##name (0)) name (); \
+  float name##1 () { return name (1); } \
+  double name##2 () { return name (1); }
+#define B(name) A(name) A(name##l)
+B (cosh)
+B (exp)
+B (exp10)
+B (exp2)
+B (expm1)
+B (gamma)
+B (j0)
+B (j1)
+B (lgamma)
+B (pow10)
+B (sinh)
+B (tgamma)
+B (y0)
+B (y1)
+B (acos)
+B (acosh)
+B (asin)
+B (asinh)
+B (atan)
+B (atanh)
+B (cbrt)
+B (cos)
+B (erf)
+B (erfc)
+B (log)
+B (log10)
+B (log2)
+B (log1p)
+B (sin)
+B (tan)
+B (tanh)
+B (sqrt)
+B (fabs)
+B (logb)
Index: gcc/testsuite/gcc.dg/Wrestrict-19.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/Wrestrict-19.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/Wrestrict-19.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,33 @@
+/* PR middle-end/89934 - ICE on a call with fewer arguments to strncpy
+   declared without prototype
+   { dg-do compile }
+   { dg-options "-O2 -Wall" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+char *strncpy ();
+
+char* f0 (char *s)
+{
+  return strncpy ();
+}
+
+char* f1 (char *s)
+{
+  return strncpy (s);
+}
+
+char* f2 (char *s)
+{
+  return strncpy (s, s + 1);   /* ICE here.  */
+}
+
+void f3 (char *s, size_t n, const char *t)
+{
+  strncpy (s, n, t);
+  strncpy (n, s, t);
+}
+
+/* { dg-prune-output "\\\[-Wbuiltin-declaration-mismatch]" }
+   { dg-prune-output "\\\[-Wint-conversion]" } */
+
Index: gcc/testsuite/gcc.dg/pr90082.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr90082.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr90082.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,13 @@
+/* PR rtl-optimization/90082 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -fnon-call-exceptions -ftrapv" } */
+
+void *buf[5];
+
+void
+foo (int a)
+{
+  if (__builtin_setjmp (buf) == 0)
+    __asm__ ("" : : "n" (a * 2));	/* { dg-error "impossible constraint in 'asm'" } */
+					/* { dg-warning "asm operand 0 probably doesn't match constraints" "" { target *-*-* } .-1 } */
+}
Index: gcc/testsuite/gcc.dg/pr89520-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89520-1.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89520-1.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,13 @@
+/* PR c/89520 */
+/* { dg-do compile } */
+/* { dg-options "-Ofast -w" } */
+
+#define A(name) __typeof (__builtin_##name (0)) name (); long name##1 () { return name (); }
+#define B(name) A(name) A(name##f) A(name##l)
+B (ceil)
+B (floor)
+B (round)
+B (trunc)
+B (nearbyint)
+B (rint)
+B (logb)
Index: gcc/testsuite/gcc.dg/pr90010.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr90010.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr90010.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,27 @@
+/* PR c++/90010 */
+/* { dg-do compile } */
+/* { dg-options "-Wall" } */
+
+char b[4096] = "abc";
+void bar (char *);
+
+void
+foo ()
+{
+  char d[4096];
+  __builtin_snprintf (d, sizeof d, "%sfoobarbazquxquuxquuzthudfred", b);	/* { dg-warning "'foobarbazquxquuxquuzthudfred' directive output may be truncated writing 28 bytes into a region of size between 1 and 4096" } */
+  /* { dg-message "'__builtin_snprintf' output between 29 and 4124 bytes into a destination of size 4096" "" { target *-*-* } .-1 } */
+  bar (d);
+  __builtin_snprintf (d, sizeof d, "%sfoobarbazquxquuxquuzcorgefred", b);	/* { dg-warning "'foobarbazquxquuxquuzcorgefred' directive output may be truncated writing 29 bytes into a region of size between 1 and 4096" } */
+  /* { dg-message "'__builtin_snprintf' output between 30 and 4125 bytes into a destination of size 4096" "" { target *-*-* } .-1 } */
+  bar (d);
+  __builtin_snprintf (d, sizeof d, "%sfoobarbazquxquuxquuzcorgewaldo", b);	/* { dg-warning "'foobarbazquxquuxquuzcorgewaldo' directive output may be truncated writing 30 bytes into a region of size between 1 and 4096" } */
+  /* { dg-message "'__builtin_snprintf' output between 31 and 4126 bytes into a destination of size 4096" "" { target *-*-* } .-1 } */
+  bar (d);
+  __builtin_snprintf (d, sizeof d, "%sfoobarbazquxquuxquuzcorgegarply", b);	/* { dg-warning "'foobarbazquxquuxquuzcorgegarply' directive output may be truncated writing 31 bytes into a region of size between 1 and 4096" } */
+  /* { dg-message "'__builtin_snprintf' output between 32 and 4127 bytes into a destination of size 4096" "" { target *-*-* } .-1 } */
+  bar (d);
+  __builtin_snprintf (d, sizeof d, "%sfoobarfredquxquuxquuzcorgegarply", b);	/* { dg-warning "'foobarfredquxquuxquuzcorgega\.\.\.' directive output may be truncated writing 32 bytes into a region of size between 1 and 4096" } */
+  /* { dg-message "'__builtin_snprintf' output between 33 and 4128 bytes into a destination of size 4096" "" { target *-*-* } .-1 } */
+  bar (d);
+}
Index: gcc/testsuite/gcc.dg/torture/neon-immediate-timode.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/neon-immediate-timode.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/neon-immediate-timode.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,10 @@
+union a {
+  char b;
+  long long c;
+};
+union a d;
+int g(int, union a, union a);
+void e() {
+  union a f[2] = {-1L};
+  g(0, d, f[0]);
+}
Index: gcc/testsuite/gcc.dg/torture/pr89572.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr89572.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr89572.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-finline-functions" } */
+
+int vh, it, k1;
+
+void
+vn (void)
+{
+  ++vh;
+  if (vh == 0 && it == 0)
+    k1 = -k1;
+}
+
+__attribute__ ((returns_twice)) void
+ef (int *uw)
+{
+  while (uw != (void *) 0)
+    {
+      vn ();
+      *uw = 0;
+    }
+}
+
+void
+gu (int *uw)
+{
+  ef (uw);
+}
Index: gcc/testsuite/gcc.dg/torture/pr90071.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr90071.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr90071.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+
+int a;
+static int b;
+
+void
+foo ()
+{
+  int d;
+  int e = (int) (__INTPTR_TYPE__) &&f;
+  void *g = &&h;
+h: ++e;
+   if (a)
+     i: goto *g;
+   for (;;)
+     {
+       e = 0;
+       if (b)
+	 goto i;
+     }
+f:
+   goto *({ d || e < 0 || e >= 2; });
+   &e;
+}
Index: gcc/testsuite/gcc.dg/torture/pr89091.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr89091.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr89091.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,10 @@
+/* PR middle-end/89091 */
+/* { dg-do compile { target int128 } } */
+
+struct S { unsigned __int128 s : 65; };
+
+int
+foo (struct S *x, int y)
+{
+  return y && x->s;
+}
Index: gcc/testsuite/gcc.dg/torture/pr89595.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr89595.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr89595.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,39 @@
+/* { dg-do run } */
+/* { dg-additional-options "-fgimple" } */
+
+int __attribute__((noipa))
+__GIMPLE(startwith("dom")) bar(int cond, int val)
+{
+  int i;
+
+  if (0 != 0)
+    goto bb_6;
+  else
+    goto bb_2;
+
+bb_2:
+  if (cond_5(D) != 0)
+    goto bb_4;
+  else
+    goto bb_5;
+
+bb_4:
+  i_6 = val_2(D);
+  i_1 = val_2(D) > 0 ? i_6 : 0;
+
+bb_5:
+  i_3 = __PHI (bb_4: i_1, bb_2: 0);
+  return i_3;
+
+bb_6:
+  i_4 = 1;
+  i_9 = 2;
+  goto bb_2;
+}
+
+int main()
+{
+  if (bar (1, 1) != 1)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr89677.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr89677.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr89677.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target int32plus } */
+
+int a, b, d;
+unsigned c;
+float e, f, g;
+void h() {
+    float *i = &g;
+    for (; c < 10; c += 3)
+      for (; d; d += 3) {
+	  a = *i;
+	  g = f + 0;
+	  f = b + *i + (b - e + 305219) + -b + 3;
+      }
+}
Index: gcc/testsuite/gcc.dg/torture/pr89505.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr89505.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr89505.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+
+struct S { int i; void *p; int j; };
+int a;
+int __attribute__((noinline))
+foo (struct S * __restrict p, int q)
+{
+  int *x = &p->j;
+  if (q)
+    x = &a;
+  p->j = 1;
+  *x = 2;
+  return p->j;
+}
+
+int main()
+{
+  struct S s;
+  if (foo (&s, 0) != 2)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr89710.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr89710.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr89710.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+
+void
+gm (int *);
+
+__attribute__ ((returns_twice)) void
+jg (void)
+{
+}
+
+void
+eb (void)
+{
+  int r6 = 0;
+
+  if (r6 != 0)
+    gm (&r6);
+}
+
+void
+gm (int *r6)
+{
+  jg ();
+
+  for (;;)
+    {
+      eb ();
+      *r6 = 0;
+    }
+}
Index: gcc/testsuite/gcc.dg/uninit-pr89296.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/uninit-pr89296.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/uninit-pr89296.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wuninitialized" } */
+
+int get_a_value ();
+void printk(const char *);
+void test_func()
+{
+    int loop;
+    while (!loop) {             /* { dg-warning "is used uninitialized" } */
+	loop = get_a_value();
+	printk("...");
+    }
+}
Index: gcc/testsuite/gcc.dg/ipa/ipcp-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/ipa/ipcp-5.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/ipa/ipcp-5.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,45 @@
+/* Test that estimated local cloning time benefit of extern inline functions is
+   zero.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -fdump-ipa-cp -fno-early-inlining"  } */
+/* { dg-add-options bind_pic_locally } */
+
+extern int get_int (void);
+extern void use_stuff (int);
+
+int arr[10];
+
+inline void
+f (int a)
+{
+  arr[0] += a + 5;
+  arr[1] += a + 50;
+  arr[2] += a - 3;
+  arr[3] += a;
+  arr[4] += a + 21;
+  arr[5] += a + 900;
+  arr[6] += a + 2;
+  arr[7] += a + 3456;
+  arr[8] += a + 3;
+  arr[9] += a + 32;
+  use_stuff (a);
+}
+
+
+int
+entry (void)
+{
+  int i;
+  for (i = 0; i < 100; i++)
+    f (7);
+  for (i = 0; i < 100; i++)
+    f (get_int ());
+  return 0;
+}
+
+
+/* { dg-final { scan-ipa-dump "loc_time: 0" "cp" } } */
+/* { dg-final { scan-ipa-dump-not "replacing param.*with const" "cp"  } } */
+
+
Index: gcc/testsuite/gcc.dg/pr88074.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr88074.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr88074.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+#include <complex.h>
+
+int main()
+{
+  _Complex double x;
+  __real x = 3.091e+8;
+  __imag x = -4.045e+8;
+  /* This used to spend huge amounts of compile-time inside mpc.  */
+  volatile _Complex double y = ctan (x);
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr89520-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89520-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89520-2.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,42 @@
+/* PR c/89520 */
+/* { dg-do compile } */
+/* { dg-options "-Ofast -w" } */
+
+#define A(name) __typeof (__builtin_##name (0)) name (); \
+  float name##1 () { return name (); } \
+  double name##2 () { return name (); }
+#define B(name) A(name) A(name##l)
+B (cosh)
+B (exp)
+B (exp10)
+B (exp2)
+B (expm1)
+B (gamma)
+B (j0)
+B (j1)
+B (lgamma)
+B (pow10)
+B (sinh)
+B (tgamma)
+B (y0)
+B (y1)
+B (acos)
+B (acosh)
+B (asin)
+B (asinh)
+B (atan)
+B (atanh)
+B (cbrt)
+B (cos)
+B (erf)
+B (erfc)
+B (log)
+B (log10)
+B (log2)
+B (log1p)
+B (sin)
+B (tan)
+B (tanh)
+B (sqrt)
+B (fabs)
+B (logb)
Index: gcc/testsuite/gcc.dg/vect/pr90018.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr90018.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr90018.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,47 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vect_double } */
+
+#include "tree-vect.h"
+
+void __attribute__((noinline,noclone))
+foo (double *a4, int n)
+{
+  for (int i = 0; i < n; ++i)
+    {
+      /* We may not apply interleaving to the group (a), (b) because of (c).  */
+      double tem1 = a4[i*4] + a4[i*4+n*4] /* (a) */;
+      double tem2 = a4[i*4+2*n*4+1];
+      a4[i*4+n*4+1] = tem1; /* (c) */
+      a4[i*4+1] = tem2;
+      double tem3 = a4[i*4] - tem2;
+      double tem4 = tem3 + a4[i*4+n*4];
+      a4[i*4+n*4+1] = tem4 + a4[i*4+n*4+1] /* (b) */;
+    }
+}
+int main(int argc, char **argv)
+{
+  int n = 11;
+  double a4[4 * n * 3];
+  double a42[4 * n * 3];
+  check_vect ();
+  for (int i = 0; i < 4 * n * 3; ++i)
+    a4[i] = a42[i] = i;
+  foo (a4, n);
+  for (int i = 0; i < n; ++i)
+    {
+      double tem1 = a42[i*4] + a42[i*4+n*4];
+      double tem2 = a42[i*4+2*n*4+1];
+      a42[i*4+n*4+1] = tem1;
+      a42[i*4+1] = tem2;
+      double tem3 = a42[i*4] - tem2;
+      double tem4 = tem3 + a42[i*4+n*4];
+      a42[i*4+n*4+1] = tem4 + a42[i*4+n*4+1];
+      __asm__ volatile ("": : : "memory");
+    }
+  for (int i = 0; i < 4 * n * 3; ++i)
+    if (a4[i] != a42[i])
+      __builtin_abort ();
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump "READ_WRITE dependence in interleaving" "vect" } } */
Index: gcc/testsuite/gcc.dg/pr89734.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89734.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89734.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,12 @@
+/* PR c/89734 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+typedef const int CI;
+typedef _Atomic int AI;
+
+CI foo (void);
+const int foo (void);
+
+AI baz (void);
+_Atomic int baz (void);
Index: gcc/testsuite/gcc.dg/pr84032.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr84032.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr84032.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,23 @@
+/* PR rtl-optimization/84032 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -fmodulo-sched" } */
+/* { dg-additional-options "-mcpu=power6" { target { powerpc-*-* } } } */
+
+void
+yr (int cm)
+{
+  int ka = cm;
+
+  for (;;)
+    {
+      short int m0;
+
+      for (m0 = 0; m0 < 6; ++m0)
+        {
+          ka &= 1;
+          cm *= 2;
+        }
+
+      ka = (ka == 0) ? cm : 0;
+    }
+}
Index: gcc/testsuite/gcc.dg/tsan/pr90208-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tsan/pr90208-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/tsan/pr90208-2.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,20 @@
+/* PR tree-optimization/90208 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fexceptions -fsanitize=thread" } */
+
+void *b[5];
+void foo (void);
+
+void
+bar (int d)
+{
+  while (d)
+    foo ();
+}
+
+void
+baz (void)
+{
+  bar (2);
+  __builtin_setjmp (b);
+}
Index: gcc/testsuite/gcc.dg/pr89037.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89037.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89037.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,24 @@
+/* { dg-do run { target int128 } } */
+/* { dg-options "" } */
+
+struct s
+{
+  __int128 y : 66;
+};
+typedef struct s T;
+T a[] = { 1, 10000, 0x12345, 0xff000001, 1ULL << 63, (__int128) 1 << 64,
+	  ((__int128) 1 << 64) | 1 };
+
+int
+main (void)
+{
+  if (a[0].y != 1
+      || a[1].y != 10000
+      || a[2].y != 0x12345
+      || a[3].y != 0xff000001
+      || a[4].y != (1ULL << 63)
+      || a[5].y != ((__int128) 1 << 64)
+      || a[6].y != (((__int128) 1 << 64) | 1))
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/guality/pr54970.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/guality/pr54970.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/guality/pr54970.c	(.../branches/gcc-8-branch)
@@ -8,17 +8,17 @@
 int
 main ()
 {
-  int a[] = { 1, 2, 3 };	/* { dg-final { gdb-test 15 "a\[0\]" "1" } } */
+  int a[] = { 1, 2, 3 };	/* { dg-final { gdb-test 15 "a\[0\]" "1" { xfail { *-*-* } } } } */
   int *p = a + 2;		/* { dg-final { gdb-test 15 "a\[1\]" "2" } } */
   int *q = a + 1;		/* { dg-final { gdb-test 15 "a\[2\]" "3" } } */
 				/* { dg-final { gdb-test 15 "*p" "3" } } */
   asm volatile (NOP);		/* { dg-final { gdb-test 15 "*q" "2" } } */
-  *p += 10;			/* { dg-final { gdb-test 20 "a\[0\]" "1" } } */
+  *p += 10;			/* { dg-final { gdb-test 20 "a\[0\]" "1" { xfail { *-*-* } } } } */
 				/* { dg-final { gdb-test 20 "a\[1\]" "2" } } */
 				/* { dg-final { gdb-test 20 "a\[2\]" "13" } } */
 				/* { dg-final { gdb-test 20 "*p" "13" } } */
   asm volatile (NOP);		/* { dg-final { gdb-test 20 "*q" "2" } } */
-  *q += 10;			/* { dg-final { gdb-test 25 "a\[0\]" "1" } } */
+  *q += 10;			/* { dg-final { gdb-test 25 "a\[0\]" "1" { xfail { *-*-* } } } } */
 				/* { dg-final { gdb-test 25 "a\[1\]" "12" } } */
 				/* { dg-final { gdb-test 25 "a\[2\]" "13" } } */
 				/* { dg-final { gdb-test 25 "*p" "13" } } */
Index: gcc/testsuite/gcc.dg/uninit-pred-8_b.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/uninit-pred-8_b.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/uninit-pred-8_b.c	(.../branches/gcc-8-branch)
@@ -1,6 +1,7 @@
-
 /* { dg-do compile } */
-/* { dg-options "-Wuninitialized -O2" } */
+/* ???  Jump threading makes a mess of the logical-op-non-short-circuit=0 case
+   so force it our way.  */
+/* { dg-options "-Wuninitialized -O2 --param logical-op-non-short-circuit=1" } */
 
 int g;
 void bar();
Index: gcc/testsuite/gcc.dg/Wrestrict-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/Wrestrict-5.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/Wrestrict-5.c	(.../branches/gcc-8-branch)
@@ -1,19 +1,11 @@
-/* Test to verify that valid calls to common restrict-qualified built-in
+/* PR tree-optimization/83655 - ICE on an invalid call to memcpy declared
+   with no prototype
+   Test to verify that valid calls to common restrict-qualified built-in
    functions declared with no prototype are checked for overlap, and that
    invalid calls are ignored.
   { dg-do compile }
   { dg-options "-O2 -Wrestrict" }  */
 
-typedef __SIZE_TYPE__ size_t;
-
-#if __cplusplus
-extern "C" {
-
-#define NO_PROTO ...
-#else
-#define NO_PROTO /* empty */
-#endif
-
 void* memcpy ();
 char* strncpy ();
 
@@ -41,3 +33,6 @@
 {
   strncpy (d + 1, d + 3, "");
 }
+
+/* { dg-prune-output "\\\[-Wbuiltin-declaration-mismatch]" }
+   { dg-prune-output "\\\[-Wint-conversion]" } */
Index: gcc/testsuite/gcc.dg/pr88074-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr88074-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr88074-2.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,17 @@
+/* PR middle-end/88074 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+/* { dg-add-options float128 } */
+/* { dg-require-effective-target float128 } */
+/* { dg-final { scan-tree-dump-not "link_error " "optimized" } } */
+
+extern void link_error (void);
+int
+main ()
+{
+  if (((__FLT128_MAX__ * 0.5 + __FLT128_MAX__ * 0.5i)
+       / (__FLT128_MAX__ * 0.25 + __FLT128_MAX__ * 0.25i))
+      != (_Complex _Float128) 2)
+    link_error ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr87979.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr87979.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr87979.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,11 @@
+/* PR rtl-optimization/87979 */
+/* { dg-do compile } */
+/* { dg-options "-Os -fmodulo-sched -fno-tree-loop-im" } */
+/* { dg-additional-options "-march=z196" { target { s390*-*-* } } } */
+
+void foo(void)
+{
+  static int m;
+  for (int i = 0; i < 10; ++i)
+    m++;
+}
Index: gcc/testsuite/gcc.dg/pr89590.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89590.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89590.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,11 @@
+/* PR middle-end/89590 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wall -w" } */
+
+void free (void *);
+
+void
+foo (void)
+{
+  ((void (*)()) free) ();
+}
Index: gcc/testsuite/gcc.dg/tree-ssa/reassoc-43.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-43.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/reassoc-43.c	(.../branches/gcc-8-branch)
@@ -50,4 +50,4 @@
 	}
     }
 }
-/* { dg-final { scan-tree-dump-not "0 != 0" "reassoc2"} } */
+/* { dg-final { scan-tree-dump-not "\[ (\]0 != 0" "reassoc2"} } */
Index: gcc/testsuite/gcc.dg/tree-ssa/pr89872.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr89872.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr89872.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,27 @@
+/* PR c/89872 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+/* { dg-final { scan-tree-dump-times " ={v} 1;" 1 "optimized" } } */
+/* { dg-final { scan-tree-dump-times " ={v} 2;" 1 "optimized" } } */
+/* { dg-final { scan-tree-dump-times " ={v} 3;" 1 "optimized" } } */
+/* { dg-final { scan-tree-dump-times " ={v} 4;" 1 "optimized" } } */
+/* { dg-final { scan-tree-dump-times " ={v} 0;" 1 "optimized" } } */
+/* { dg-final { scan-tree-dump-times " ={v} " 10 "optimized" } } */
+
+void
+foo (void)
+{
+  (volatile int){1} + (volatile int){2};
+}
+
+void
+bar (void)
+{
+  (volatile int){3};
+}
+
+void
+baz (void)
+{
+  (volatile int){4} / (volatile int){0};
+}
Index: gcc/testsuite/gcc.dg/tree-ssa/pr89546.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr89546.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr89546.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,100 @@
+/* { dg-do run } */
+/* { dg-options "-O" } */
+
+struct I
+{
+  int i;
+};
+
+struct A
+{
+  struct I i1;
+  struct I i2;
+  struct I i3;
+};
+
+struct B
+{
+  struct I i0;
+  struct A a;
+};
+
+struct C
+{
+  struct I i00;
+  struct B b;
+};
+
+volatile int v;
+
+void __attribute__((noipa))
+consume_i (struct I i)
+{
+  v = i.i;
+}
+
+void __attribute__((noipa))
+consume_a (struct A a)
+{
+  v = a.i1.i;
+}
+
+void __attribute__((noipa))
+consume_b (struct B b)
+{
+  v = b.a.i1.i;
+}
+
+void __attribute__((noipa))
+consume_c (struct C c)
+{
+  v = c.b.a.i1.i;
+}
+
+
+
+
+int __attribute__((noipa))
+foo (struct I input)
+{
+  struct I i1, i2, i3;
+  struct A a1, a2, a3;
+  struct B b1;
+  struct C c;
+
+  i1 = input;
+  a1.i1 = i1;
+  b1.a = a1;
+
+  i2.i = 1;
+  b1.i0 = i2;
+
+  c.b = b1;
+
+  a2 = c.b.a;
+  a3 = a2;
+  i3 = a3.i1;
+
+  int t = c.b.i0.i;
+  a2.i3.i = 4;
+  consume_i (i1);
+  consume_i (i2);
+  consume_b (b1);
+  consume_a (a1);
+  consume_a (a2);
+  consume_a (a3);
+  consume_c (c);
+
+  return i3.i + t;
+}
+
+int
+main (int argc, char *argv[])
+{
+  struct I s;
+  s.i = 1234;
+  int i = foo (s);
+  if (i != 1235)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/Warray-bounds-38.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/Warray-bounds-38.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/Warray-bounds-38.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,30 @@
+/* PR middle-end/88273 - bogus warning: 'memcpy' offset [-527, -529]
+   is out of the bounds [0, 16]
+   { dg-do compile }
+   { dg-options "-O2 -Wall" }  */
+
+typedef __SIZE_TYPE__ size_t;
+
+void *q;
+
+size_t x, y;
+
+inline void f (char *p, int i, size_t j)
+{
+  size_t n = y ? y : j;
+
+  p += x - i;
+
+  __builtin_memcpy (q, p, n);   /* { dg-bogus "bounds" } */
+
+  x = n;
+}
+
+void g (void)
+{
+  struct { char a[16]; } s;
+
+  f (q, 0, sizeof s);
+
+  f (s.a, 33 * sizeof s, 1);
+}
Index: gcc/testsuite/gcc.dg/pr89679.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr89679.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/gcc.dg/pr89679.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,26 @@
+/* PR rtl-optimization/89679 */
+/* { dg-do run } */
+/* { dg-options "-Og -frerun-cse-after-loop -fno-tree-fre" } */
+
+unsigned short g;
+
+void
+foo (unsigned long long x)
+{
+  if (x != 0xffff)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+#if __SIZEOF_SHORT__ == 2 && __SIZEOF_INT__ == 4 && __CHAR_BIT__ == 8
+  unsigned short d = 0;
+  unsigned long long x, c = ~0;
+  c = c >> d;
+  __builtin_memset (&d, c, 2);
+  x = d + g;
+  foo (x);
+#endif
+  return 0;
+}
Index: gcc/testsuite/ChangeLog
===================================================================
--- a/src/gcc/testsuite/ChangeLog	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/ChangeLog	(.../branches/gcc-8-branch)
@@ -1,3 +1,1170 @@
+2019-08-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline.
+	2019-08-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/91436
+	* g++.dg/lookup/missing-std-include-5.C: Limit test to C++14 and up.
+	* g++.dg/lookup/missing-std-include-6.C: Don't check make_unique in
+	test that runs for C++11.
+	* g++.dg/lookup/missing-std-include-8.C: Check make_unique here.
+
+2019-08-14  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-02  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* g++.dg/ext/instantiate2.C: Remove special-casing for Darwin.
+
+2013-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90563
+	* gfortran.dg/do_subscript_5.f90: New test.
+
+2019-08-05  Kito Cheng  <kito.cheng@sifive.com>
+
+	Backport from mainline
+	2019-08-05  Kito Cheng  <kito.cheng@sifive.com>
+
+	* gcc.target/riscv/promote-type-for-libcall.c: New.
+
+2019-08-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Paul Thomas <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90786
+	PR fortran/90813
+	* gfortran.dg/proc_ptr_51.f90: New test.
+
+2019-07-22  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-07-22  Martin Liska  <mliska@suse.cz>
+
+	PR driver/91172
+	* gcc.dg/pr91172.c: New test.
+
+2019-07-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline
+	2019-07-18  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* c-c++-common/pr53633-2.c: New test.
+
+2019-07-16  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backport from mainline
+	PR target/89222
+	* gcc.target/arm/pr89222.c: Add new test.
+
+2019-07-16  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backport from mainline
+	2019-02-04  Wilco Dijkstra  <wdijkstr@arm.com>
+	PR target/89190
+	* gcc.target/arm/pr89190.c: New test.
+
+2019-07-15  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-07-01  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.target/s390/vector/vec-shift-2.c: New test.
+
+2019-07-12  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	PR testsuite/78529
+	* gcc.c-torture/execute/builtins/builtins.exp: Add -fno-ipa-ra.
+
+2019-07-07  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91077
+	* gfortran.dg/pointer_array_11.f90 : New test.
+
+2019-07-04  Chenghua Xu  <paul.hua.gm@gmail.com>
+
+	Backported from mainline.
+	* gcc.target/mips/mips-fmadd.c: Rename to ...
+	* gcc.target/mips/mips-fmadd-o32.c: ... Here; add abi=32.
+	* gcc.target/mips/mips-fmadd-n64.c: New.
+
+2019-07-04  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-07-03  Martin Liska  <mliska@suse.cz>
+
+	PR middle-end/90899
+	* gcc.target/i386/pr90899.c: New test.
+
+2019-06-29  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/specs/array5.ads: New test.
+	* gnat.dg/specs/array5_pkg1.ads: New helper.
+	* gnat.dg/specs/array5_pkg2.ads: Likewise.
+	* gnat.dg/specs/array5_pkg2-g.ads: Likewise.
+
+2019-06-21  Jeff Law  <law@redhat.com>
+
+	Backport fom mainline
+	2019-06-21  Jeff Law  <law@redhat.com>
+
+        PR tree-optimization/90949
+	* gcc.c-torture/execute/pr90949.c: New test.
+
+2019-06-21  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90937
+	* gfortran.dg/external_procedure_4.f90: New test.
+
+2019-06-16  Jeff Law  <law@redhat.com>
+
+	Backported from mainline
+	2019-05-31  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+	* gcc.target/mips/msa-fmadd.c: New.
+
+2019-06-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Tom Trnka  <trnka@scm.com>
+
+	Backport from trunk
+	PR fortran/90744
+	* gfortran.dg/deferred_character_33.f90: New test.
+	* gfortran.dg/deferred_character_33a.f90: New test.
+
+2019-06-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90810
+	* g++.dg/ext/vector37.C: New test.
+
+2019-06-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90498
+	* gfortran.dg/associate_48.f90 : New test.
+
+2019-06-09  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/57284
+	* gfortran.dg/assign_10.f90: Bump up counts of "atmp".
+	* gfortran.dg/transpose_optimization_2.f90: Ditto
+
+2019-06-09  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/57284
+	* gfortran.dg/class_70.f03
+
+2019-06-07  John David Anglin  <danglin@gcc.gnu.org>
+
+	* lib/scanasm.exp (dg-function-on-line): Add pattern for hppa*-*-linux*.
+
+2019-06-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/82920
+	* gcc.target/i386/indirect-thunk-bnd-1.c: Adjust scan-asms for Darwin,
+	do not use -fno-pic on Darwin.
+	* gcc.target/i386/indirect-thunk-bnd-2.c: Likewise.
+	* gcc.target/i386/ret-thunk-25.c: Skip for Darwin, which has a
+	different ABI for returning this category of complex value.
+
+2019-06-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-15  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/82920
+	* g++.dg/cet-notrack-1.C: Adjust scan assembler for Darwin.
+	* gcc.target/i386/cet-notrack-5a.c: Likewise.
+	* gcc.target/i386/cet-notrack-5b.c: Likewise.
+	* gcc.target/i386/cet-notrack-6b.c: Likewise.
+	* gcc.target/i386/cet-notrack-icf-1.c: Likewise.
+	* gcc.target/i386/cet-notrack-icf-2.c: Likewise.
+	* gcc.target/i386/cet-notrack-icf-3.c: Likewise.
+	* gcc.target/i386/cet-notrack-icf-4.c: Likewise.
+	* gcc.target/i386/cet-sjlj-3.c: Likewise.
+	* gcc.target/i386/cet-sjlj-5.c: Likewise.
+
+2019-06-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-14  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/82920
+	* gcc.target/i386/cet-sjlj-6b.c: Require effective target x32.
+	* gcc.target/i386/pr52146.c: Likewise.
+	* gcc.target/i386/pr52698.c: Likewise.
+	* gcc.target/i386/pr52857-1.c: Likewise.
+	* gcc.target/i386/pr52857-2.c: Likewise.
+	* gcc.target/i386/pr52876.c: Likewise.
+	* gcc.target/i386/pr53698.c: Likewise.
+	* gcc.target/i386/pr54157.c: Likewise.
+	* gcc.target/i386/pr55049-1.c: Likewise.
+	* gcc.target/i386/pr55093.c: Likewise.
+	* gcc.target/i386/pr55116-1.c: Likewise.
+	* gcc.target/i386/pr55116-2.c: Likewise.
+	* gcc.target/i386/pr55597.c: Likewise.
+	* gcc.target/i386/pr59929.c: Likewise.
+	* gcc.target/i386/pr66470.c: Likewise.
+
+2019-06-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-12  Iain Sandoe  <iain@sandoe.co.uk>
+	    Dominique d'Humieres  <dominiq@gcc.gnu.org>
+
+	PR target/82920
+	* gcc.target/i386/indirect-thunk-1.c: Adjust scan-asms for Darwin,
+	do not use -fno-pic on Darwin.
+	* gcc.target/i386/indirect-thunk-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-5.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-6.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-8.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-register-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-register-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-register-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-register-4.c: Likewise.
+	* gcc.target/i386/ret-thunk-1.c: Likewise.
+	* gcc.target/i386/ret-thunk-10.c: Likewise.
+	* gcc.target/i386/ret-thunk-11.c: Likewise.
+	* gcc.target/i386/ret-thunk-12.c: Likewise.
+	* gcc.target/i386/ret-thunk-13.c: Likewise.
+	* gcc.target/i386/ret-thunk-14.c: Likewise.
+	* gcc.target/i386/ret-thunk-15.c: Likewise.
+	* gcc.target/i386/ret-thunk-16.c: Likewise.
+	* gcc.target/i386/ret-thunk-2.c: Likewise.
+	* gcc.target/i386/ret-thunk-22.c: Likewise.
+	* gcc.target/i386/ret-thunk-23.c: Likewise.
+	* gcc.target/i386/ret-thunk-24.c: Likewise.
+	* gcc.target/i386/ret-thunk-3.c: Likewise.
+	* gcc.target/i386/ret-thunk-4.c: Likewise.
+	* gcc.target/i386/ret-thunk-5.c: Likewise.
+	* gcc.target/i386/ret-thunk-6.c: Likewise.
+	* gcc.target/i386/ret-thunk-7.c: Likewise.
+	* gcc.target/i386/ret-thunk-8.c: Likewise.
+	* gcc.target/i386/ret-thunk-9.c: Likewise.
+
+2019-05-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt79.ad[sb]: New test.
+
+2019-05-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/specs/array4.ads: New test.
+
+2019-05-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/unchecked_convert13.adb: New test.
+
+2019-05-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-05-23  Martin Liska  <mliska@suse.cz>
+
+	PR sanitizer/90570
+	* g++.dg/asan/pr90570.C: New test.
+
+2019-05-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt78.ad[sb]: New test.
+
+2019-05-23  Uro Bizjak  <ubizjak@gmail.com>
+
+	Backported from mainline
+	2019-05-21  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/90547
+	* gcc.target/i386/pr90547.c: New test.
+
+2019-05-22  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* g++.dg/tls/pr85400.C: New test.
+
+2019-05-20  Jeff Law  <law@redhat.com>
+
+	Backported from mainline
+	2019-05-17  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	* g++.dg/eh/o32-fp.C: New.
+	* gcc.target/mips/dwarfregtable-1.c: New.
+	* gcc.target/mips/dwarfregtable-2.c: New.
+	* gcc.target/mips/dwarfregtable-3.c: New.
+	* gcc.target/mips/dwarfregtable-4.c: New.
+	* gcc.target/mips/dwarfregtable.h: New.
+
+2019-05-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from mainline
+	2019-05-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/90532 Ensure __is_constructible(T[]) is false
+	* g++.dg/ext/90532.C: New test.
+
+2019-05-16  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-05-07  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89765
+	* gcc.target/powerpc/pr89765-mc.c: New test.
+	* gcc.target/powerpc/vsx-builtin-10c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-10d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-11c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-11d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-12c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-12d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-14c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-14d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-15c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-15d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-16c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-16d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-17c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-17d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-18c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-18d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-19c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-19d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-20c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-20d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-9c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-9d.c: New test.
+
+2019-05-08  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-05-06  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89424
+	* gcc.target/powerpc/pr89424-0.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13a.c: Define macro PR89424 to
+	enable testing of newly patched capability.
+	* gcc.target/powerpc/vsx-builtin-13b.c: Likewise.
+	* gcc.target/powerpc/vsx-builtin-20a.c: Likewise.
+	* gcc.target/powerpc/vsx-builtin-20b.c: Likewise.
+
+2019-05-06  Richard Biener  <rguenther@suse.de>
+
+	PR bootstrap/90359
+	Backport from mainline
+	2019-03-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89655
+	PR bootstrap/89656
+	* gcc.c-torture/compile/pr89655.c: New test.
+
+2019-05-03  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89698
+	* g++.dg/torture/pr89698.C: New testcase.
+
+	2019-03-07  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89595
+	* gcc.dg/torture/pr89595.c: New testcase.
+
+	2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89710
+	* gcc.dg/torture/pr89710.c: New testcase.
+
+	2019-04-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90071
+	* gcc.dg/torture/pr90071.c: New testcase.
+
+	2018-08-20  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	PR target/86984
+	* gcc.target/alpha/pr86984.c: New test.
+
+2019-04-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-04-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/90193
+	* gcc.target/i386/pr90193.c: New test.
+
+	PR target/90187
+	* g++.dg/opt/pr90187.C: New test.
+
+	PR tree-optimization/90208
+	* gcc.dg/tsan/pr90208-2.c: New test.
+
+	2019-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90108
+	* c-c++-common/pr90108.c: New test.
+
+	2019-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/90082
+	* gcc.dg/pr90082.c: New test.
+
+	PR tree-optimization/90090
+	* g++.dg/opt/pr90090.C: New test.
+
+	2019-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89933
+	* c-c++-common/pr89933.c: New test.
+
+	PR rtl-optimization/89965
+	* gcc.target/i386/pr89965.c: New test.
+
+	PR c/89946
+	* c-c++-common/pr89946.c: New test.
+
+	PR rtl-optimization/90026
+	* g++.dg/opt/pr90026.C: New test.
+
+	2019-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90010
+	* gcc.dg/pr90010.c: New test.
+
+	2019-04-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/89998
+	* gcc.c-torture/compile/pr89998-1.c: New test.
+	* gcc.c-torture/compile/pr89998-2.c: New test.
+
+	2019-03-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/89869
+	* g++.dg/ubsan/vptr-14.C: New test.
+
+	PR c/89872
+	* gcc.dg/tree-ssa/pr89872.c: New test.
+
+	2019-03-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89621
+	* gfortran.dg/gomp/pr89621.f90: New test.
+
+	2019-03-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89796
+	* g++.dg/gomp/pr89796.C: New test.
+	* gcc.dg/gomp/pr89796.c: New test.
+
+	2019-03-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/60702
+	* g++.dg/tls/thread_local11.C: Remove scan-tree-dump-times directives
+	for _ZTH* calls.
+	* g++.dg/tls/thread_local11a.C: New test.
+
+	2019-03-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/60702
+	* g++.dg/tls/thread_local11.C: New test.
+	* g++.dg/tls/thread_local11.h: New test.
+	* g++.dg/tls/thread_local12a.C: New test.
+	* g++.dg/tls/thread_local12b.C: New test.
+	* g++.dg/tls/thread_local12c.C: New test.
+	* g++.dg/tls/thread_local12d.C: New test.
+	* g++.dg/tls/thread_local12e.C: New test.
+	* g++.dg/tls/thread_local12f.C: New test.
+	* g++.dg/tls/thread_local12g.C: New test.
+	* g++.dg/tls/thread_local12h.C: New test.
+	* g++.dg/tls/thread_local12i.C: New test.
+	* g++.dg/tls/thread_local12j.C: New test.
+	* g++.dg/tls/thread_local12k.C: New test.
+	* g++.dg/tls/thread_local12l.C: New test.
+
+	2019-03-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89767
+	* g++.dg/cpp1y/lambda-init18.C: New test.
+	* g++.dg/cpp1y/lambda-init19.C: New test.
+	* g++.dg/cpp1y/pr89767.C: New test.
+
+	2019-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/89752
+	* g++.dg/ext/asm15.C: Check for particular diagnostic wording.
+	* g++.dg/ext/asm16.C: Likewise.
+	* g++.dg/ext/asm17.C: New test.
+
+	PR target/89726
+	* gcc.target/i386/fpprec-1.c (x): Add 6 new constants.
+	(expect_round, expect_rint, expect_floor, expect_ceil, expect_trunc):
+	Add expected results for them.
+
+	PR c/89734
+	* gcc.dg/pr89734.c: New test.
+
+	2019-03-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/89704
+	* gcc.dg/debug/pr89704.c: New test.
+
+	2019-03-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/89684
+	* gcc.target/i386/pr89684.c: New test.
+
+	PR rtl-optimization/89679
+	* gcc.dg/pr89679.c: New test.
+
+	PR tree-optimization/89703
+	* gcc.c-torture/compile/pr89703-1.c: New test.
+	* gcc.c-torture/compile/pr89703-2.c: New test.
+
+	PR c++/89512
+	* g++.dg/cpp1y/var-templ61.C: New test.
+
+	2019-03-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/88588
+	* c-c++-common/gomp/pr88588.c: New test.
+
+	2019-03-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89663
+	* gcc.c-torture/compile/pr89663-1.c: New test.
+	* gcc.c-torture/compile/pr89663-2.c: New test.
+
+	2019-03-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/89651
+	* gfortran.dg/gomp/pr89651.f90: New test.
+
+	2019-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/88568
+	* g++.dg/other/pr88568.C: New test.
+
+	2019-03-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/82075
+	* g++.dg/cpp1z/decomp49.C: New test.
+
+	2019-03-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/87148
+	* g++.dg/ext/flexary34.C: New test.
+
+	2019-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89590
+	* gcc.dg/pr89590.c: New test.
+
+	2019-02-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89521
+	* gcc.dg/pr89521-1.c: New test.
+	* gcc.dg/pr89521-2.c: New test.
+
+	PR c/89520
+	* gcc.dg/pr89520-1.c: New test.
+	* gcc.dg/pr89520-2.c: New test.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89403
+	* g++.dg/cpp0x/pr89403.C: New test.
+
+	PR c++/89405
+	* g++.dg/cpp1z/inline-var5.C: New test.
+
+	PR middle-end/89412
+	* gcc.c-torture/compile/pr89412.c: New test.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+		    David Malcolm  <dmalcolm@redhat.com>
+
+	PR middle-end/89091
+	* gcc.dg/torture/pr89091.c: New test.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/88074
+	PR middle-end/89415
+	* gcc.dg/pr88074-2.c: New test.
+
+	2019-02-19  Richard Biener  <rguenther@suse.de>
+
+        PR middle-end/88074
+	* gcc.dg/pr88074.c: New testcase.
+
+2019-04-30  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	PR target/90075
+	* gcc.target/aarch64/pr90075.c: New test.
+
+2019-04-29  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline:
+	2019-01-25  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/89037
+	* gcc.dg/pr89037.c: New test.
+
+2019-04-26  Roman Zhuykov  <zhroma@ispras.ru>
+
+	Backport from mainline
+	2019-04-23  Roman Zhuykov  <zhroma@ispras.ru>
+
+	PR rtl-optimization/87979
+	* gcc.dg/pr87979.c: New test.
+
+	PR rtl-optimization/84032
+	* gcc.dg/pr84032.c: New test.
+
+2019-04-24  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/87127
+	* gfortran.dg/external_procedures_4.f90: New test.
+
+2019-04-17  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-10  Martin Jambor  <mjambor@suse.cz>
+
+        * g++.dg/tree-ssa/pr87008.C: New test.
+        * gcc.dg/guality/pr54970.c: Xfail tests querying a[0] everywhere.
+
+2019-04-17  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-03-15  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/87532
+	* gcc.target/powerpc/pr87532.c: New test.
+	* gcc.target/powerpc/vec-extract-v16qiu-v2.h: New test.
+	* gcc.target/powerpc/vec-extract-v16qiu-v2a.c: New test.
+	* gcc.target/powerpc/vec-extract-v16qiu-v2b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-10a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-10b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-11a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-11b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-12a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-12b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-14a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-14b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-15a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-15b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-16a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-16b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-17a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-17b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-18a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-18b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-19a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-19b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-20a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-20b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-9a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-9b.c: New test.
+
+	2019-03-19  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89736
+	* gcc.target/powerpc/pr87532-mc.c: Modify dejagnu directives to
+	restrict this test to vsx targets.
+
+2019-04-15  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-04-15  Martin Jambor  <mjambor@suse.cz>
+
+	* g++.dg/ipa/pr89693.C: New test.
+
+2019-04-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-01-18  Martin Liska  <mliska@suse.cz>
+
+	PR middle-end/88587
+	* g++.target/i386/pr88587.C: New test.
+	* gcc.target/i386/mvc13.c: New test.
+
+2019-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/87352
+	* gfortran.dg/finalize_28.f90: Adjust count of __builtin_free.
+	* gfortran.dg/finalize_34.f90: New test.
+
+2019-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/89981
+	* gfortran.dg/entry_22.f90: New test.
+
+2019-04-11  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90018
+	* gcc.dg/vect/pr90018.c: New testcase.
+
+2019-04-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89904
+	* gfortran.dg/pr85797.f90: Adjust testcase.
+
+2019-04-10  Matthew Malcomson  <matthew.malcomson@arm.com>
+
+	PR target/90024
+	* gcc.dg/torture/neon-immediate-timode.c: New test.
+
+019-04-07  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/89945
+	* gcc.target/i386/pr89945.c: New test.
+
+2019-04-04  Martin Sebor  <msebor@redhat.com>
+
+	PR middle-end/89934
+	* gcc.dg/Wrestrict-19.c: New test.
+	* gcc.dg/Wrestrict-5.c: Add comment.  Remove unused code.
+
+2019-04-02  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/89902
+	PR target/89903
+	* gcc.target/i386/pr70799-4.c: Remove.
+	* gcc.target/i386/pr70799-5.c: Remove.
+	* gcc.target/i386/pr89902.c: New test.
+	* gcc.target/i386/pr89903.c: Ditto.
+
+2019-03-31  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/83515
+	PR fortran/85797
+	* gfortran.dg/pr85797.f90: New test.
+
+2019-03-30  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/89866
+	Backport from trunk
+	* gfortran.dg/pointer_intent_8.f90: New test.
+
+2019-03-30  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/78865
+	Backport from trunk
+	* gfortran.dg/altreturn_10.f90: New test.
+	* gfortran.dg/whole_file_3.f90: Change dg-warning to dg-error.
+
+2019-03-28  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/89848
+	* gcc.target/i386/pr89848.c: New test.
+
+2019-03-26  Uro Bizjak  <ubizjak@gmail.com>
+
+	PR target/89827
+	* gcc.target/i386/pr89827.c: New test.
+
+2019-03-25  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-03-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/89775
+	* gcc.target/s390/pr89775-1.c: New test.
+	* gcc.target/s390/pr89775-2.c: New test.
+
+2019-03-24  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/71861
+	Backport from trunk
+	* gfortran.dg/interface_abstract_5.f90: New test case.
+
+2019-03-22  Backport from mainline
+
+	2019-03-22  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	* gcc.target/powerpc/mmx-psubd-2.c: Test _m_psubd.
+
+2019-03-21  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR fortran/56408
+	* gcc.target/powerpc/ppc-fortran/ppc-fortran.exp
+	(dg-compile-aux-modules): Fix diagnostic.
+	* gfortran.dg/coarray/caf.exp (dg-compile-aux-modules): Likewise.
+	* gfortran.dg/dg.exp (dg-compile-aux-modules): Likewise.
+
+	PR fortran/56408
+	* gfortran.dg/coarray/caf.exp (dg-compile-aux-modules): Workaround
+	missing nexted dg-test call support in dejaGNU 1.4.4.
+
+	PR fortran/29383
+	* gfortran.dg/ieee/ieee.exp (DEFAULT_FFLAGS): Set the same as in
+	other '*.exp' files.
+
+2019-03-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* c-c++-common/unroll-7.c: New test.
+
+2019-03-18  Martin Sebor  <msebor@redhat.com>
+
+	PR middle-end/88273
+	* gcc.dg/Warray-bounds-38.c: New test.
+
+2019-03-18  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-18  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/89546
+	* gcc.dg/tree-ssa/pr89546.c: New test.
+
+2019-03-17  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/84394
+	Backport from trunk
+	* gfortran.dg/blockdata_11.f90: New test.
+
+2019-03-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2019-03-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/89523
+	* gcc.target/i386/pr89523-1a.c: New test.
+	* gcc.target/i386/pr89523-1b.c: Likewise.
+	* gcc.target/i386/pr89523-2.c: Likewise.
+	* gcc.target/i386/pr89523-3.c: Likewise.
+	* gcc.target/i386/pr89523-4.c: Likewise.
+	* gcc.target/i386/pr89523-5.c: Likewise.
+	* gcc.target/i386/pr89523-6.c: Likewise.
+	* gcc.target/i386/pr89523-7.c: Likewise.
+	* gcc.target/i386/pr89523-8.c: Likewise.
+	* gcc.target/i386/pr89523-9.c: Likewise.
+
+2019-03-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66089
+	Backport from trunk
+	* gfortran.dg/dependency_53.f90: New test.
+	* gfortran.dg/assumed_type_2.f90: Adapted tree dumps.
+	* gfortran.dg/no_arg_check_2.f90: Likewise.
+
+2019-03-16 Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66695
+	PR fortran/77746
+	PR fortran/79485
+	Backport from trunk
+	* gfortran.dg/binding_label_tests_30.f90: New test.
+	* gfortran.dg/binding_label_tests_31.f90: New test.
+	* gfortran.dg/binding_label_tests_32.f90: New test.
+	* gfortran.dg/binding_label_tests_33.f90: New test.
+
+2019-03-15  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-03-06  Richard Biener  <rguenther@suse.de>
+
+	PR testsuite/89551
+	* gcc.dg/uninit-pred-8_b.c: Force logical-op-non-short-circuit
+	the way that makes the testcase PASS.
+
+2019-03-14  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-07  Martin Jambor  <mjambor@suse.cz>
+
+	PR lto/87525
+	* gcc.dg/ipa/ipcp-5.c: New test.
+
+2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89572
+	* gcc.dg/torture/pr89572.c: New testcase.
+
+2019-03-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87673
+	Backport from trunk
+	* gfortran.dg/charlen_17.f90: New test.
+
+2019-03-13  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR target/85860
+	* gcc.target/i386/pr85860.c: New.
+
+2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-03-13  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89677
+	* gcc.dg/torture/pr89677.c: New testcase.
+
+	2019-03-01  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89497
+	* gcc.dg/tree-ssa/reassoc-43.c: Avoid false match in regex.
+	* g++.dg/tree-prof/devirt.C: Scan tracer dump for foldings
+	that happen now earlier.
+
+	2019-02-18  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89296
+	* gcc.dg/uninit-pr89296.c: New testcase.
+
+2019-03-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-03-11  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.target/s390/zvector/vec-addc-u128.c: New test.
+
+2019-03-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-02-07  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.target/s390/zvector/xl-xst-align-1.c: New test.
+	* gcc.target/s390/zvector/xl-xst-align-2.c: New test.
+
+2019-03-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89664
+	* gfortran.dg/pr89664.f90: New testcase.
+
+2019-03-12  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2019-03-08  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* gcc.target/arm/f16_f64_conv_no_dp.c: New test.
+
+	Backport from mainline
+	2019-03-11  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	* gcc.target/arm/f16_f64_conv_no_dp.c: Add arm_fp16_ok effective
+	target.
+
+2019-03-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* c-c++-common/unroll-6.c: New test.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-03-10  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gcc.target/i386/indirect-thunk-extern-7.c: Add -fjump-tables to
+	dg-options.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-03-08  Martin Liska  <mliska@suse.cz>
+
+	PR target/86952
+	* gcc.target/i386/indirect-thunk-7.c: Use jump tables to match
+	scanned pattern.
+	* gcc.target/i386/indirect-thunk-inline-7.c: Likewise.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71544
+	Backport from trunk
+	* gfortran.dg/c_ptr_tests_19.f90: New test.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87734
+	Backport from trunk
+	* gfortran.dg/public_private_module_10.f90: New test.
+
+2019-03-08  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-07  Martin Jambor  <mjambor@suse.cz>
+
+	* g++.dg/ipa/pr88235.C: New test.
+
+2019-03-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89585
+	* g++.dg/asm-qual-3.C: Adjust expected diagnostics.
+
+2019-03-06  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/71203
+	* gfortran.dg/substr_8.f90: New test.
+
+2019-03-06  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/72714
+	Backport from trunk
+	* gfortran.dg/coarray_allocate_11.f90: New test.
+
+2019-03-06  Tamar Christina  <tamar.christina@arm.com>
+
+	Backport from trunk.
+	2019-02-25  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/88530
+	* common/config/aarch64/aarch64-common.c
+	(struct aarch64_option_extension): Add is_synthetic.
+	(all_extensions): Use it.
+	(TARGET_OPTION_INIT_STRUCT): Define hook.
+	(struct gcc_targetm_common): Moved to end.
+	(all_extensions_by_on): New.
+	(opt_ext_cmp, typedef opt_ext): New.
+	(aarch64_option_init_struct): New.
+	(aarch64_contains_opt): New.
+	(aarch64_get_extension_string_for_isa_flags): Output smallest set.
+	* config/aarch64/aarch64-option-extensions.def
+	(AARCH64_OPT_EXTENSION): Explicitly include AES and SHA2 in crypto.
+	(fp, simd, crc, lse, fp16, rcpc, rdma, dotprod, aes, sha2, sha3,
+	sm4, fp16fml, sve):
+	Set is_synthetic to false.
+	(crypto): Set is_synthetic to true.
+	* config/aarch64/driver-aarch64.c (AARCH64_OPT_EXTENSION): Add
+	SYNTHETIC.
+
+2019-03-06  Tamar Christina  <tamar.christina@arm.com>
+
+	Backport from trunk.
+	2019-02-28  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/88530
+	* gcc.target/aarch64/options_set_10.c: New test.
+
+2019-03-06  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport of r268834 from mainline to gcc-8-branch.
+	2019-01-23  Xiong Hu Luo  <luoxhu@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/crypto-builtin-1.c
+	(crypto1_be, crypto2_be, crypto3_be, crypto4_be, crypto5_be):
+	New testcases.
+
+2019-03-05  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-02-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89505
+	* gcc.dg/torture/pr89505.c: New testcase.
+
+2019-03-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89077
+	* gfortran.dg/transfer_simplify_12.f90: New test.
+	* gfortran.dg/substr_simplify.f90: New test.
+
+2019-03-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/77583
+	* gfortran.dg/pr77583.f90: New test.
+
+2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/89174
+	Backport from trunk
+	* gfortran.dg/allocate_with_mold_3.f90: New test.
+
+2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87689
+	Backport from trunk
+	* gfortran.dg/lto/20091028-1_0.f90: Add -Wno-lto-type-mismatch to
+	options.
+	* gfortran.dg/lto/20091028-2_0.f90: Likewise.
+	* gfortran.dg/lto/pr87689_0.f: New file.
+	* gfortran.dg/lto/pr87689_1.f: New file.
+	* gfortran.dg/altreturn_9_0.f90: New file.
+	* gfortran.dg/altreturn_9_1.f90: New file.
+
+2019-03-02  Jerry DeLisle <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84387
+	* gfortran.dg/dtio_34.f90: New test.
+
+2019-03-02  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89516
+	* gfortran.dg/pr89492.f90: Adjust testcase.
+	* gfortran.dg/transfer_check_5.f90: New test.
+
+	PR fortran/89492
+	* gfortran.dg/pr89492.f90: New test.
+
+	PR fortran/89266
+	PR fortran/88326
+	* gfortran.dg/pr89266.f90: New test.
+	* gfortran.dg/pr88326.f90: New test.
+
+2019-02-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20190228-1.c: New test.
+
+2019-02-28  Li Jia He  <helijia@linux.ibm.com>
+
+	Backport from trunk
+	2019-02-20  Li Jia He  <helijia@linux.ibm.com>
+
+	PR target/88100
+	* gcc/testsuite/gcc.target/powerpc/pr88100.c: New testcase.
+
+2019-02-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt77.adb: New test.
+	* gnat.dg/opt77_pkg.ad[sb]: New helper.
+
+2019-02-23  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/86119
+	Backport from trunk
+	* gfortran.dg/warn_conversion_11.f90: New test.
+
+2019-02-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/88117
+	* gfortran.dg/deferred_character_32.f90: New test
+
+2019-02-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71066
+	Backport from trunk
+	* gfortran.dg/coarray_data_1.f90: New test.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: gcc/testsuite/g++.dg/ubsan/vptr-14.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ubsan/vptr-14.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/ubsan/vptr-14.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,18 @@
+// PR sanitizer/89869
+// { dg-do run }
+// { dg-options "-fsanitize=vptr -fno-sanitize-recover=vptr" }
+
+struct S { S *s = 0; virtual ~S () {} };
+
+void
+foo (S *x, S *y)
+{
+  (x->s ? y : x) = x->s;
+}
+
+int
+main ()
+{
+  S a;
+  foo (&a, 0);
+}
Index: gcc/testsuite/g++.dg/lookup/missing-std-include-8.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/lookup/missing-std-include-8.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/lookup/missing-std-include-8.C	(.../branches/gcc-8-branch)
@@ -13,6 +13,15 @@
   // { dg-error "expected primary-expression before '\\)' token" "" { target *-*-* } .-3 }
 }
 
+template<class T>
+void test_make_unique ()
+{
+  std::make_unique<T>(); // { dg-error "'make_unique' is not a member of 'std'" }
+  // { dg-message "'std::make_unique' is only available from C\\+\\+14 onwards" "" { target *-*-* } .-1 }
+  // { dg-error "expected primary-expression before '>' token" "" { target *-*-* } .-2 }
+  // { dg-error "expected primary-expression before '\\)' token" "" { target *-*-* } .-3 }
+}
+
 void test_array ()
 {
   std::array a; // { dg-error "'array' is not a member of 'std'" }
Index: gcc/testsuite/g++.dg/lookup/missing-std-include-5.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/lookup/missing-std-include-5.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/lookup/missing-std-include-5.C	(.../branches/gcc-8-branch)
@@ -1,2 +1,3 @@
+// { dg-do compile { target c++14 } }
 using namespace std::complex_literals; // { dg-error "" }
 // { dg-message "#include <complex>" "" { target *-*-* } .-1 }
Index: gcc/testsuite/g++.dg/lookup/missing-std-include-6.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/lookup/missing-std-include-6.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/lookup/missing-std-include-6.C	(.../branches/gcc-8-branch)
@@ -11,15 +11,6 @@
   // { dg-error "expected primary-expression before '\\)' token" "" { target *-*-* } .-3 }
 }
 
-template<class T>
-void test_make_unique ()
-{
-  auto p = std::make_unique<T>(); // { dg-error "'make_unique' is not a member of 'std'" }
-  // { dg-message "'#include <memory>'" "" { target *-*-* } .-1 }
-  // { dg-error "expected primary-expression before '>' token" "" { target *-*-* } .-2 }
-  // { dg-error "expected primary-expression before '\\)' token" "" { target *-*-* } .-3 }
-}
-
 std::shared_ptr<int> test_shared_ptr; // { dg-error "'shared_ptr' in namespace 'std' does not name a template type" }
 // { dg-message "'#include <memory>'" "" { target *-*-* } .-1 }
 
Index: gcc/testsuite/g++.dg/warn/conv5.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/warn/conv5.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/warn/conv5.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,11 @@
+// PR c++/89876
+// { dg-do compile { target c++11 } }
+// { dg-prune-output "sorry" }
+
+template <typename T>
+T f (T, char*);
+
+template <typename T>
+decltype (f (T (), "")) g (T) { return ""; } // { dg-error "invalid conversion" }
+
+void h () { g (0); }
Index: gcc/testsuite/g++.dg/asan/pr90570.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/asan/pr90570.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/asan/pr90570.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,18 @@
+/* PR sanitizer/90570 */
+/* { dg-do run } */
+
+#include <vector>
+
+struct stru
+{
+  std::vector<int> v{1,2,3,4};
+  int i{5};
+};
+
+int main()
+{
+  stru s1;
+  stru s2;
+
+  return 0;
+}
Index: gcc/testsuite/g++.dg/opt/pr90026.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/opt/pr90026.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/opt/pr90026.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,24 @@
+// PR rtl-optimization/90026
+// { dg-do compile }
+// { dg-options "-fnon-call-exceptions -ftracer -O2 -w" }
+
+typedef __SIZE_TYPE__ size_t;
+struct S { int *b; ~S () { delete b; } };
+void bar ();
+char c[sizeof (int)];
+
+void *
+operator new (size_t, void *)
+{
+  __builtin_unreachable ();
+}
+
+void
+foo ()
+{
+  S a;
+  if (a.b)
+    a.b = new int ();
+  bar ();
+  new (c) int ();
+}
Index: gcc/testsuite/g++.dg/opt/pr90187.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/opt/pr90187.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/opt/pr90187.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,15 @@
+// PR target/90187
+// { dg-do compile }
+// { dg-options "-Ofast -ffloat-store" }
+
+double a[64];
+double *foo (void);
+
+void
+bar (int x, const double *y)
+{
+  int i;
+  for (i = 0; i < x; i++)
+    if (y[i] < a[i])
+      a[i] = y[i];
+}
Index: gcc/testsuite/g++.dg/opt/pr90090.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/opt/pr90090.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/opt/pr90090.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,19 @@
+// PR tree-optimization/90090
+// { dg-do compile }
+// { dg-options "-Ofast -fno-associative-math -fsignaling-nans -fno-tree-dce -fnon-call-exceptions" }
+
+double bar (double, double, double, double, double);
+double baz ();
+
+double
+foo (double a)
+{
+  try
+    {
+      return bar (1.0/a, 2.0/a, 4.0/a, 8.0/a, 16.0/a);
+    }
+  catch (...)
+    {
+      return baz ();
+    }
+}
Index: gcc/testsuite/g++.dg/tree-prof/devirt.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tree-prof/devirt.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/tree-prof/devirt.C	(.../branches/gcc-8-branch)
@@ -1,5 +1,5 @@
 /* PR ipa/88561 */
-/* { dg-options "-O3 -fdump-tree-dom3-details" } */
+/* { dg-options "-O3 -fdump-tree-tracer-details -fdump-tree-dom3-details" } */
 
 struct nsISupports
 {
@@ -121,6 +121,6 @@
     __builtin_abort ();
 }
 
-/* { dg-final-use-not-autofdo { scan-tree-dump-times "folding virtual function call to virtual unsigned int mozPersonalDictionary::_ZThn16" 1 "dom3" { target { lp64 || llp64 } } } } */
-/* { dg-final-use-not-autofdo { scan-tree-dump-times "folding virtual function call to virtual unsigned int mozPersonalDictionary::_ZThn8" 1 "dom3" { target ilp32 } } } */
-/* { dg-final-use-not-autofdo { scan-tree-dump-times "folding virtual function call to virtual unsigned int mozPersonalDictionary::AddRef" 1 "dom3" } } */
+/* { dg-final-use-not-autofdo { scan-tree-dump-times "folding virtual function call to virtual unsigned int mozPersonalDictionary::_ZThn16" 1 "tracer" { target { lp64 || llp64 } } } } */
+/* { dg-final-use-not-autofdo { scan-tree-dump-times "folding virtual function call to virtual unsigned int mozPersonalDictionary::_ZThn8" 1 "tracer" { target ilp32 } } } */
+/* { dg-final-use-not-autofdo { scan-tree-dump-times "folding virtual function call to virtual unsigned int mozPersonalDictionary::AddRef" 1 "tracer" } } */
Index: gcc/testsuite/g++.dg/pr91173.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/pr91173.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/pr91173.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,45 @@
+class a {
+  int b;
+  void *c;
+
+public:
+  bool aa();
+  int &ab() {
+    if (aa()) {
+      void *d(c);
+      return static_cast<int *>(d)[b];
+    }
+    return *(int *)0;
+  }
+};
+typedef enum {E} e;
+class f : public a {
+  int g;
+
+public:
+  int ac() {
+    if (g)
+      return 1;
+    return ac();
+  }
+};
+int *ad;
+struct h {
+  static int ae(e, int *m) {
+    f ag;
+    int *ah;
+    while (!0) {
+      ad = &ag.ab();
+      ah = ad + ag.ac();
+      while (ad < ah)
+        *m = *ad++;
+    }
+  }
+};
+template <class, class>
+void i(int *, int *, int, int *, e n, int *o) {
+  h::ae(n, o);
+}
+int aq, ar, as, at, au;
+void aw() { i<int, bool>(&aq, &ar, as, &at, (e)0, &au); }
+
Index: gcc/testsuite/g++.dg/asm-qual-3.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/asm-qual-3.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/asm-qual-3.C	(.../branches/gcc-8-branch)
@@ -2,11 +2,11 @@
 // { dg-do compile }
 // { dg-options "-std=gnu++98" }
 
-asm const ("");    // { dg-error {expected '\(' before 'const'} }
-asm volatile (""); // { dg-error {expected '\(' before 'volatile'} }
+asm const ("");    // { dg-error {'const' is not an asm qualifier} }
+asm volatile ("");
 asm restrict (""); // { dg-error {expected '\(' before 'restrict'} }
-asm inline ("");   // { dg-error {expected '\(' before 'inline'} }
-asm goto ("");     // { dg-error {expected '\(' before 'goto'} }
+asm inline ("");   // { dg-error {asm qualifier outside of function body} }
+asm goto ("");     // { dg-error {asm qualifier outside of function body} }
 
 // There are many other things wrong with this code, so:
 // { dg-excess-errors "" }
Index: gcc/testsuite/g++.dg/cpp0x/using-enum-3.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/using-enum-3.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/using-enum-3.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,21 @@
+// PR c++/89511
+// { dg-do compile { target c++11 } }
+
+void f ()
+{
+  enum e { a };
+  using e::a; // { dg-error "not a namespace or unscoped enum" }
+}
+
+struct S {
+  enum E { A };
+  using E::A; // { dg-error "type .S. is not a base type for type .S." }
+};
+
+namespace N {
+  enum E { B };
+}
+
+struct T {
+  using N::E::B; // { dg-error "using-declaration for non-member at class scope" }
+};
Index: gcc/testsuite/g++.dg/cpp0x/lambda/lambda-defarg9.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-defarg9.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-defarg9.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,10 @@
+// PR c++/89422
+// { dg-do compile { target c++11 } }
+// { dg-additional-options -g }
+
+template <int> struct S
+{
+  friend void foo (int a = []{ return 0; }()) {}
+  int b;
+};
+S<0> t;
Index: gcc/testsuite/g++.dg/cpp0x/implicit16.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/implicit16.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/implicit16.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,37 @@
+// PR c++/89381
+// { dg-do compile { target c++11 } }
+
+template<typename T>
+struct base
+{
+  base() { }
+  base(const base&) { }
+  base(base&&) { }
+  base& operator=(const base&) { return *this; }
+  base& operator=(base&&) { return *this; }
+};
+
+struct foo : base<int>
+{
+    using base<int>::base;
+    using base<int>::operator=;
+};
+
+//using workaround = decltype(foo{*static_cast<foo const*>(0)});
+
+struct bar
+{
+    bar& operator=(foo ve)
+    {
+        value = ve;
+        return *this;
+    }
+
+    foo value;
+};
+
+int main()
+{
+    foo a;
+    foo b{a};
+}
Index: gcc/testsuite/g++.dg/cpp0x/nullptr41.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/nullptr41.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/nullptr41.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,19 @@
+// PR c++/89212
+// { dg-do compile { target c++11 } }
+
+template <int, typename T> using enable_if_t = int;
+
+template<typename U, typename W, typename Y, class X, W(X::*foo)() = nullptr>
+struct p
+{
+    template<U(Y::*fun)() = foo, typename T = enable_if_t<nullptr == fun, int>>
+    p(T) { }
+    p() = default;
+};
+
+struct A
+{
+    p<void, void, A, A> i = 1;
+    void bar();
+    p<void, void, A, A, &A::bar> j;
+};
Index: gcc/testsuite/g++.dg/cpp0x/decltype-tid1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/decltype-tid1.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/decltype-tid1.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,9 @@
+// PR c++/87513
+// { dg-do compile { target c++11 } }
+
+struct A { template <long> void foo (); };
+template <long t> auto bar () -> decltype (&A::foo<t>);
+void foo ()
+{
+  bar<0> ();
+}
Index: gcc/testsuite/g++.dg/cpp0x/rv-conv2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/rv-conv2.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/rv-conv2.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,18 @@
+// PR c++/89705
+// { dg-do compile { target c++11 } }
+
+struct W { operator const volatile int(); };
+const int& rci = W();
+
+struct X { operator const int(); };
+int&& rri = X();
+
+struct Y { operator volatile int(); };
+int&& rri2 = Y();
+
+struct Z { operator const volatile int(); };
+volatile int&& rri3 = Z();
+
+enum E { A };
+struct S { operator const E(); };
+E&& rre = S();
Index: gcc/testsuite/g++.dg/cpp0x/initlist-value4.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/initlist-value4.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/initlist-value4.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,12 @@
+// PR c++/88857
+// { dg-do compile { target c++11 } }
+
+class S { int a; };
+void foo (const S &, int);
+
+template <int N>
+void
+bar ()
+{
+  foo ({}); // { dg-error "too few arguments to function" }
+}
Index: gcc/testsuite/g++.dg/cpp0x/pr89403.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/pr89403.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/pr89403.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,18 @@
+// PR c++/89403
+// { dg-do compile { target c++11 } }
+// { dg-options "-Os -fsyntax-only" }
+
+template <typename T>
+struct A : T {
+  constexpr A() : T() { }
+};
+
+template <typename T>
+struct B {
+  A<T> b;
+  constexpr B() { }
+};
+
+struct C { struct {} s; };
+constexpr B<C> b{};
+constexpr C c = b.b;
Index: gcc/testsuite/g++.dg/cpp0x/nullptr40.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/nullptr40.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/nullptr40.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,19 @@
+// PR c++/89212
+// { dg-do compile { target c++11 } }
+
+template <int, typename T> using enable_if_t = int;
+
+template<class X, void(X::*foo)() = nullptr>
+struct p
+{
+    template<void(X::*fun)() = foo, typename T = enable_if_t<nullptr == fun, int>>
+    p(T) { }
+    p() = default;
+};
+
+struct A
+{
+    p<A> i = 1;
+    void bar();
+    p<A, &A::bar> j;
+};
Index: gcc/testsuite/g++.dg/eh/o32-fp.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/eh/o32-fp.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/eh/o32-fp.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,47 @@
+// Test whether call saved float are restored properly for O32 ABI
+// { dg-do run { target { { { mips*-*-linux* } && hard_float } && { ! mips64 } } } }
+// { dg-options "-O2" }
+
+void __attribute__((noinline))
+bar (void)
+{
+  throw 1;
+}
+
+void __attribute__((noinline))
+foo (void)
+{
+  register double f20 __asm__ ("f20") = 0.0;
+  register double f22 __asm__ ("f22") = 0.0;
+  register double f24 __asm__ ("f24") = 0.0;
+  register double f26 __asm__ ("f26") = 0.0;
+  register double f28 __asm__ ("f28") = 0.0;
+  register double f30 __asm__ ("f30") = 0.0;
+  __asm__ __volatile__("":"+f"(f20),"+f"(f22),"+f"(f24),"+f"(f26),"+f"(f30));
+  bar ();
+}
+
+int
+main (void)
+{
+  register double f20 __asm__ ("f20") = 12.0;
+  register double f22 __asm__ ("f22") = 13.0;
+  register double f24 __asm__ ("f24") = 14.0;
+  register double f26 __asm__ ("f26") = 15.0;
+  register double f28 __asm__ ("f28") = 16.0;
+  register double f30 __asm__ ("f30") = 17.0;
+
+  try
+    {
+      foo ();
+    }
+  catch (...)
+    {
+      __asm__ ("":"+f"(f20),"+f"(f22),"+f"(f24),"+f"(f26),"+f"(f30));
+    }
+
+  if (f20 != 12.0 || f22 != 13.0 || f24 != 14.0
+      || f26 != 15.0 || f28 != 16.0 || f30 != 17.0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/g++.dg/torture/pr89698.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr89698.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr89698.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,28 @@
+/* { dg-do run } */
+
+extern "C" void abort (void);
+
+class A {
+    virtual void f(){};
+public:
+    int x;
+    A(int in): x(in) {};
+};
+
+class B: public A {
+public:
+    int y;
+    B(int in):A(in-1), y(in) {};
+};
+
+int test(void)
+{
+  int res;
+  B b(2);
+  A* bp = &b;
+  void* vp = dynamic_cast<void*>(bp);
+  if (((A*)vp)->x == 1 && ((B*)vp)->y == 2)
+    return 1;
+  return 0;
+}
+int main() { if (test() != 1) abort (); return 0; }
Index: gcc/testsuite/g++.dg/ipa/pr88235.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr88235.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr88235.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,55 @@
+// { dg-do compile }
+// { dg-options "-O1 -fdevirtualize -finline-small-functions -fipa-cp -fipa-cp-clone --param ipa-cp-eval-threshold=125 --param max-inline-insns-single=4" }
+
+extern "C" int printf (const char *, ...);
+enum E { vf_request, vf_event } want;
+
+int errs = 0;
+
+class ivResource {
+public:
+  virtual ~ivResource () { }
+};
+
+class ivHandler   : public ivResource   {
+public:
+  virtual void event() { }
+};
+
+class ivGlyph   : public ivResource   {
+public:
+  virtual ~ivGlyph  () { }
+  virtual void request () {
+    if (want!=vf_request)
+      ++errs;
+  }
+};
+
+class ItemView : public ivGlyph, public ivHandler {
+public:
+  virtual void event () {
+    if (want!=vf_event)
+      ++errs;
+  }
+} a;
+
+ivGlyph *bar() {
+  return &a;
+}
+
+ivHandler *bar2() {
+  return &a;
+}
+
+int main() {
+  want=vf_request;
+  bar()->request();
+  want=vf_event;
+  bar2()->event();
+  if (errs) {
+    printf("FAIL\n");
+    return 1;
+  }
+  printf("PASS\n");
+  return 0;
+}
Index: gcc/testsuite/g++.dg/ipa/pr89693.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr89693.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr89693.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,52 @@
+// Copyright (C) 2005 Free Software Foundation, Inc.
+// Contributed by Nathan Sidwell 4 Apr 2005 <nathan@codesourcery.com>
+// Re-purposed to check for re-rurgesnce of PR 89693 in 2019.
+
+// { dg-do compile }
+// { dg-options "-O3 -fno-ipa-icf-functions" }
+
+// Origin: yanliu@ca.ibm.com
+//         nathan@codesourcery.com
+
+struct A {
+  virtual void One ();
+};
+struct B  {
+  virtual B *Two ();
+  virtual B &Three ();
+};
+
+struct C : A, B
+{
+  virtual C *Two ();
+  virtual C &Three ();
+};
+void A::One () {}
+B *B::Two()    {return this;}
+B &B::Three()    {return *this;}
+C *C::Two ()   {return 0;}
+C &C::Three ()   {return *(C *)0;}
+
+B *Foo (B *b)
+{
+  return b->Two ();
+}
+
+B &Bar (B *b)
+{
+  return b->Three ();
+}
+
+int main ()
+{
+  C c;
+
+  /* We should not adjust a null pointer.  */
+  if (Foo (&c))
+    return 1;
+  /* But we should adjust a (bogus) null reference.  */
+  if (!&Bar (&c))
+    return 2;
+
+  return 0;
+}
Index: gcc/testsuite/g++.dg/cet-notrack-1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cet-notrack-1.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cet-notrack-1.C	(.../branches/gcc-8-branch)
@@ -1,7 +1,7 @@
 /* { dg-do compile { target i?86-*-* x86_64-*-* } } */
 /* { dg-options "-fcf-protection" } */
 /* { dg-final { scan-assembler "endbr32|endbr64" } } */
-/* { dg-final { scan-assembler-times "\tcall\[ \t]+puts" 2 } } */
+/* { dg-final { scan-assembler-times "\tcall\[ \t]+_?puts" 2 } } */
 /* { dg-final { scan-assembler-times "notrack call\[ \t]+" 1 } } */
 #include <stdio.h>
 
Index: gcc/testsuite/g++.dg/cpp1y/var-templ61.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/var-templ61.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/var-templ61.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,20 @@
+// PR c++/89512
+// { dg-do compile { target c++14 } }
+
+struct A {
+  template <typename T>
+  static const int a = 0;
+};
+
+struct B {
+  template <typename T>
+  static int foo ()
+  {
+    return T::a;		// { dg-error "missing template arguments" }
+  }
+};
+
+int bar ()
+{
+  return B::foo<A> ();		// { dg-message "required from here" }
+}
Index: gcc/testsuite/g++.dg/cpp1y/pr89767.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/pr89767.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/pr89767.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,32 @@
+// PR c++/89767
+// { dg-do compile { target c++14 } }
+// { dg-options "-O2 -Wall" }
+
+template <typename d> struct e { using g = d; };
+template <typename d, template <typename> class> using h = e<d>;
+template <typename d, template <typename> class i>
+using j = typename h<d, i>::g;
+template <typename c> int k(c);
+template <typename...> class au;
+struct l { template <typename c> using m = typename c::f; };
+struct s : l { using af = j<au<int, int> *, m>; };
+template <unsigned long, typename> struct o;
+template <long p, typename c> using q = typename o<p, c>::g;
+template <typename> struct r;
+template <typename c> struct r<c *> { typedef c aj; };
+template <typename ak, typename> struct al { typename r<ak>::aj operator*(); void operator++(); };
+template <typename am, typename an, typename ao>
+bool operator!=(al<am, ao>, al<an, ao>);
+template <unsigned long, typename...> struct ap;
+template <unsigned long aq, typename ar, typename... as>
+struct ap<aq, ar, as...> : ap<1, as...> {};
+template <unsigned long aq, typename ar> struct ap<aq, ar> {};
+template <typename... at> class au : public ap<0, at...> {};
+template <unsigned long p, typename ar, typename... as>
+struct o<p, au<ar, as...>> : o<p - 1, au<as...>> {};
+template <typename ar, typename... as> struct o<0, au<ar, as...>> { typedef ar g; };
+template <long p, typename ar> constexpr ar av(ap<p, ar> __t) { return ar (); }
+template <int p, typename... at> constexpr q<p, au<at...>> aw(au<at...> __t) { av<p>(__t); return q<p, au<at...>> (); }
+struct bg { typedef s::af af; };
+struct F { typedef al<bg::af, int> bk; bk begin(); bk end(); };
+void bo() { int t = 0; F cv; for (auto bp : cv) [t, n = k(aw<1>(bp))] {}; }
Index: gcc/testsuite/g++.dg/cpp1y/lambda-init18.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/lambda-init18.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/lambda-init18.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,12 @@
+// PR c++/89767
+// { dg-do compile { target c++14 } }
+
+void bar (int);
+
+void
+foo ()
+{
+  int x = 0;
+  auto z = [x, y = [x] { bar (x); }] { y (); bar (x); };
+  z ();
+}
Index: gcc/testsuite/g++.dg/cpp1y/lambda-init19.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/lambda-init19.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/lambda-init19.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,15 @@
+// PR c++/89767
+// { dg-do compile { target c++14 } }
+
+void bar (int);
+
+void
+foo ()
+{
+  int x = 0;
+  int a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0;
+  auto z = [x, y = [x] { bar (x); }, x] { y (); bar (x); };	// { dg-error "already captured 'x' in lambda expression" }
+  auto w = [x, a, b, c, d, y = [x] { bar (x); }, e, f, g, h, x] { y (); bar (x + a + b + c + d + e + f + g + h); };	// { dg-error "already captured 'x' in lambda expression" }
+  z ();
+  w ();
+}
Index: gcc/testsuite/g++.dg/cpp1z/constexpr-if28.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1z/constexpr-if28.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1z/constexpr-if28.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,11 @@
+// PR c++/89576
+// { dg-do compile { target c++17 } }
+
+template <class T>
+void foo()
+{
+    constexpr int x = 0;
+    [&] {
+        if constexpr (x) {}
+    };
+}
Index: gcc/testsuite/g++.dg/cpp1z/decomp49.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1z/decomp49.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1z/decomp49.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,14 @@
+// PR c++/82075
+// { dg-do run { target c++11 } }
+// { dg-options "" }
+
+struct B { };
+struct D : B { int i; };
+
+int
+main ()
+{
+  auto [i] = D{};	// { dg-warning "only available with" "" { target c++14_down } }
+  if (i != 0)
+    __builtin_abort ();
+}
Index: gcc/testsuite/g++.dg/cpp1z/aggr-base7.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1z/aggr-base7.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1z/aggr-base7.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,8 @@
+// PR c++/88690
+// { dg-do compile { target c++11 } }
+
+struct A { int a = 1; };
+struct B { int b = 0; };
+struct C { C() = default; C (const C&) = delete; };
+struct D : public B, public C {};
+struct E : A { D f; } g{};
Index: gcc/testsuite/g++.dg/cpp1z/inline-var5.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1z/inline-var5.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1z/inline-var5.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,27 @@
+// PR c++/89405
+// { dg-do compile { target c++17 } }
+// { dg-options "-fno-weak" }
+
+template <int N>
+struct S
+{
+  static constexpr int a = N;	// { dg-warning "semantics of inline variable" }
+};				// { dg-message "you can work around this" "" { target *-*-* } .-1 }
+
+const int *x = &S<0>::a;
+// PR c++/87921
+// { dg-do compile { target c++17 } }
+
+template <class H>
+struct X
+{
+  static inline long x[] = { 1L };
+  long foo () { return x[0]; }
+};
+
+void
+bar ()
+{
+  class L {};
+  X<L> v {};
+}
Index: gcc/testsuite/g++.dg/cpp1z/aggr-base8.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1z/aggr-base8.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1z/aggr-base8.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,48 @@
+// PR c++/89214
+// { dg-do compile { target c++17 } }
+
+struct A
+{
+  A (int);
+};
+
+struct BB
+{
+  A a;
+};
+
+struct B : BB
+{
+};
+
+void
+foo ()
+{
+  B b1 = {42};
+  B b2 = {{42}};
+  B b3 = {{{42}}};
+
+  B b4 = B{42};
+  B b5 = B{{42}};
+  B b6 = B{{{42}}};
+
+  B b7 = {B{42}};
+  B b8 = {B{{42}}};
+  B b9 = {B{{{42}}}};
+
+  B b10 = {{B{42}}}; // { dg-warning "initializing a base class of type .BB. results in object slicing" }
+  B b11 = {{B{{42}}}}; // { dg-warning "initializing a base class of type .BB. results in object slicing" }
+  B b12 = {{B{{{42}}}}}; // { dg-warning "initializing a base class of type .BB. results in object slicing" }
+
+  B bb1{42};
+  B bb2{{42}};
+  B bb3{{{42}}};
+
+  B bb7{B{42}};
+  B bb8{B{{42}}};
+  B bb9{B{{{42}}}};
+
+  B bb10{{B{42}}}; // { dg-warning "initializing a base class of type .BB. results in object slicing" }
+  B bb11{{B{{42}}}}; // { dg-warning "initializing a base class of type .BB. results in object slicing" }
+  B bb12{{B{{{42}}}}}; // { dg-warning "initializing a base class of type .BB. results in object slicing" }
+}
Index: gcc/testsuite/g++.dg/cpp1z/class-deduction62.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1z/class-deduction62.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1z/class-deduction62.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,22 @@
+// PR c++/88419
+// { dg-do compile { target c++17 } }
+
+template<class> struct ref_view {
+  template<class T> ref_view(T&&);
+};
+
+template<class R> ref_view(R&) -> ref_view<R>;
+
+struct ref_fn {
+  template<class R> auto operator()(R r) const
+    noexcept(noexcept(ref_view{r}));
+};
+
+template<class R> struct indirect_view {
+  indirect_view(R);
+};
+
+struct indirect_fn {
+  template<class R> auto operator()(R r) const
+    noexcept(noexcept(indirect_view{r}));
+};
Index: gcc/testsuite/g++.dg/cpp1z/aggr-base9.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1z/aggr-base9.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1z/aggr-base9.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,33 @@
+// PR c++/89214
+// { dg-do compile { target c++17 } }
+
+struct B {
+  int c;
+};
+
+struct D : B { };
+
+void
+foo ()
+{
+  D d1 = {42};
+  D d2 = {{42}};
+  
+  D d4 = D{42};
+  D d5 = D{{42}};
+ 
+  D d7 = {D{42}};
+  D d8 = {D{{42}}};
+
+  D d10 = {{D{42}}}; // { dg-warning "initializing a base class of type .B. results in object slicing" }
+  D d11 = {{D{{42}}}}; // { dg-warning "initializing a base class of type .B. results in object slicing" }
+
+  D dd1{42};
+  D dd2{{42}};
+  
+  D dd7{D{42}};
+  D dd8{D{{42}}};
+
+  D dd10{{D{42}}}; // { dg-warning "initializing a base class of type .B. results in object slicing" }
+  D dd11{{D{{42}}}}; // { dg-warning "initializing a base class of type .B. results in object slicing" }
+}
Index: gcc/testsuite/g++.dg/cpp1z/class-deduction63.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1z/class-deduction63.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1z/class-deduction63.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,11 @@
+// PR c++/88869
+// { dg-do compile { target c++17 } }
+
+template <typename> struct B;
+template <> struct B<int> {
+  template <typename T> struct C {
+    T e;
+    C (T f) : e(f) {}
+  };
+  void foo () { C c (42); }
+};
Index: gcc/testsuite/g++.dg/cpp1z/class-deduction64.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1z/class-deduction64.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1z/class-deduction64.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,9 @@
+// PR c++/88820
+// { dg-do compile { target c++17 } }
+
+template <int> struct S;
+
+template <S> struct W {
+  template <typename> static int foo();
+  bool b = foo<int>();
+};
Index: gcc/testsuite/g++.dg/cpp1z/class-deduction58.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1z/class-deduction58.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1z/class-deduction58.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,16 @@
+// PR c++/86098
+// { dg-additional-options -std=c++17 }
+
+template <class _Res> class future;
+template <class T> T&& declval();
+
+template<template <class...> class T>
+struct construct_deduced {
+  template <class... AN>
+  using deduced_t = decltype(T{declval<AN>()...});
+  template<class... AN>
+  deduced_t<AN...> operator()(AN&&... an) const;
+};
+
+template<class T>
+future<T> future_from(T singleSender);
Index: gcc/testsuite/g++.dg/cpp1z/fold-lambda3.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1z/fold-lambda3.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1z/fold-lambda3.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,19 @@
+// PR c++/88183
+// { dg-do compile { target c++17 } }
+
+struct A { int i; };
+
+template <class T> T& g(T);
+
+template <class U, class... Vs>
+void f(U u, Vs... vs)
+{ 
+  [vs...](auto x) {
+    (g(x) .* ... .* vs) = 42;
+  }(u);
+}
+
+int main()
+{
+  f(A(), &A::i);
+}
Index: gcc/testsuite/g++.dg/ext/flexary34.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ext/flexary34.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/ext/flexary34.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,10 @@
+// PR c++/87148
+// { dg-do compile }
+// { dg-options "-pedantic" }
+
+struct Tst { int i; char t[]; };	// { dg-warning "forbids flexible array member" }
+
+Tst t {};				// { dg-warning "extended initializer lists only available with" "" { target c++98_only } }
+Tst u = Tst();
+void foo () { Tst u = {}; }
+Tst *bar () { return new Tst (); }
Index: gcc/testsuite/g++.dg/ext/90532.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ext/90532.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/ext/90532.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,27 @@
+// { dg-do compile { target c++11 } }
+// PR c++/90532
+static_assert( !__is_constructible(int[]), "" );
+static_assert( !__is_constructible(int[], int), "" );
+static_assert( !__is_constructible(int[], int[]), "" );
+static_assert( !__is_trivially_constructible(int[]), "" );
+static_assert( !__is_trivially_constructible(int[], int), "" );
+static_assert( !__is_trivially_constructible(int[], int[]), "" );
+static_assert( !__is_trivially_constructible(int[], int(&)[]), "" );
+static_assert( !__is_trivially_constructible(int[], void), "" );
+struct A { };
+static_assert( !__is_constructible(A[]), "" );
+static_assert( !__is_constructible(A[], const A&), "" );
+static_assert( !__is_constructible(A[], const A[]), "" );
+static_assert( !__is_trivially_constructible(A[]), "" );
+static_assert( !__is_trivially_constructible(A[], const A&), "" );
+static_assert( !__is_trivially_constructible(A[], const A[]), "" );
+static_assert( !__is_trivially_constructible(A[], A(&)[]), "" );
+static_assert( !__is_trivially_constructible(A[], void), "" );
+struct B { B(); };
+static_assert( !__is_constructible(B[]), "" );
+static_assert( !__is_constructible(B[], const B&), "" );
+static_assert( !__is_trivially_constructible(B[]), "" );
+static_assert( !__is_trivially_constructible(B[], const B&), "" );
+static_assert( !__is_trivially_constructible(B[], const B[]), "" );
+static_assert( !__is_trivially_constructible(B[], B(&)[]), "" );
+static_assert( !__is_trivially_constructible(B[], void), "" );
Index: gcc/testsuite/g++.dg/ext/instantiate2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ext/instantiate2.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/ext/instantiate2.C	(.../branches/gcc-8-branch)
@@ -8,8 +8,7 @@
 template <class T> T A<T>::t = 0;
 static template struct A<int>;
 
-// { dg-final { scan-assembler "\n_?_ZN1AIiE1tE(:|\n|\t)" { target { ! *-*-darwin* } } } }
-// { dg-final { scan-assembler ".zerofill __DATA,__pu_bss2,__ZN1AIiE1tE" { target *-*-darwin* } } } 
+// { dg-final { scan-assembler "\n_?_ZN1AIiE1tE(:|\n|\t)" } }
 void test_int() { A<int>::t = 42; }
 
 // { dg-final { scan-assembler-not "\n_?_ZN1AIcE1tE(:|\n|\t)" } }
Index: gcc/testsuite/g++.dg/ext/asm15.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ext/asm15.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/ext/asm15.C	(.../branches/gcc-8-branch)
@@ -6,5 +6,6 @@
 void
 foo (S &s)
 {
-  __asm volatile ("" : "+r" (s) : : "memory");	// { dg-error "" }
+  __asm volatile ("" : "+r" (s) : : "memory");	// { dg-error "impossible constraint" }
+						// { dg-error "must stay in memory" "" { target *-*-* } .-1 }
 }
Index: gcc/testsuite/g++.dg/ext/asm16.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ext/asm16.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/ext/asm16.C	(.../branches/gcc-8-branch)
@@ -6,5 +6,6 @@
 void
 foo ()
 {
-  __asm volatile ("" : "=r" (s) : : "memory");	// { dg-error "" }
+  __asm volatile ("" : "=r" (s) : : "memory");	// { dg-error "impossible constraint" }
+						// { dg-error "must stay in memory" "" { target *-*-* } .-1 }
 }
Index: gcc/testsuite/g++.dg/ext/asm17.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ext/asm17.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/ext/asm17.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,11 @@
+// PR target/89752
+// { dg-do compile }
+
+struct A { A (); ~A (); short c; };
+
+void
+foo ()
+{
+  A a0, a1;
+  __asm volatile ("" : "+rm" (a0), "+rm" (a1));
+}
Index: gcc/testsuite/g++.dg/ext/vector37.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ext/vector37.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/ext/vector37.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,29 @@
+// PR c++/90810
+// { dg-do run }
+
+void
+foo (float x, float y)
+{
+  typedef float __attribute__ ((__vector_size__ (4 * sizeof (float)), __may_alias__)) V;
+  const V a = { x, x, x, x }, b = { y, y, y, y };
+  const V c = a / b;
+  if (c[0] != 6.0f || c[1] != 6.0f || c[2] != 6.0f || c[3] != 6.0f)
+    __builtin_abort ();
+}
+
+void
+bar (float y)
+{
+  typedef float __attribute__ ((__vector_size__ (4 * sizeof (float)), __may_alias__)) V;
+  const V a = { 7.0f, 8.0f, 9.0f, 10.0f }, b = { 1.0f, 2.0f, 3.0f, y };
+  const V c = a / b;
+  if (c[0] != 7.0f || c[1] != 4.0f || c[2] != 3.0f || c[3] != 5.0f)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  foo (12.0f, 2.0f);
+  bar (2.0f);
+}
Index: gcc/testsuite/g++.dg/gomp/pr89796.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/gomp/pr89796.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/gomp/pr89796.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,53 @@
+// PR c++/89796
+// { dg-do compile }
+// { dg-additional-options "-Wunused-value" }
+
+int
+f1 (int &c)
+{
+  int r;
+  #pragma omp atomic capture	// { dg-bogus "value computed is not used" }
+  { r = c; c++; }
+  return r;
+}
+
+template <int N>
+int
+f2 (int &c)
+{
+  int r;
+  #pragma omp atomic capture	// { dg-bogus "value computed is not used" }
+  { r = c; c++; }
+  return r;
+}
+
+int
+f3 (int &c)
+{
+  return f2 <0> (c);
+}
+
+int
+f4 (int *p)
+{
+  int r;
+  #pragma omp atomic capture	// { dg-bogus "value computed is not used" }
+  { r = *p; (*p)++; }
+  return r;
+}
+
+template <int N>
+int
+f5 (int *p)
+{
+  int r;
+  #pragma omp atomic capture	// { dg-bogus "value computed is not used" }
+  { r = *p; (*p)++; }
+  return r;
+}
+
+int
+f6 (int *p)
+{
+  return f5 <0> (p);
+}
Index: gcc/testsuite/g++.dg/other/pr88568.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/other/pr88568.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/other/pr88568.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,13 @@
+// PR c/88568
+// { dg-do compile }
+// { dg-require-dll "" }
+
+struct S {
+  __attribute__((dllimport)) static const char foo[];
+};
+
+int
+foo (int x)
+{
+  return S::foo[x];
+}
Index: gcc/testsuite/g++.dg/tree-ssa/tail-call-1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tree-ssa/tail-call-1.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/tail-call-1.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,11 @@
+// PR c++/82081
+// { dg-do compile { target c++11 } }
+// { dg-additional-options "-O2 -fdump-tree-optimized" }
+// { dg-final { scan-tree-dump-not "tail call" "optimized" } }
+
+int g(int) ;
+
+int f() noexcept {
+    int i = 42, j = 43;
+    return g(i+j);
+}
Index: gcc/testsuite/g++.dg/tree-ssa/pr87008.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr87008.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr87008.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+
+extern void dontcallthis();
+
+struct A { long a, b; };
+struct B : A {};
+template<class T>void cp(T&a,T const&b){a=b;}
+long f(B x){
+  B y; cp<A>(y,x);
+  B z; cp<A>(z,x);
+  if (y.a - z.a)
+    dontcallthis ();
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-not "dontcallthis" "optimized" } } */
Index: gcc/testsuite/g++.dg/tls/thread_local11.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local11.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local11.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,36 @@
+// PR c++/60702
+// { dg-do compile { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+// { dg-additional-options "-fdump-tree-gimple" }
+// { dg-final { scan-tree-dump-times "_ZTW2s1" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTW2s2" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTW2s3" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTW2s4" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u1E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u2E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u3E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u4E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u5E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u6E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u7E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u8E" 2 "gimple" } }
+
+#include "thread_local11.h"
+
+void
+foo ()
+{
+  f1 ();
+  f2 ();
+  f3 ();
+  f4 ();
+  f5 ();
+  f6 ();
+  f7<0> ();
+  f8<0> ();
+  f9<0> ();
+  f10<0> ();
+  f11<0> ();
+  f12<0> ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12a.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12a.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12a.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (f1 ()->i != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12b.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12b.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12b.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (*f2 () != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12c.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12c.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12c.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (f3 ()->i != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12d.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12d.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12d.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (*f4 () != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12e.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12e.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12e.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (f5 ()->i != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12f.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12f.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12f.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (*f6 () != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12g.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12g.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12g.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (f7<0> ()->i != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12h.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12h.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12h.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (*f8<0> () != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12i.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12i.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12i.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (f9<0> ()->i != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12j.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12j.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12j.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (*f10<0> () != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12k.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12k.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12k.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (f11<0> ()->i != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12l.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local12l.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local12l.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (*f12<0> () != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/pr85400.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/pr85400.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/pr85400.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,24 @@
+// PR c++/85400
+// Testcase by Brian Vandenberg <phantall@gmail.com>
+
+// { dg-do link { target c++11 } }
+// { dg-require-effective-target fpic }
+// { dg-require-effective-target shared }
+// { dg-require-effective-target tls }
+// { dg-options "-shared -fPIC -O" }
+// { dg-add-options tls }
+
+struct Test
+{
+  int blah (int y)
+  {
+    thread_local int mything = 3;
+    mything = y > 0 ? y : mything;
+    return mything;
+  }
+};
+
+int stuff (Test& test, int y)
+{
+  return test.blah(y);
+}
Index: gcc/testsuite/g++.dg/tls/thread_local11a.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local11a.C	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local11a.C	(.../branches/gcc-8-branch)
@@ -0,0 +1,20 @@
+// PR c++/60702
+// { dg-do compile { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-alias "" }
+// { dg-require-effective-target tls_runtime }
+// { dg-additional-options "-fdump-tree-gimple" }
+// { dg-final { scan-tree-dump-times "_ZTH2s1" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTH2s2" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTH2s3" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTH2s4" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u1E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u2E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u3E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u4E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u5E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u6E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u7E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u8E" 1 "gimple" } }
+
+#include "thread_local11.C"
Index: gcc/testsuite/g++.dg/tls/thread_local11.h
===================================================================
--- a/src/gcc/testsuite/g++.dg/tls/thread_local11.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/g++.dg/tls/thread_local11.h	(.../branches/gcc-8-branch)
@@ -0,0 +1,26 @@
+// PR c++/60702
+
+extern "C" void abort ();
+struct S { S () { i = 42; }; int i; };
+thread_local S s1, s2, s3, s4;
+struct T { static thread_local S u1, u2, u3, u4, u5, u6, u7, u8; int i; } t;
+thread_local S T::u1, T::u2, T::u3, T::u4, T::u5, T::u6, T::u7, T::u8;
+
+S *f1 () { return &s1; }
+int *f2 () { return &s2.i; }
+S *f3 () { return &t.u1; }
+int *f4 () { return &t.u2.i; }
+S *f5 () { return &T::u3; }
+int *f6 () { return &T::u4.i; }
+template <int N>
+S *f7 () { return &s3; }
+template <int N>
+int *f8 () { return &s4.i; }
+template <int N>
+S *f9 () { return &t.u5; }
+template <int N>
+int *f10 () { return &t.u6.i; }
+template <int N>
+S *f11 () { return &T::u7; }
+template <int N>
+int *f12 () { return &T::u8.i; }
Index: gcc/testsuite/c-c++-common/pr90108.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/pr90108.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/c-c++-common/pr90108.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,6 @@
+/* PR c++/90108 */
+/* { dg-do compile } */
+/* { dg-options "--param ggc-min-heapsize=0" } */
+
+typedef unsigned int a __attribute__ ((__aligned__(8), __may_alias__));
+typedef unsigned int a __attribute__ ((__aligned__(8), __may_alias__));
Index: gcc/testsuite/c-c++-common/gomp/pr88588.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/gomp/pr88588.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/c-c++-common/gomp/pr88588.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,18 @@
+/* PR middle-end/88588 */
+/* { dg-do compile } */
+/* { dg-options "-fopenmp -O1" } */
+
+int *v;
+
+#pragma omp declare simd
+void
+foo (int x)
+{
+  int *a = &x;
+
+  for (;;)
+    {
+      *v = *a;
+      a = v;
+    }
+}
Index: gcc/testsuite/c-c++-common/pr53633-2.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/pr53633-2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/c-c++-common/pr53633-2.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target naked_functions } */
+/* { dg-options "-O2 -Wall" } */
+/* Check that we do not get warnings about missing return statements
+   or bogus looking noreturn functions.  */
+static int __attribute__((naked))
+foo (void)
+{
+  __asm__ ("");
+}
+
+static int __attribute__((naked,noreturn))
+bar (void)
+{
+  __asm__ ("");
+}
+
+int foo_caller (void) { return foo (); }
+int bar_caller (void) { return bar (); }
Index: gcc/testsuite/c-c++-common/unroll-6.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/unroll-6.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/c-c++-common/unroll-6.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O -fno-tree-loop-optimize" } */
+
+void test (void)
+{
+  #pragma GCC unroll 2
+  for (int nv = 0; nv <= 2; nv += 2)
+    {}
+}
Index: gcc/testsuite/c-c++-common/pr89933.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/pr89933.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/c-c++-common/pr89933.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,5 @@
+/* PR c/89933 */
+/* { dg-do compile } */
+
+typedef unsigned int a __attribute__ ((__aligned__(8), __may_alias__));
+typedef unsigned int a __attribute__ ((__aligned__(8), __may_alias__));
Index: gcc/testsuite/c-c++-common/unroll-7.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/unroll-7.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/c-c++-common/unroll-7.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O -fno-tree-dominator-opts" } */
+
+int nv;
+
+void test (void)
+{
+  #pragma GCC unroll 2
+  for (nv = 0; nv < 1; ++nv)
+    {}
+}
Index: gcc/testsuite/c-c++-common/pr89946.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/pr89946.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/testsuite/c-c++-common/pr89946.c	(.../branches/gcc-8-branch)
@@ -0,0 +1,7 @@
+/* PR c/89946 */
+
+__attribute__((patchable_function_entry (-1))) void foo (void) {}	/* { dg-warning "'patchable_function_entry' attribute argument '-1' is not an integer constant" } */
+__attribute__((patchable_function_entry (5, -5))) void bar (void) {}	/* { dg-warning "'patchable_function_entry' attribute argument '-5' is not an integer constant" } */
+int i, j;
+__attribute__((patchable_function_entry (i))) void baz (void) {}	/* { dg-warning "'patchable_function_entry' attribute argument 'i' is not an integer constant" } */
+__attribute__((patchable_function_entry (2, j))) void qux (void) {}	/* { dg-warning "'patchable_function_entry' attribute argument 'j' is not an integer constant" } */
Index: gcc/cp/typeck.c
===================================================================
--- a/src/gcc/cp/typeck.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/cp/typeck.c	(.../branches/gcc-8-branch)
@@ -40,6 +40,7 @@
 #include "stringpool.h"
 #include "attribs.h"
 #include "asan.h"
+#include "gimplify.h"
 
 static tree cp_build_addr_expr_strict (tree, tsubst_flags_t);
 static tree cp_build_function_call (tree, tree, tsubst_flags_t);
@@ -1383,6 +1384,11 @@
 	 template parameters set, they can't be equal.  */
       if (!comp_template_parms_position (t1, t2))
 	return false;
+      /* If T1 and T2 don't represent the same class template deduction,
+         they aren't equal.  */
+      if (CLASS_PLACEHOLDER_TEMPLATE (t1)
+	  != CLASS_PLACEHOLDER_TEMPLATE (t2))
+	return false;
       /* Constrained 'auto's are distinct from parms that don't have the same
 	 constraints.  */
       if (!equivalent_placeholder_constraints (t1, t2))
@@ -2437,6 +2443,12 @@
       /* A static data member.  */
       result = member;
       mark_exp_read (object);
+
+      if (tree wrap = maybe_get_tls_wrapper_call (result))
+	/* Replace an evaluated use of the thread_local variable with
+	   a call to its wrapper.  */
+	result = wrap;
+
       /* If OBJECT has side-effects, they are supposed to occur.  */
       if (TREE_SIDE_EFFECTS (object))
 	result = build2 (COMPOUND_EXPR, TREE_TYPE (result), object, result);
@@ -5747,18 +5759,17 @@
     return c_common_truthvalue_conversion (input_location, expr);
 }
 
-/* Just like cp_truthvalue_conversion, but we want a CLEANUP_POINT_EXPR.  */
+/* Just like cp_truthvalue_conversion, but we want a CLEANUP_POINT_EXPR.  This
+   is a low-level function; most callers should use maybe_convert_cond.  */
 
 tree
 condition_conversion (tree expr)
 {
   tree t;
-  /* Anything that might happen in a template should go through
-     maybe_convert_cond.  */
-  gcc_assert (!processing_template_decl);
   t = perform_implicit_conversion_flags (boolean_type_node, expr,
 					 tf_warning_or_error, LOOKUP_NORMAL);
-  t = fold_build_cleanup_point_expr (boolean_type_node, t);
+  if (!processing_template_decl)
+    t = fold_build_cleanup_point_expr (boolean_type_node, t);
   return t;
 }
 
@@ -7983,8 +7994,6 @@
 	/* Produce (a ? (b = rhs) : (c = rhs))
 	   except that the RHS goes through a save-expr
 	   so the code to compute it is only emitted once.  */
-	tree cond;
-
 	if (VOID_TYPE_P (TREE_TYPE (rhs)))
 	  {
 	    if (complain & tf_error)
@@ -7999,13 +8008,21 @@
 	if (!lvalue_or_else (lhs, lv_assign, complain))
 	  return error_mark_node;
 
-	cond = build_conditional_expr
-	  (input_location, TREE_OPERAND (lhs, 0),
-	   cp_build_modify_expr (loc, TREE_OPERAND (lhs, 1),
-				 modifycode, rhs, complain),
-	   cp_build_modify_expr (loc, TREE_OPERAND (lhs, 2),
-				 modifycode, rhs, complain),
-           complain);
+	tree op1 = cp_build_modify_expr (loc, TREE_OPERAND (lhs, 1),
+					 modifycode, rhs, complain);
+	/* When sanitizing undefined behavior, even when rhs doesn't need
+	   stabilization at this point, the sanitization might add extra
+	   SAVE_EXPRs in there and so make sure there is no tree sharing
+	   in the rhs, otherwise those SAVE_EXPRs will have initialization
+	   only in one of the two branches.  */
+	if (sanitize_flags_p (SANITIZE_UNDEFINED
+			      | SANITIZE_UNDEFINED_NONDEFAULT))
+	  rhs = unshare_expr (rhs);
+	tree op2 = cp_build_modify_expr (loc, TREE_OPERAND (lhs, 2),
+					 modifycode, rhs, complain);
+	tree cond = build_conditional_expr (input_location,
+					    TREE_OPERAND (lhs, 0), op1, op2,
+					    complain);
 
 	if (cond == error_mark_node)
 	  return cond;
Index: gcc/cp/init.c
===================================================================
--- a/src/gcc/cp/init.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/cp/init.c	(.../branches/gcc-8-branch)
@@ -419,6 +419,15 @@
 	      if (ftype == error_mark_node)
 		continue;
 
+	      /* Ignore flexible array members for value initialization.  */
+	      if (TREE_CODE (ftype) == ARRAY_TYPE
+		  && !COMPLETE_TYPE_P (ftype)
+		  && !TYPE_DOMAIN (ftype)
+		  && COMPLETE_TYPE_P (TREE_TYPE (ftype))
+		  && (next_initializable_field (DECL_CHAIN (field))
+		      == NULL_TREE))
+		continue;
+
 	      /* We could skip vfields and fields of types with
 		 user-defined constructors, but I think that won't improve
 		 performance at all; it should be simpler in general just
@@ -2269,8 +2278,11 @@
 		  || TREE_CODE (init) == STRING_CST)))
 	break;
       /* Don't return a CONSTRUCTOR for a variable with partial run-time
-	 initialization, since it doesn't represent the entire value.  */
-      if (TREE_CODE (init) == CONSTRUCTOR
+	 initialization, since it doesn't represent the entire value.
+	 Similarly for VECTOR_CSTs created by cp_folding those
+	 CONSTRUCTORs.  */
+      if ((TREE_CODE (init) == CONSTRUCTOR
+	   || TREE_CODE (init) == VECTOR_CST)
 	  && !DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl))
 	break;
       /* If the variable has a dynamic initializer, don't use its
Index: gcc/cp/class.c
===================================================================
--- a/src/gcc/cp/class.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/cp/class.c	(.../branches/gcc-8-branch)
@@ -5171,7 +5171,9 @@
     for (ovl_iterator iter (get_class_binding_direct
 			    (t, assign_op_identifier));
 	 iter; ++iter)
-      if ((!user_p || !DECL_ARTIFICIAL (*iter)) && move_fn_p (*iter))
+      if ((!user_p || !DECL_ARTIFICIAL (*iter))
+	  && DECL_CONTEXT (*iter) == t
+	  && move_fn_p (*iter))
 	return true;
   
   return false;
Index: gcc/cp/decl.c
===================================================================
--- a/src/gcc/cp/decl.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/cp/decl.c	(.../branches/gcc-8-branch)
@@ -2163,13 +2163,33 @@
 	  if (TYPE_NAME (TREE_TYPE (newdecl)) == newdecl)
 	    {
 	      tree remove = TREE_TYPE (newdecl);
-	      for (tree t = TYPE_MAIN_VARIANT (remove); ;
-		   t = TYPE_NEXT_VARIANT (t))
-		if (TYPE_NEXT_VARIANT (t) == remove)
-		  {
-		    TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (remove);
-		    break;
-		  }
+	      if (TYPE_MAIN_VARIANT (remove) == remove)
+		{
+		  gcc_assert (TYPE_NEXT_VARIANT (remove) == NULL_TREE);
+		  /* If remove is the main variant, no need to remove that
+		     from the list.  One of the DECL_ORIGINAL_TYPE
+		     variants, e.g. created for aligned attribute, might still
+		     refer to the newdecl TYPE_DECL though, so remove that one
+		     in that case.  */
+		  if (tree orig = DECL_ORIGINAL_TYPE (newdecl))
+		    if (orig != remove)
+		      for (tree t = TYPE_MAIN_VARIANT (orig); t;
+			   t = TYPE_MAIN_VARIANT (t))
+			if (TYPE_NAME (TYPE_NEXT_VARIANT (t)) == newdecl)
+			  {
+			    TYPE_NEXT_VARIANT (t)
+			      = TYPE_NEXT_VARIANT (TYPE_NEXT_VARIANT (t));
+			    break;
+			  }
+		}	    
+	      else
+		for (tree t = TYPE_MAIN_VARIANT (remove); ;
+		     t = TYPE_NEXT_VARIANT (t))
+		  if (TYPE_NEXT_VARIANT (t) == remove)
+		    {
+		      TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (remove);
+		      break;
+		    }
 	    }
 	}
       else if (merge_attr)
@@ -5616,6 +5636,7 @@
 		 be merged.  */
 	      TREE_PUBLIC (decl) = 0;
 	      DECL_COMMON (decl) = 0;
+	      DECL_INTERFACE_KNOWN (decl) = 1;
 	      const char *msg;
 	      if (DECL_INLINE_VAR_P (decl))
 		msg = G_("sorry: semantics of inline variable "
Index: gcc/cp/method.c
===================================================================
--- a/src/gcc/cp/method.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/cp/method.c	(.../branches/gcc-8-branch)
@@ -1201,6 +1201,8 @@
     expr = assignable_expr (to, from);
   else if (trivial && from && TREE_CHAIN (from))
     return error_mark_node; // only 0- and 1-argument ctors can be trivial
+  else if (TREE_CODE (to) == ARRAY_TYPE && !TYPE_DOMAIN (to))
+    return error_mark_node; // can't construct an array of unknown bound
   else
     expr = constructible_expr (to, from);
   return expr;
Index: gcc/cp/ChangeLog
===================================================================
--- a/src/gcc/cp/ChangeLog	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/cp/ChangeLog	(.../branches/gcc-8-branch)
@@ -1,3 +1,205 @@
+2019-08-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline.
+	2019-08-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/91436
+	* name-lookup.c (get_std_name_hint): Fix min_dialect field for
+	complex_literals and make_unique entries.
+
+2019-08-01  Marek Polacek  <polacek@redhat.com>	
+
+	Backported from mainline
+	2018-06-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/86098 - ICE with template placeholder for TTP.
+	* typeck.c (structural_comptypes) [TEMPLATE_TYPE_PARM]: Check
+	CLASS_PLACEHOLDER_TEMPLATE.
+
+2019-06-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90810
+	* init.c (constant_value_1): Handle VECTOR_CST DECL_INITIAL for
+	!DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P decls like CONSTRUCTOR.
+
+2019-05-22  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2018-05-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR c++/85400
+	* decl2.c (adjust_var_decl_tls_model): New static function.
+	(comdat_linkage): Call it on a variable.
+	(maybe_make_one_only): Likewise.
+
+2019-05-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from mainline
+	2019-05-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/90532 Ensure __is_constructible(T[]) is false
+	* method.c (is_xible_helper): Return error_mark_node for construction
+	of an array of unknown bound.
+
+2019-05-07  Marek Polacek  <polacek@redhat.com>	
+
+	Backported from mainline
+	2019-02-27  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/88857 - ICE with value-initialization of argument in template.
+	* call.c (convert_like_real): Don't call build_value_init in template.
+
+	2019-03-25  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/89214 - ICE when initializing aggregates with bases.
+	* typeck2.c (digest_init_r): Warn about object slicing instead of
+	crashing.
+
+	2019-02-27  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/89511 - ICE with using-declaration and unscoped enumerator.
+	* parser.c (cp_parser_using_declaration): For an unscoped enum
+	only use its context if it's not a function declaration.
+
+	2019-03-25  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/89705 - ICE with reference binding with conversion function.
+	* call.c (reference_binding): If the result of the conversion function
+	is a prvalue of non-class type, use the cv-unqualified type.
+
+	2019-03-29  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/89876 - ICE with deprecated conversion.
+	* call.c (convert_like_real): Only give warnings with tf_warning.
+
+2019-04-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90108
+	* decl.c (duplicate_decls): If remove is main variant and
+	DECL_ORIGINAL_TYPE is some other type, remove a DECL_ORIGINAL_TYPE
+	variant that has newdecl as TYPE_NAME if any.
+
+	2019-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89933
+	* decl.c (duplicate_decls): When newdecl's type is its main variant,
+	don't try to remove it from the variant list, but instead assert
+	it has no variants.
+
+	2019-03-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/89869
+	* typeck.c: Include gimplify.h.
+	(cp_build_modify_expr) <case COND_EXPR>: Unshare rhs before using it
+	for second time.  Formatting fixes.
+
+	2019-03-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89796
+	* semantics.c (finish_omp_atomic): Add warning_sentinel for
+	-Wunused-value around finish_expr_stmt call.
+
+	2019-03-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/60702
+	* cp-tree.h (get_tls_wrapper_fn): Remove declaration.
+	(maybe_get_tls_wrapper_call): Declare.
+	* decl2.c (get_tls_wrapper_fn): Make static.
+	(maybe_get_tls_wrapper_call): New function.
+	* typeck.c (build_class_member_access_expr): Handle accesses to TLS
+	variables.
+	* semantics.c (finish_qualified_id_expr): Likewise.
+	(finish_id_expression_1): Use maybe_get_tls_wrapper_call.
+	* pt.c (tsubst_copy_and_build): Likewise.
+
+	2019-03-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89767
+	* parser.c (cp_parser_lambda_introducer): Add ids and first_capture_id
+	variables, check for duplicates in this function.
+	* lambda.c (add_capture): Don't check for duplicates nor use
+	IDENTIFIER_MARKED.
+	(register_capture_members): Don't clear IDENTIFIER_MARKED here.
+
+	2019-03-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89512
+	* semantics.c (finish_qualified_id_expr): Reject variable templates.
+
+	2019-03-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/87148
+	* init.c (build_value_init_noctor): Ignore flexible array members.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89403
+	* decl2.c (c_parse_final_cleanups): Move TREE_ASM_WRITTEN setting
+	for flag_syntax_only from here...
+	* semantics.c (expand_or_defer_fn_1): ... here.
+
+	PR c++/89405
+	* decl.c (maybe_commonize_var): When clearing TREE_PUBLIC and
+	DECL_COMMON, set DECL_INTERFACE_KNOWN.
+
+2019-03-08  Jason Merrill  <jason@redhat.com>
+
+	PR c++/88820 - ICE with CTAD and member template used in DMI.
+	* pt.c (do_class_deduction): Handle parm used as its own arg.
+
+	PR c++/88869 - C++17 ICE with CTAD and explicit specialization.
+	* pt.c (do_class_deduction): Don't include explicit specialization
+	args in outer_args.
+
+	PR c++/88419 - C++17 ICE with class template arg deduction.
+	* pt.c (make_template_placeholder): Set TYPE_CANONICAL after
+	CLASS_PLACEHOLDER_TEMPLATE.
+
+	PR c++/88690 - C++17 ICE with empty base in aggregate.
+	* typeck2.c (process_init_constructor_record): Skip trivial
+	initialization of an empty base.
+
+	PR c++/87921 - wrong error with inline static data member.
+	* decl2.c (c_parse_final_cleanups): Don't force out uninstantiated
+	inline static data members.
+
+	PR c++/89381 - implicit copy and using-declaration.
+	* class.c (classtype_has_move_assign_or_move_ctor_p): Don't consider
+	op= brought in by a using-declaration.
+
+	PR c++/89576 - if constexpr of lambda capture.
+	* semantics.c (maybe_convert_cond): Do convert a non-dependent
+	condition in a template.
+	* typeck.c (condition_conversion): Handle being called in a
+	template.
+
+	PR c++/89422 - ICE with -g and lambda in default arg in template.
+	* pt.c (tsubst_function_decl): SET_DECL_FRIEND_CONTEXT sooner.
+
+	PR c++/87513 - 'sorry' mangling PMF template-id.
+	* mangle.c (write_expression): Handle SCOPE_REF to BASELINK.
+
+	PR c++/88183 - ICE with .* fold-expression.
+	* pt.c (fold_expression) [DOTSTAR_EXPR]: Remove special handling.
+
+2019-03-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89585
+	* parser.c (cp_parser_asm_definition): Parse asm qualifiers even
+	at toplevel, but diagnose them.
+
+2019-02-26  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-02-11  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/89212 - ICE converting nullptr to pointer-to-member-function.
+	* pt.c (tsubst_copy_and_build) <case CONSTRUCTOR>: Return early for
+	null member pointer value.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: gcc/cp/typeck2.c
===================================================================
--- a/src/gcc/cp/typeck2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/cp/typeck2.c	(.../branches/gcc-8-branch)
@@ -1142,8 +1142,29 @@
     {
       tree elt = CONSTRUCTOR_ELT (init, 0)->value;
       if (reference_related_p (type, TREE_TYPE (elt)))
-	/* We should have fixed this in reshape_init.  */
-	gcc_unreachable ();
+	{
+	  /* In C++17, aggregates can have bases, thus participate in
+	     aggregate initialization.  In the following case:
+
+	       struct B { int c; };
+	       struct D : B { };
+	       D d{{D{{42}}}};
+
+	    there's an extra set of braces, so the D temporary initializes
+	    the first element of d, which is the B base subobject.  The base
+	    of type B is copy-initialized from the D temporary, causing
+	    object slicing.  */
+	  tree field = next_initializable_field (TYPE_FIELDS (type));
+	  if (field && DECL_FIELD_IS_BASE (field))
+	    {
+	      if (warning_at (loc, 0, "initializing a base class of type %qT "
+			      "results in object slicing", TREE_TYPE (field)))
+		inform (loc, "remove %<{ }%> around initializer");
+	    }
+	  else
+	    /* We should have fixed this in reshape_init.  */
+	    gcc_unreachable ();
+	}
     }
 
   if (BRACE_ENCLOSED_INITIALIZER_P (init)
@@ -1538,6 +1559,13 @@
 	    }
 	}
 
+      if (DECL_SIZE (field) && integer_zerop (DECL_SIZE (field))
+	  && !TREE_SIDE_EFFECTS (next))
+	/* Don't add trivial initialization of an empty base/field to the
+	   constructor, as they might not be ordered the way the back-end
+	   expects.  */
+	continue;
+
       /* If this is a bitfield, now convert to the lowered type.  */
       if (type != TREE_TYPE (field))
 	next = cp_convert_and_check (TREE_TYPE (field), next, complain);
Index: gcc/cp/pt.c
===================================================================
--- a/src/gcc/cp/pt.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/cp/pt.c	(.../branches/gcc-8-branch)
@@ -11732,8 +11732,6 @@
     {
     case COMPOUND_EXPR:
       return build_x_compound_expr (input_location, left, right, complain);
-    case DOTSTAR_EXPR:
-      return build_m_component_ref (left, right, complain);
     default:
       return build_x_binary_op (input_location, code,
                                 left, TREE_CODE (left),
@@ -13023,6 +13021,11 @@
 	set_constraints (r, ci);
       }
 
+  if (DECL_FRIEND_P (t) && DECL_FRIEND_CONTEXT (t))
+    SET_DECL_FRIEND_CONTEXT (r,
+			     tsubst (DECL_FRIEND_CONTEXT (t),
+				     args, complain, in_decl));
+
   /* Set up the DECL_TEMPLATE_INFO for R.  There's no need to do
      this in the special friend case mentioned above where
      GEN_TMPL is NULL.  */
@@ -13084,11 +13087,6 @@
 	   && !grok_op_properties (r, /*complain=*/true))
     return error_mark_node;
 
-  if (DECL_FRIEND_P (t) && DECL_FRIEND_CONTEXT (t))
-    SET_DECL_FRIEND_CONTEXT (r,
-			     tsubst (DECL_FRIEND_CONTEXT (t),
-				     args, complain, in_decl));
-
   /* Possibly limit visibility based on template args.  */
   DECL_VISIBILITY (r) = VISIBILITY_DEFAULT;
   if (DECL_VISIBILITY_SPECIFIED (t))
@@ -18797,6 +18795,12 @@
 	   looked up by digest_init.  */
 	process_index_p = !(type && MAYBE_CLASS_TYPE_P (type));
 
+	if (null_member_pointer_value_p (t))
+	  {
+	    gcc_assert (same_type_p (type, TREE_TYPE (t)));
+	    RETURN (t);
+	  }
+
 	n = vec_safe_copy (CONSTRUCTOR_ELTS (t));
         newlen = vec_safe_length (n);
 	FOR_EACH_VEC_SAFE_ELT (n, idx, ce)
@@ -18890,17 +18894,10 @@
       {
 	tree r = tsubst_copy (t, args, complain, in_decl);
 	/* ??? We're doing a subset of finish_id_expression here.  */
-	if (VAR_P (r)
-	    && !processing_template_decl
-	    && !cp_unevaluated_operand
-	    && (TREE_STATIC (r) || DECL_EXTERNAL (r))
-	    && CP_DECL_THREAD_LOCAL_P (r))
-	  {
-	    if (tree wrap = get_tls_wrapper_fn (r))
-	      /* Replace an evaluated use of the thread_local variable with
-		 a call to its wrapper.  */
-	      r = build_cxx_call (wrap, 0, NULL, tf_warning_or_error);
-	  }
+	if (tree wrap = maybe_get_tls_wrapper_call (r))
+	  /* Replace an evaluated use of the thread_local variable with
+	     a call to its wrapper.  */
+	  r = wrap;
 	else if (outer_automatic_var_p (r))
 	  r = process_outer_var_ref (r, complain);
 
@@ -25998,8 +25995,10 @@
 tree
 make_template_placeholder (tree tmpl)
 {
-  tree t = make_auto_1 (DECL_NAME (tmpl), true);
+  tree t = make_auto_1 (DECL_NAME (tmpl), false);
   CLASS_PLACEHOLDER_TEMPLATE (t) = tmpl;
+  /* Our canonical type depends on the placeholder.  */
+  TYPE_CANONICAL (t) = canonical_type_parameter (t);
   return t;
 }
 
@@ -26534,6 +26533,9 @@
 	error ("non-class template %qT used without template arguments", tmpl);
       return error_mark_node;
     }
+  if (init && TREE_TYPE (init) == ptype)
+    /* Using the template parm as its own argument.  */
+    return ptype;
 
   tree type = TREE_TYPE (tmpl);
 
@@ -26601,7 +26603,7 @@
 
   tree outer_args = NULL_TREE;
   if (DECL_CLASS_SCOPE_P (tmpl)
-      && CLASSTYPE_TEMPLATE_INFO (DECL_CONTEXT (tmpl)))
+      && CLASSTYPE_TEMPLATE_INSTANTIATION (DECL_CONTEXT (tmpl)))
     {
       outer_args = CLASSTYPE_TI_ARGS (DECL_CONTEXT (tmpl));
       type = TREE_TYPE (most_general_template (tmpl));
Index: gcc/cp/semantics.c
===================================================================
--- a/src/gcc/cp/semantics.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/cp/semantics.c	(.../branches/gcc-8-branch)
@@ -645,10 +645,13 @@
     return NULL_TREE;
 
   /* Wait until we instantiate templates before doing conversion.  */
-  if (processing_template_decl)
+  if (processing_template_decl
+      && (type_dependent_expression_p (cond)
+	  /* For GCC 8 only convert non-dependent condition in a lambda.  */
+	  || !current_lambda_expr ()))
     return cond;
 
-  if (warn_sequence_point)
+  if (warn_sequence_point && !processing_template_decl)
     verify_sequence_points (cond);
 
   /* Do the conversion.  */
@@ -2099,6 +2102,14 @@
 	expr = build_offset_ref (qualifying_class, expr, /*address_p=*/false,
 				 complain);
     }
+  else if (!template_p
+	   && TREE_CODE (expr) == TEMPLATE_DECL
+	   && !DECL_FUNCTION_TEMPLATE_P (expr))
+    {
+      if (complain & tf_error)
+	error ("%qE missing template arguments", expr);
+      return error_mark_node;
+    }
   else
     {
       /* In a template, return a SCOPE_REF for most qualified-ids
@@ -2114,6 +2125,8 @@
 	expr = build_qualified_name (TREE_TYPE (expr),
 				     qualifying_class, expr,
 				     template_p);
+      else if (tree wrap = maybe_get_tls_wrapper_call (expr))
+	expr = wrap;
 
       expr = convert_from_reference (expr);
     }
@@ -3709,18 +3722,10 @@
 	  *non_integral_constant_expression_p = true;
 	}
 
-      tree wrap;
-      if (VAR_P (decl)
-	  && !cp_unevaluated_operand
-	  && !processing_template_decl
-	  && (TREE_STATIC (decl) || DECL_EXTERNAL (decl))
-	  && CP_DECL_THREAD_LOCAL_P (decl)
-	  && (wrap = get_tls_wrapper_fn (decl)))
-	{
-	  /* Replace an evaluated use of the thread_local variable with
-	     a call to its wrapper.  */
-	  decl = build_cxx_call (wrap, 0, NULL, tf_warning_or_error);
-	}
+      if (tree wrap = maybe_get_tls_wrapper_call (decl))
+	/* Replace an evaluated use of the thread_local variable with
+	   a call to its wrapper.  */
+	decl = wrap;
       else if (TREE_CODE (decl) == TEMPLATE_ID_EXPR
 	       && !dependent_p
 	       && variable_template_p (TREE_OPERAND (decl, 0)))
@@ -4265,7 +4270,12 @@
   /* There's no reason to do any of the work here if we're only doing
      semantic analysis; this code just generates RTL.  */
   if (flag_syntax_only)
-    return false;
+    {
+      /* Pretend that this function has been written out so that we don't try
+	 to expand it again.  */
+      TREE_ASM_WRITTEN (fn) = 1;
+      return false;
+    }
 
   return true;
 }
@@ -8452,6 +8462,11 @@
       stmt = build2 (OMP_ATOMIC, void_type_node, integer_zero_node, stmt);
       OMP_ATOMIC_SEQ_CST (stmt) = seq_cst;
     }
+
+  /* Avoid -Wunused-value warnings here, the whole construct has side-effects
+     and even if it might be wrapped from fold-const.c or c-omp.c wrapped
+     in some tree that appears to be unused, the value is not unused.  */
+  warning_sentinel w (warn_unused_value);
   finish_expr_stmt (stmt);
 }
 
Index: gcc/cp/decl2.c
===================================================================
--- a/src/gcc/cp/decl2.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/cp/decl2.c	(.../branches/gcc-8-branch)
@@ -1838,6 +1838,17 @@
     }
 }
 
+/* Adjust the TLS model on variable DECL if need be, typically after
+   the linkage of DECL has been modified.  */
+
+static void
+adjust_var_decl_tls_model (tree decl)
+{
+  if (CP_DECL_THREAD_LOCAL_P (decl)
+      && !lookup_attribute ("tls_model", DECL_ATTRIBUTES (decl)))
+    set_decl_tls_model (decl, decl_default_tls_model (decl));
+}
+
 /* Set DECL up to have the closest approximation of "initialized common"
    linkage available.  */
 
@@ -1888,6 +1899,9 @@
 
   if (TREE_PUBLIC (decl))
     DECL_COMDAT (decl) = 1;
+
+  if (VAR_P (decl))
+    adjust_var_decl_tls_model (decl);
 }
 
 /* For win32 we also want to put explicit instantiations in
@@ -1926,6 +1940,8 @@
 	  /* Mark it needed so we don't forget to emit it.  */
           node->forced_by_abi = true;
 	  TREE_USED (decl) = 1;
+
+	  adjust_var_decl_tls_model (decl);
 	}
     }
 }
@@ -3357,7 +3373,7 @@
    VAR and then returns a reference to VAR.  The wrapper function is used
    in place of VAR everywhere VAR is mentioned.  */
 
-tree
+static tree
 get_tls_wrapper_fn (tree var)
 {
   /* Only C++11 TLS vars need this wrapper fn.  */
@@ -3409,6 +3425,22 @@
   return fn;
 }
 
+/* If EXPR is a thread_local variable that should be wrapped by init
+   wrapper function, return a call to that function, otherwise return
+   NULL.  */
+
+tree
+maybe_get_tls_wrapper_call (tree expr)
+{
+  if (VAR_P (expr)
+      && !processing_template_decl
+      && !cp_unevaluated_operand
+      && CP_DECL_THREAD_LOCAL_P (expr))
+    if (tree wrap = get_tls_wrapper_fn (expr))
+      return build_cxx_call (wrap, 0, NULL, tf_warning_or_error);
+  return NULL;
+}
+
 /* At EOF, generate the definition for the TLS wrapper function FN:
 
    T& var_wrapper() {
@@ -4888,11 +4920,6 @@
 	      /* Generate RTL for this function now that we know we
 		 need it.  */
 	      expand_or_defer_fn (decl);
-	      /* If we're compiling -fsyntax-only pretend that this
-		 function has been written out so that we don't try to
-		 expand it again.  */
-	      if (flag_syntax_only)
-		TREE_ASM_WRITTEN (decl) = 1;
 	      reconsider = true;
 	    }
 	}
@@ -4905,7 +4932,10 @@
 	{
 	  if (var_finalized_p (decl) || DECL_REALLY_EXTERN (decl)
 	      /* Don't write it out if we haven't seen a definition.  */
-	      || (DECL_IN_AGGR_P (decl) && !DECL_INLINE_VAR_P (decl)))
+	      || (DECL_IN_AGGR_P (decl) && !DECL_INLINE_VAR_P (decl))
+	      /* Or haven't instantiated it.  */
+	      || (DECL_TEMPLATE_INSTANTIATION (decl)
+		  && !DECL_TEMPLATE_INSTANTIATED (decl)))
 	    continue;
 	  import_export_decl (decl);
 	  /* If this static data member is needed, provide it to the
Index: gcc/cp/parser.c
===================================================================
--- a/src/gcc/cp/parser.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/cp/parser.c	(.../branches/gcc-8-branch)
@@ -10266,6 +10266,11 @@
       first = false;
     }
 
+  hash_set<tree> *ids = NULL;
+#if GCC_VERSION >= 8000
+  char ids_buf[sizeof (hash_set<tree>) + __alignof__ (hash_set<tree>) - 1];
+#endif
+  tree first_capture_id = NULL_TREE;
   while (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_SQUARE))
     {
       cp_token* capture_token;
@@ -10301,11 +10306,14 @@
 	    pedwarn (loc, 0, "explicit by-copy capture of %<this%> redundant "
 		     "with by-copy capture default");
 	  cp_lexer_consume_token (parser->lexer);
-	  add_capture (lambda_expr,
-		       /*id=*/this_identifier,
-		       /*initializer=*/finish_this_expr (),
-		       /*by_reference_p=*/true,
-		       explicit_init_p);
+	  if (LAMBDA_EXPR_THIS_CAPTURE (lambda_expr))
+	    pedwarn (input_location, 0,
+		     "already captured %qD in lambda expression",
+		     this_identifier);
+	  else
+	    add_capture (lambda_expr, /*id=*/this_identifier,
+			 /*initializer=*/finish_this_expr (),
+			 /*by_reference_p=*/true, explicit_init_p);
 	  continue;
 	}
 
@@ -10319,11 +10327,14 @@
 			     "-std=c++17 or -std=gnu++17");
 	  cp_lexer_consume_token (parser->lexer);
 	  cp_lexer_consume_token (parser->lexer);
-	  add_capture (lambda_expr,
-		       /*id=*/this_identifier,
-		       /*initializer=*/finish_this_expr (),
-		       /*by_reference_p=*/false,
-		       explicit_init_p);
+	  if (LAMBDA_EXPR_THIS_CAPTURE (lambda_expr))
+	    pedwarn (input_location, 0,
+		     "already captured %qD in lambda expression",
+		     this_identifier);
+	  else
+	    add_capture (lambda_expr, /*id=*/this_identifier,
+			 /*initializer=*/finish_this_expr (),
+			 /*by_reference_p=*/false, explicit_init_p);
 	  continue;
 	}
 
@@ -10445,11 +10456,35 @@
 		     "default", capture_id);
 	}
 
-      add_capture (lambda_expr,
-		   capture_id,
-		   capture_init_expr,
-		   /*by_reference_p=*/capture_kind == BY_REFERENCE,
-		   explicit_init_p);
+      /* Check for duplicates.
+	 Optimize for the zero or one explicit captures cases and only create
+	 the hash_set after adding second capture.  */
+      bool found = false;
+      if (ids && ids->elements ())
+	found = ids->add (capture_id);
+      else if (first_capture_id == NULL_TREE)
+	first_capture_id = capture_id;
+      else if (capture_id == first_capture_id)
+	found = true;
+      else
+	{
+#if GCC_VERSION >= 8000
+	  ids = new (ids_buf
+		     + (-(uintptr_t) ids_buf
+			& (__alignof__ (hash_set <tree>) - 1))) hash_set <tree>;
+#else
+	  ids = new hash_set <tree>;
+#endif
+	  ids->add (first_capture_id);
+	  ids->add (capture_id);
+	}
+      if (found)
+	pedwarn (input_location, 0,
+		 "already captured %qD in lambda expression", capture_id);
+      else
+	add_capture (lambda_expr, capture_id, capture_init_expr,
+		     /*by_reference_p=*/capture_kind == BY_REFERENCE,
+		     explicit_init_p);
 
       /* If there is any qualification still in effect, clear it
 	 now; we will be starting fresh with the next capture.  */
@@ -10458,6 +10493,13 @@
       parser->object_scope = NULL_TREE;
     }
 
+  if (ids)
+#if GCC_VERSION >= 8000
+    ids->~hash_set <tree> ();
+#else
+    delete ids;
+#endif
+
   cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);
 }
 
@@ -18773,7 +18815,8 @@
 						  /*is_declaration=*/true);
   if (!qscope)
     qscope = global_namespace;
-  else if (UNSCOPED_ENUM_P (qscope))
+  else if (UNSCOPED_ENUM_P (qscope)
+	   && !TYPE_FUNCTION_SCOPE_P (qscope))
     qscope = CP_TYPE_CONTEXT (qscope);
 
   if (access_declaration_p && cp_parser_error_occurred (parser))
@@ -19125,8 +19168,9 @@
   location_t volatile_loc = UNKNOWN_LOCATION;
   location_t inline_loc = UNKNOWN_LOCATION;
   location_t goto_loc = UNKNOWN_LOCATION;
+  location_t first_loc = UNKNOWN_LOCATION;
 
-  if (cp_parser_allow_gnu_extensions_p (parser) && parser->in_function_body)
+  if (cp_parser_allow_gnu_extensions_p (parser))
     for (;;)
       {
 	cp_token *token = cp_lexer_peek_token (parser->lexer);
@@ -19152,6 +19196,8 @@
 	      }
 	    else
 	      inline_loc = loc;
+	    if (!first_loc)
+	      first_loc = loc;
 	    cp_lexer_consume_token (parser->lexer);
 	    continue;
 
@@ -19163,6 +19209,8 @@
 	      }
 	    else
 	      goto_loc = loc;
+	    if (!first_loc)
+	      first_loc = loc;
 	    cp_lexer_consume_token (parser->lexer);
 	    continue;
 
@@ -19182,6 +19230,12 @@
   bool inline_p = (inline_loc != UNKNOWN_LOCATION);
   bool goto_p = (goto_loc != UNKNOWN_LOCATION);
 
+  if (!parser->in_function_body && (inline_p || goto_p))
+    {
+      error_at (first_loc, "asm qualifier outside of function body");
+      inline_p = goto_p = false;
+    }
+
   /* Look for the opening `('.  */
   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))
     return;
Index: gcc/cp/call.c
===================================================================
--- a/src/gcc/cp/call.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/cp/call.c	(.../branches/gcc-8-branch)
@@ -1767,6 +1767,9 @@
 	    && DECL_CONV_FN_P (t->cand->fn))
 	  {
 	    tree ftype = TREE_TYPE (TREE_TYPE (t->cand->fn));
+	    /* A prvalue of non-class type is cv-unqualified.  */
+	    if (TREE_CODE (ftype) != REFERENCE_TYPE && !CLASS_TYPE_P (ftype))
+	      ftype = cv_unqualified (ftype);
 	    int sflags = (flags|LOOKUP_NO_CONVERSION)&~LOOKUP_NO_TEMP_BIND;
 	    conversion *new_second
 	      = reference_binding (rto, ftype, NULL_TREE, c_cast_p,
@@ -6775,7 +6778,8 @@
 	/* If we're initializing from {}, it's value-initialization.  */
 	if (BRACE_ENCLOSED_INITIALIZER_P (expr)
 	    && CONSTRUCTOR_NELTS (expr) == 0
-	    && TYPE_HAS_DEFAULT_CONSTRUCTOR (totype))
+	    && TYPE_HAS_DEFAULT_CONSTRUCTOR (totype)
+	    && !processing_template_decl)
 	  {
 	    bool direct = CONSTRUCTOR_IS_DIRECT_INIT (expr);
 	    if (abstract_virtuals_error_sfinae (NULL_TREE, totype, complain))
@@ -7110,7 +7114,8 @@
 
     case ck_qual:
       /* Warn about deprecated conversion if appropriate.  */
-      string_conv_p (totype, expr, 1);
+      if (complain & tf_warning)
+	string_conv_p (totype, expr, 1);
       break;
 
     case ck_ptr:
Index: gcc/cp/lambda.c
===================================================================
--- a/src/gcc/cp/lambda.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/cp/lambda.c	(.../branches/gcc-8-branch)
@@ -612,19 +612,6 @@
 	  IDENTIFIER_LENGTH (id) + 1);
   name = get_identifier (buf);
 
-  /* If TREE_TYPE isn't set, we're still in the introducer, so check
-     for duplicates.  */
-  if (!LAMBDA_EXPR_CLOSURE (lambda))
-    {
-      if (IDENTIFIER_MARKED (name))
-	{
-	  pedwarn (input_location, 0,
-		   "already captured %qD in lambda expression", id);
-	  return NULL_TREE;
-	}
-      IDENTIFIER_MARKED (name) = true;
-    }
-
   if (variadic)
     type = make_pack_expansion (type);
 
@@ -685,8 +672,6 @@
   if (PACK_EXPANSION_P (field))
     field = PACK_EXPANSION_PATTERN (field);
 
-  /* We set this in add_capture to avoid duplicates.  */
-  IDENTIFIER_MARKED (DECL_NAME (field)) = false;
   finish_member_declaration (field);
 }
 
Index: gcc/cp/mangle.c
===================================================================
--- a/src/gcc/cp/mangle.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/cp/mangle.c	(.../branches/gcc-8-branch)
@@ -3047,7 +3047,8 @@
 	{
 	  scope = TREE_OPERAND (expr, 0);
 	  member = TREE_OPERAND (expr, 1);
-	  gcc_assert (!BASELINK_P (member));
+	  if (BASELINK_P (member))
+	    member = BASELINK_FUNCTIONS (member);
 	}
       else
 	{
Index: gcc/cp/cp-tree.h
===================================================================
--- a/src/gcc/cp/cp-tree.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/cp/cp-tree.h	(.../branches/gcc-8-branch)
@@ -6390,7 +6390,7 @@
 extern tree get_guard				(tree);
 extern tree get_guard_cond			(tree, bool);
 extern tree set_guard				(tree);
-extern tree get_tls_wrapper_fn			(tree);
+extern tree maybe_get_tls_wrapper_call		(tree);
 extern void mark_needed				(tree);
 extern bool decl_needed_p			(tree);
 extern void note_vague_linkage_fn		(tree);
Index: gcc/cp/name-lookup.c
===================================================================
--- a/src/gcc/cp/name-lookup.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/cp/name-lookup.c	(.../branches/gcc-8-branch)
@@ -5509,7 +5509,7 @@
     {"bitset", "<bitset>", cxx11},
     /* <complex>.  */
     {"complex", "<complex>", cxx98},
-    {"complex_literals", "<complex>", cxx98},
+    {"complex_literals", "<complex>", cxx14},
     /* <condition_variable>. */
     {"condition_variable", "<condition_variable>", cxx11},
     {"condition_variable_any", "<condition_variable>", cxx11},
@@ -5571,7 +5571,7 @@
     {"multimap", "<map>", cxx98},
     /* <memory>.  */
     {"make_shared", "<memory>", cxx11},
-    {"make_unique", "<memory>", cxx11},
+    {"make_unique", "<memory>", cxx14},
     {"shared_ptr", "<memory>", cxx11},
     {"unique_ptr", "<memory>", cxx11},
     {"weak_ptr", "<memory>", cxx11},
Index: gcc/cgraphclones.c
===================================================================
--- a/src/gcc/cgraphclones.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/cgraphclones.c	(.../branches/gcc-8-branch)
@@ -938,6 +938,11 @@
    If non-NULL BLOCK_TO_COPY determine what basic blocks to copy.
    If non_NULL NEW_ENTRY determine new entry BB of the clone.
 
+   If TARGET_ATTRIBUTES is non-null, when creating a new declaration,
+   add the attributes to DECL_ATTRIBUTES.  And call valid_attribute_p
+   that will promote value of the attribute DECL_FUNCTION_SPECIFIC_TARGET
+   of the declaration.
+
    Return the new version's cgraph node.  */
 
 cgraph_node *
@@ -945,7 +950,7 @@
   (vec<cgraph_edge *> redirect_callers,
    vec<ipa_replace_map *, va_gc> *tree_map, bitmap args_to_skip,
    bool skip_return, bitmap bbs_to_copy, basic_block new_entry_block,
-   const char *suffix)
+   const char *suffix, tree target_attributes)
 {
   tree old_decl = decl;
   cgraph_node *new_version_node = NULL;
@@ -968,6 +973,19 @@
   SET_DECL_ASSEMBLER_NAME (new_decl, DECL_NAME (new_decl));
   SET_DECL_RTL (new_decl, NULL);
 
+  if (target_attributes)
+    {
+      DECL_ATTRIBUTES (new_decl) = target_attributes;
+
+      location_t saved_loc = input_location;
+      tree v = TREE_VALUE (target_attributes);
+      input_location = DECL_SOURCE_LOCATION (new_decl);
+      bool r = targetm.target_option.valid_attribute_p (new_decl, NULL, v, 0);
+      input_location = saved_loc;
+      if (!r)
+	return NULL;
+    }
+
   /* When the old decl was a con-/destructor make sure the clone isn't.  */
   DECL_STATIC_CONSTRUCTOR (new_decl) = 0;
   DECL_STATIC_DESTRUCTOR (new_decl) = 0;
Index: gcc/df-core.c
===================================================================
--- a/src/gcc/df-core.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/df-core.c	(.../branches/gcc-8-branch)
@@ -298,12 +298,12 @@
 
    Artificial defs and uses occur both at the beginning and ends of blocks.
 
-     For blocks that area at the destination of eh edges, the
+     For blocks that are at the destination of eh edges, the
      artificial uses and defs occur at the beginning.  The defs relate
      to the registers specified in EH_RETURN_DATA_REGNO and the uses
-     relate to the registers specified in ED_USES.  Logically these
+     relate to the registers specified in EH_USES.  Logically these
      defs and uses should really occur along the eh edge, but there is
-     no convenient way to do this.  Artificial edges that occur at the
+     no convenient way to do this.  Artificial defs that occur at the
      beginning of the block have the DF_REF_AT_TOP flag set.
 
      Artificial uses occur at the end of all blocks.  These arise from
Index: gcc/modulo-sched.c
===================================================================
--- a/src/gcc/modulo-sched.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/modulo-sched.c	(.../branches/gcc-8-branch)
@@ -1605,6 +1605,7 @@
       mii = 1; /* Need to pass some estimate of mii.  */
       rec_mii = sms_order_nodes (g, mii, node_order, &max_asap);
       mii = MAX (res_MII (g), rec_mii);
+      mii = MAX (mii, 1);
       maxii = MAX (max_asap, MAXII_FACTOR * mii);
 
       if (dump_file)
@@ -3004,9 +3005,7 @@
             last_must_precede = next_ps_i;
         }
       /* The closing branch must be the last in the row.  */
-      if (must_precede 
-	  && bitmap_bit_p (must_precede, next_ps_i->id)
-	  && JUMP_P (ps_rtl_insn (ps, next_ps_i->id)))
+      if (JUMP_P (ps_rtl_insn (ps, next_ps_i->id)))
 	return false;
              
        last_in_row = next_ps_i;
Index: gcc/xcoffout.c
===================================================================
--- a/src/gcc/xcoffout.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/xcoffout.c	(.../branches/gcc-8-branch)
@@ -64,6 +64,7 @@
 
 char *xcoff_bss_section_name;
 char *xcoff_private_data_section_name;
+char *xcoff_private_rodata_section_name;
 char *xcoff_tls_data_section_name;
 char *xcoff_tbss_section_name;
 char *xcoff_read_only_section_name;
Index: gcc/tree-ssa-math-opts.c
===================================================================
--- a/src/gcc/tree-ssa-math-opts.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-ssa-math-opts.c	(.../branches/gcc-8-branch)
@@ -334,7 +334,8 @@
 	 /* Do not recognize x / x as valid division, as we are getting
 	    confused later by replacing all immediate uses x in such
 	    a stmt.  */
-	 && gimple_assign_rhs1 (use_stmt) != def;
+	 && gimple_assign_rhs1 (use_stmt) != def
+	 && !stmt_can_throw_internal (use_stmt);
 }
 
 /* Return whether USE_STMT is DEF * DEF.  */
@@ -359,13 +360,12 @@
 {
   if (gimple_code (use_stmt) == GIMPLE_ASSIGN
       && gimple_assign_rhs_code (use_stmt) == RDIV_EXPR
-      && gimple_assign_rhs1 (use_stmt) != gimple_assign_rhs2 (use_stmt))
+      && gimple_assign_rhs1 (use_stmt) != gimple_assign_rhs2 (use_stmt)
+      && !stmt_can_throw_internal (use_stmt))
     {
       tree denominator = gimple_assign_rhs2 (use_stmt);
       if (TREE_CODE (denominator) == SSA_NAME)
-	{
-	  return is_square_of (SSA_NAME_DEF_STMT (denominator), def);
-	}
+	return is_square_of (SSA_NAME_DEF_STMT (denominator), def);
     }
   return 0;
 }
@@ -603,7 +603,7 @@
 
   /* If it is more profitable to optimize 1 / x, don't optimize 1 / (x * x).  */
   if (sqrt_recip_count > square_recip_count)
-    return;
+    goto out;
 
   /* Do the expensive part only if we can hope to optimize something.  */
   if (count + square_recip_count >= threshold && count >= 1)
@@ -646,6 +646,7 @@
 	}
     }
 
+out:
   for (occ = occ_head; occ; )
     occ = free_bb (occ);
 
Index: gcc/tree-ssa-dom.c
===================================================================
--- a/src/gcc/tree-ssa-dom.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-ssa-dom.c	(.../branches/gcc-8-branch)
@@ -170,11 +170,10 @@
   gimple *def_stmt = SSA_NAME_DEF_STMT (name);
   if (is_gimple_assign (def_stmt))
     {
-      /* We know the result of DEF_STMT was zero.  See if that allows
-	 us to deduce anything about the SSA_NAMEs used on the RHS.  */
       enum tree_code code = gimple_assign_rhs_code (def_stmt);
       switch (code)
 	{
+	/* If the result of an OR is zero, then its operands are, too.  */
 	case BIT_IOR_EXPR:
 	  if (integer_zerop (value))
 	    {
@@ -188,8 +187,7 @@
 	    }
 	  break;
 
-      /* We know the result of DEF_STMT was one.  See if that allows
-	 us to deduce anything about the SSA_NAMEs used on the RHS.  */
+	/* If the result of an AND is nonzero, then its operands are, too.  */
 	case BIT_AND_EXPR:
 	  if (!integer_zerop (value))
 	    {
@@ -296,7 +294,6 @@
 	    break;
 	  }
 
-
 	case EQ_EXPR:
 	case NE_EXPR:
 	  {
@@ -336,7 +333,28 @@
 	case NEGATE_EXPR:
 	  {
 	    tree rhs = gimple_assign_rhs1 (def_stmt);
-	    tree res = fold_build1 (code, TREE_TYPE (rhs), value);
+	    tree res;
+	    /* If this is a NOT and the operand has a boolean range, then we
+	       know its value must be zero or one.  We are not supposed to
+	       have a BIT_NOT_EXPR for boolean types with precision > 1 in
+	       the general case, see e.g. the handling of TRUTH_NOT_EXPR in
+	       the gimplifier, but it can be generated by match.pd out of
+	       a BIT_XOR_EXPR wrapped in a BIT_AND_EXPR.  Now the handling
+	       of BIT_AND_EXPR above already forces a specific semantics for
+	       boolean types with precision > 1 so we must do the same here,
+	       otherwise we could change the semantics of TRUTH_NOT_EXPR for
+	       boolean types with precision > 1.  */
+	    if (code == BIT_NOT_EXPR
+		&& TREE_CODE (rhs) == SSA_NAME
+		&& ssa_name_has_boolean_range (rhs))
+	      {
+		if ((TREE_INT_CST_LOW (value) & 1) == 0)
+		  res = build_one_cst (TREE_TYPE (rhs));
+		else
+		  res = build_zero_cst (TREE_TYPE (rhs));
+	      }
+	    else
+	      res = fold_build1 (code, TREE_TYPE (rhs), value);
 	    derive_equivalences (rhs, res, recursion_limit - 1);
 	    break;
 	  }
@@ -598,7 +616,7 @@
      various tables mantained by DOM.  Returns the taken edge if
      the statement is a conditional with a statically determined
      value.  */
-  edge optimize_stmt (basic_block, gimple_stmt_iterator);
+  edge optimize_stmt (basic_block, gimple_stmt_iterator *, bool *);
 };
 
 /* Jump threading, redundancy elimination and const/copy propagation.
@@ -1437,10 +1455,48 @@
   m_avail_exprs_stack->pop_to_marker ();
 
   edge taken_edge = NULL;
+  /* Initialize visited flag ahead of us, it has undefined state on
+     pass entry.  */
   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+    gimple_set_visited (gsi_stmt (gsi), false);
+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)
     {
+      /* Do not optimize a stmt twice, substitution might end up with
+         _3 = _3 which is not valid.  */
+      if (gimple_visited_p (gsi_stmt (gsi)))
+	{
+	  gsi_next (&gsi);
+	  continue;
+	}
+
+      /* Compute range information and optimize the stmt.  */
       evrp_range_analyzer.record_ranges_from_stmt (gsi_stmt (gsi), false);
-      taken_edge = this->optimize_stmt (bb, gsi);
+      bool removed_p = false;
+      taken_edge = this->optimize_stmt (bb, &gsi, &removed_p);
+      if (!removed_p)
+	gimple_set_visited (gsi_stmt (gsi), true);
+
+      /* Go back and visit stmts inserted by folding after substituting
+	 into the stmt at gsi.  */
+      if (gsi_end_p (gsi))
+	{
+	  gcc_checking_assert (removed_p);
+	  gsi = gsi_last_bb (bb);
+	  while (!gsi_end_p (gsi) && !gimple_visited_p (gsi_stmt (gsi)))
+	    gsi_prev (&gsi);
+	}
+      else
+	{
+	  do
+	    {
+	      gsi_prev (&gsi);
+	    }
+	  while (!gsi_end_p (gsi) && !gimple_visited_p (gsi_stmt (gsi)));
+	}
+      if (gsi_end_p (gsi))
+	gsi = gsi_start_bb (bb);
+      else
+	gsi_next (&gsi);
     }
 
   /* Now prepare to process dominated blocks.  */
@@ -1905,7 +1961,8 @@
       condition to an equality condition.  */
 
 edge
-dom_opt_dom_walker::optimize_stmt (basic_block bb, gimple_stmt_iterator si)
+dom_opt_dom_walker::optimize_stmt (basic_block bb, gimple_stmt_iterator *si,
+				   bool *removed_p)
 {
   gimple *stmt, *old_stmt;
   bool may_optimize_p;
@@ -1913,7 +1970,7 @@
   bool was_noreturn;
   edge retval = NULL;
 
-  old_stmt = stmt = gsi_stmt (si);
+  old_stmt = stmt = gsi_stmt (*si);
   was_noreturn = is_gimple_call (stmt) && gimple_call_noreturn_p (stmt);
 
   if (dump_file && (dump_flags & TDF_DETAILS))
@@ -1936,9 +1993,9 @@
 
       /* Try to fold the statement making sure that STMT is kept
 	 up to date.  */
-      if (fold_stmt (&si))
+      if (fold_stmt (si))
 	{
-	  stmt = gsi_stmt (si);
+	  stmt = gsi_stmt (*si);
 	  gimple_set_modified (stmt, true);
 
 	  if (dump_file && (dump_flags & TDF_DETAILS))
@@ -1987,8 +2044,8 @@
 	      && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL
 	      && DECL_FUNCTION_CODE (callee) == BUILT_IN_CONSTANT_P)
 	    {
-	      propagate_tree_value_into_stmt (&si, integer_zero_node);
-	      stmt = gsi_stmt (si);
+	      propagate_tree_value_into_stmt (si, integer_zero_node);
+	      stmt = gsi_stmt (*si);
 	    }
 	}
 
@@ -2044,9 +2101,9 @@
 	}
 
       update_stmt_if_modified (stmt);
-      eliminate_redundant_computations (&si, m_const_and_copies,
+      eliminate_redundant_computations (si, m_const_and_copies,
 					m_avail_exprs_stack);
-      stmt = gsi_stmt (si);
+      stmt = gsi_stmt (*si);
 
       /* Perform simple redundant store elimination.  */
       if (gimple_assign_single_p (stmt)
@@ -2073,7 +2130,7 @@
 	    {
 	      basic_block bb = gimple_bb (stmt);
 	      unlink_stmt_vdef (stmt);
-	      if (gsi_remove (&si, true))
+	      if (gsi_remove (si, true))
 		{
 		  bitmap_set_bit (need_eh_cleanup, bb->index);
 		  if (dump_file && (dump_flags & TDF_DETAILS))
@@ -2080,6 +2137,7 @@
 		    fprintf (dump_file, "  Flagged to clear EH edges.\n");
 		}
 	      release_defs (stmt);
+	      *removed_p = true;
 	      return retval;
 	    }
 	}
Index: gcc/xcoffout.h
===================================================================
--- a/src/gcc/xcoffout.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/xcoffout.h	(.../branches/gcc-8-branch)
@@ -127,6 +127,7 @@
 
 extern char *xcoff_bss_section_name;
 extern char *xcoff_private_data_section_name;
+extern char *xcoff_private_rodata_section_name;
 extern char *xcoff_tls_data_section_name;
 extern char *xcoff_tbss_section_name;
 extern char *xcoff_read_only_section_name;
Index: gcc/gimple-ssa-warn-restrict.c
===================================================================
--- a/src/gcc/gimple-ssa-warn-restrict.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/gimple-ssa-warn-restrict.c	(.../branches/gcc-8-branch)
@@ -314,13 +314,9 @@
 	  offrange[0] += offset_int::from (min, SIGNED);
 	  offrange[1] += offset_int::from (max, SIGNED);
 	}
-      else if (rng == VR_ANTI_RANGE)
-	{
-	  offrange[0] += offset_int::from (max + 1, SIGNED);
-	  offrange[1] += offset_int::from (min - 1, SIGNED);
-	}
       else
 	{
+	  /* Handle an anti-range the same as no range at all.  */
 	  gimple *stmt = SSA_NAME_DEF_STMT (offset);
 	  tree type;
 	  if (is_gimple_assign (stmt)
@@ -702,6 +698,10 @@
   offset_int bounds[2] = { maxobjsize, maxobjsize };
   if (dstref->strbounded_p)
     {
+      unsigned nargs = gimple_call_num_args (call);
+      if (nargs <= sizeargno)
+	return;
+
       tree size = gimple_call_arg (call, sizeargno);
       tree range[2];
       if (get_size_range (size, range, true))
Index: gcc/lto-wrapper.c
===================================================================
--- a/src/gcc/lto-wrapper.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/lto-wrapper.c	(.../branches/gcc-8-branch)
@@ -1669,7 +1669,9 @@
 	  struct pex_obj *pex;
 	  char jobs[32];
 
-	  fprintf (mstream, "all:");
+	  fprintf (mstream,
+		   ".PHONY: all\n"
+		   "all:");
 	  for (i = 0; i < nr; ++i)
 	    {
 	      int j = ltrans_priorities[i*2 + 1];
Index: gcc/dwarf2out.c
===================================================================
--- a/src/gcc/dwarf2out.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/dwarf2out.c	(.../branches/gcc-8-branch)
@@ -2875,9 +2875,13 @@
    separate comdat sections since the linker will then be able to
    remove duplicates.  But not all tools support .debug_types sections
    yet.  For Dwarf V5 or higher .debug_types doesn't exist any more,
-   it is DW_UT_type unit type in .debug_info section.  */
+   it is DW_UT_type unit type in .debug_info section.  For late LTO
+   debug there should be almost no types emitted so avoid enabling
+   -fdebug-types-section there.  */
 
-#define use_debug_types (dwarf_version >= 4 && flag_debug_types_section)
+#define use_debug_types (dwarf_version >= 4 \
+			 && flag_debug_types_section \
+			 && !in_lto_p)
 
 /* Various DIE's use offsets relative to the beginning of the
    .debug_info section to refer to each other.  */
@@ -3713,7 +3717,7 @@
 static void output_die (dw_die_ref);
 static void output_compilation_unit_header (enum dwarf_unit_type);
 static void output_comp_unit (dw_die_ref, int, const unsigned char *);
-static void output_comdat_type_unit (comdat_type_node *);
+static void output_comdat_type_unit (comdat_type_node *, bool);
 static const char *dwarf2_name (tree, int);
 static void add_pubname (tree, dw_die_ref);
 static void add_enumerator_pubname (const char *, dw_die_ref);
@@ -9339,7 +9343,6 @@
 	  }
 	  break;
 	case dw_val_class_loc_list:
-	case dw_val_class_view_list:
 	  if (dwarf_split_debug_info && dwarf_version >= 5)
 	    {
 	      gcc_assert (AT_loc_list (a)->num_assigned);
@@ -9348,6 +9351,9 @@
           else
             size += DWARF_OFFSET_SIZE;
 	  break;
+	case dw_val_class_view_list:
+	  size += DWARF_OFFSET_SIZE;
+	  break;
 	case dw_val_class_range_list:
 	  if (value_format (a) == DW_FORM_rnglistx)
 	    {
@@ -9425,7 +9431,7 @@
 		 we use DW_FORM_ref_addr.  In DWARF2, DW_FORM_ref_addr
 		 is sized by target address length, whereas in DWARF3
 		 it's always sized as an offset.  */
-	      if (use_debug_types)
+	      if (AT_ref (a)->comdat_type_p)
 		size += DWARF_TYPE_SIGNATURE_SIZE;
 	      else if (dwarf_version == 2)
 		size += DWARF2_ADDR_SIZE;
@@ -9721,12 +9727,12 @@
 	  gcc_unreachable ();
 	}
     case dw_val_class_loc_list:
-    case dw_val_class_view_list:
       if (dwarf_split_debug_info
 	  && dwarf_version >= 5
 	  && AT_loc_list (a)->num_assigned)
 	return DW_FORM_loclistx;
       /* FALLTHRU */
+    case dw_val_class_view_list:
     case dw_val_class_range_list:
       /* For range lists in DWARF 5, use DW_FORM_rnglistx from .debug_info.dwo
 	 but in .debug_info use DW_FORM_sec_offset, which is shorter if we
@@ -9869,7 +9875,12 @@
       return DW_FORM_flag;
     case dw_val_class_die_ref:
       if (AT_ref_external (a))
-	return use_debug_types ? DW_FORM_ref_sig8 : DW_FORM_ref_addr;
+	{
+	  if (AT_ref (a)->comdat_type_p)
+	    return DW_FORM_ref_sig8;
+	  else
+	    return DW_FORM_ref_addr;
+	}
       else
 	return DW_FORM_ref;
     case dw_val_class_fde_ref:
@@ -11217,7 +11228,8 @@
 /* Output a comdat type unit DIE and its children.  */
 
 static void
-output_comdat_type_unit (comdat_type_node *node)
+output_comdat_type_unit (comdat_type_node *node,
+			 bool early_lto_debug ATTRIBUTE_UNUSED)
 {
   const char *secname;
   char *tmp;
@@ -11244,14 +11256,16 @@
   if (dwarf_version >= 5)
     {
       if (!dwarf_split_debug_info)
-	secname = ".debug_info";
+	secname = early_lto_debug ? DEBUG_LTO_INFO_SECTION : DEBUG_INFO_SECTION;
       else
-	secname = ".debug_info.dwo";
+	secname = (early_lto_debug
+		   ? DEBUG_LTO_DWO_INFO_SECTION : DEBUG_DWO_INFO_SECTION);
     }
   else if (!dwarf_split_debug_info)
-    secname = ".debug_types";
+    secname = early_lto_debug ? ".gnu.debuglto_.debug_types" : ".debug_types";
   else
-    secname = ".debug_types.dwo";
+    secname = (early_lto_debug
+	       ? ".gnu.debuglto_.debug_types.dwo" : ".debug_types.dwo");
 
   tmp = XALLOCAVEC (char, 4 + DWARF_TYPE_SIGNATURE_SIZE * 2);
   sprintf (tmp, dwarf_version >= 5 ? "wi." : "wt.");
@@ -17879,6 +17893,8 @@
 	case DW_OP_push_object_address:
 	case DW_OP_call_frame_cfa:
 	case DW_OP_GNU_variable_value:
+	case DW_OP_GNU_addr_index:
+	case DW_OP_GNU_const_index:
 	  ++frame_offset_;
 	  break;
 
@@ -19661,6 +19677,9 @@
 
     case HIGH:
     case CONST_FIXED:
+    case MINUS:
+    case SIGN_EXTEND:
+    case ZERO_EXTEND:
       return false;
 
     case MEM:
@@ -31398,7 +31417,7 @@
                          ? dl_section_ref
                          : debug_skeleton_line_section_label));
 
-      output_comdat_type_unit (ctnode);
+      output_comdat_type_unit (ctnode, false);
       *slot = ctnode;
     }
 
@@ -32039,7 +32058,7 @@
                          ? debug_line_section_label
                          : debug_skeleton_line_section_label));
 
-      output_comdat_type_unit (ctnode);
+      output_comdat_type_unit (ctnode, true);
       *slot = ctnode;
     }
 
Index: gcc/expr.c
===================================================================
--- a/src/gcc/expr.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/expr.c	(.../branches/gcc-8-branch)
@@ -5187,9 +5187,13 @@
 		}
 	      else
 		{
-		  rtx from_rtx
-		    = simplify_gen_subreg (to_mode, result,
-					   TYPE_MODE (TREE_TYPE (from)), 0);
+		  rtx from_rtx;
+		  if (MEM_P (result))
+		    from_rtx = change_address (result, to_mode, NULL_RTX);
+		  else
+		    from_rtx
+		      = simplify_gen_subreg (to_mode, result,
+					     TYPE_MODE (TREE_TYPE (from)), 0);
 		  if (from_rtx)
 		    {
 		      emit_move_insn (XEXP (to_rtx, 0),
@@ -5258,6 +5262,7 @@
 		MEM_VOLATILE_P (to_rtx) = 1;
 	    }
 
+	  gcc_checking_assert (known_ge (bitpos, 0));
 	  if (optimize_bitfield_assignment_op (bitsize, bitpos,
 					       bitregion_start, bitregion_end,
 					       mode1, to_rtx, to, from,
@@ -7115,6 +7120,7 @@
 	}
 
       /* Store the value in the bitfield.  */
+      gcc_assert (known_ge (bitpos, 0));
       store_bit_field (target, bitsize, bitpos,
 		       bitregion_start, bitregion_end,
 		       mode, temp, reverse);
@@ -10658,6 +10664,14 @@
 	mode2
 	  = CONSTANT_P (op0) ? TYPE_MODE (TREE_TYPE (tem)) : GET_MODE (op0);
 
+	/* Make sure bitpos is not negative, it can wreak havoc later.  */
+	if (maybe_lt (bitpos, 0))
+	  {
+	    gcc_checking_assert (offset == NULL_TREE);
+	    offset = size_int (bits_to_bytes_round_down (bitpos));
+	    bitpos = num_trailing_bits (bitpos);
+	  }
+
 	/* If we have either an offset, a BLKmode result, or a reference
 	   outside the underlying object, we must force it to memory.
 	   Such a case can occur in Ada if we have unchecked conversion
@@ -10906,6 +10920,7 @@
 		&& GET_MODE_CLASS (ext_mode) == MODE_INT)
 	      reversep = TYPE_REVERSE_STORAGE_ORDER (type);
 
+	    gcc_checking_assert (known_ge (bitpos, 0));
 	    op0 = extract_bit_field (op0, bitsize, bitpos, unsignedp,
 				     (modifier == EXPAND_STACK_PARM
 				      ? NULL_RTX : target),
Index: gcc/opts.c
===================================================================
--- a/src/gcc/opts.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/opts.c	(.../branches/gcc-8-branch)
@@ -922,6 +922,14 @@
 		      "linker plugin");
 	  opts->x_flag_fat_lto_objects = 1;
 	}
+
+      /* -gsplit-dwarf isn't compatible with LTO, see PR88389.  */
+      if (opts->x_dwarf_split_debug_info)
+	{
+	  inform (loc, "%<-gsplit-dwarf%> is not supported with LTO,"
+		  " disabling");
+	  opts->x_dwarf_split_debug_info = 0;
+	}
     }
 
   /* We initialize opts->x_flag_split_stack to -1 so that targets can set a
Index: gcc/tree-ssa-loop-ivcanon.c
===================================================================
--- a/src/gcc/tree-ssa-loop-ivcanon.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-ssa-loop-ivcanon.c	(.../branches/gcc-8-branch)
@@ -1177,7 +1177,7 @@
 	= niter_desc.may_be_zero && !integer_zerop (niter_desc.may_be_zero);
     }
   if (TREE_CODE (niter) == INTEGER_CST)
-    locus = gimple_location (last_stmt (exit->src));
+    locus = gimple_location_safe (last_stmt (exit->src));
   else
     {
       /* For non-constant niter fold may_be_zero into niter again.  */
@@ -1204,7 +1204,7 @@
 	niter = find_loop_niter_by_eval (loop, &exit);
 
       if (exit)
-        locus = gimple_location (last_stmt (exit->src));
+        locus = gimple_location_safe (last_stmt (exit->src));
 
       if (TREE_CODE (niter) != INTEGER_CST)
 	exit = NULL;
Index: gcc/recog.c
===================================================================
--- a/src/gcc/recog.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/recog.c	(.../branches/gcc-8-branch)
@@ -1070,6 +1070,11 @@
 int
 address_operand (rtx op, machine_mode mode)
 {
+  /* Wrong mode for an address expr.  */
+  if (GET_MODE (op) != VOIDmode
+      && ! SCALAR_INT_MODE_P (GET_MODE (op)))
+    return false;
+
   return memory_address_p (mode, op);
 }
 
@@ -2695,10 +2700,13 @@
 		/* p is used for address_operands.  When we are called by
 		   gen_reload, no one will have checked that the address is
 		   strictly valid, i.e., that all pseudos requiring hard regs
-		   have gotten them.  */
-		if (strict <= 0
-		    || (strict_memory_address_p (recog_data.operand_mode[opno],
-						 op)))
+		   have gotten them.  We also want to make sure we have a
+		   valid mode.  */
+		if ((GET_MODE (op) == VOIDmode
+		     || SCALAR_INT_MODE_P (GET_MODE (op)))
+		    && (strict <= 0
+			|| (strict_memory_address_p
+			     (recog_data.operand_mode[opno], op))))
 		  win = 1;
 		break;
 
Index: gcc/ada/ChangeLog
===================================================================
--- a/src/gcc/ada/ChangeLog	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/ada/ChangeLog	(.../branches/gcc-8-branch)
@@ -1,3 +1,62 @@
+2019-06-29  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity): Beep up comment on SAVED,
+	and tweak comment on the assertion about the scopes of Itypes.  Do not
+	skip the regular processing for Itypes that are E_Record_Subtype with
+	a Cloned_Subtype.  Get the Cloned_Subtype for every E_Record_Subtype
+	if the type is dummy and hasn't got its own freeze node.
+	<E_Record_Subtype>: Save again the DECL of the Cloned_Subtype, if any.
+	<E_Access_Subtype>: Save again the DECL of the equivalent type.
+	(Gigi_Equivalent_Type) <E_Access_Subtype>: New case.
+
+2019-06-29  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (mark_visited_r): Set TYPE_SIZES_GIMPLIFIED on
+	the main variant of a type, if any.
+
+2019-06-29  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (set_nonaliased_component_on_array_type): Add
+	missing guard for the presence of TYPE_CANONICAL.
+	(set_reverse_storage_order_on_array_type): Likewise.
+
+2019-06-17  Arnaud Charlet  <charlet@adacore.com>
+
+	PR ada/80590
+	* exp_ch9.adb (Expand_N_Delay_Relative_Statement): Swap the two
+	conditions to avoid a unnecessary exception propagation in the default
+	case.
+
+2019-05-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (walk_nesting_tree): New static function.
+	(finalize_nrv): Use it to walk the entire nesting tree.
+
+2019-05-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/utils.c (maybe_pad_type): Issue the warning for the
+	specific case of component types preferably.
+
+2019-05-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (Call_to_gnu): Use the unpadded type when
+	putting back an intermediate conversion the type of the actuals.
+
+2019-05-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gcc-interface/Makefile.in (install-gcc-specs): Use foreach.
+	Honor DESTDIR.
+
+2019-02-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/89349
+	Backport from mainline
+	2018-05-25  Arnaud Charlet  <charlet@adacore.com>
+
+	* osint.ads (Unknown_Attributes): No longer pretend this is a constant.
+	(No_File_Info_Cache): Initialize separately.
+	* osint.adb (No_File_Info_Cache): Update initializer.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: gcc/ada/gcc-interface/utils.c
===================================================================
--- a/src/gcc/ada/gcc-interface/utils.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/ada/gcc-interface/utils.c	(.../branches/gcc-8-branch)
@@ -1519,14 +1519,14 @@
 	 generated for some other corresponding source entity.  */
       if (Comes_From_Source (gnat_entity))
 	{
-	  if (Present (gnat_error_node))
+	  if (is_component_type)
+	    post_error_ne_tree ("component of& padded{ by ^ bits}?",
+				gnat_entity, gnat_entity,
+				size_diffop (size, orig_size));
+	  else if (Present (gnat_error_node))
 	    post_error_ne_tree ("{^ }bits of & unused?",
 				gnat_error_node, gnat_entity,
 				size_diffop (size, orig_size));
-	  else if (is_component_type)
-	    post_error_ne_tree ("component of& padded{ by ^ bits}?",
-				gnat_entity, gnat_entity,
-				size_diffop (size, orig_size));
 	}
     }
 
Index: gcc/ada/gcc-interface/Makefile.in
===================================================================
--- a/src/gcc/ada/gcc-interface/Makefile.in	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/ada/gcc-interface/Makefile.in	(.../branches/gcc-8-branch)
@@ -2285,9 +2285,8 @@
 install-gcc-specs:
 #	Install all the requested GCC spec files.
 
-	for f in $(GCC_SPEC_FILES); do \
-	    $(INSTALL_DATA_DATE) $(srcdir)/ada/$$f $(libsubdir)/; \
-	done
+	$(foreach f,$(GCC_SPEC_FILES), \
+	    $(INSTALL_DATA_DATE) $(srcdir)/ada/$(f) $(DESTDIR)$(libsubdir)/;)
 
 install-gnatlib: ../stamp-gnatlib-$(RTSDIR) install-gcc-specs
 	$(RMDIR) $(DESTDIR)$(ADA_RTL_OBJ_DIR)
Index: gcc/ada/gcc-interface/decl.c
===================================================================
--- a/src/gcc/ada/gcc-interface/decl.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/ada/gcc-interface/decl.c	(.../branches/gcc-8-branch)
@@ -295,7 +295,10 @@
   tree gnu_size = NULL_TREE;
   /* Contains the GCC name to be used for the GCC node.  */
   tree gnu_entity_name;
-  /* True if we have already saved gnu_decl as a GNAT association.  */
+  /* True if we have already saved gnu_decl as a GNAT association.  This can
+     also be used to purposely avoid making such an association but this use
+     case ought not to be applied to types because it can break the deferral
+     mechanism implemented for access types.  */
   bool saved = false;
   /* True if we incremented defer_incomplete_level.  */
   bool this_deferred = false;
@@ -312,14 +315,11 @@
 
   /* Since a use of an Itype is a definition, process it as such if it is in
      the main unit, except for E_Access_Subtype because it's actually a use
-     of its base type, and for E_Record_Subtype with cloned subtype because
-     it's actually a use of the cloned subtype, see below.  */
+     of its base type, see below.  */
   if (!definition
       && is_type
       && Is_Itype (gnat_entity)
-      && !(kind == E_Access_Subtype
-	   || (kind == E_Record_Subtype
-	       && Present (Cloned_Subtype (gnat_entity))))
+      && Ekind (gnat_entity) != E_Access_Subtype
       && !present_gnu_tree (gnat_entity)
       && In_Extended_Main_Code_Unit (gnat_entity))
     {
@@ -362,7 +362,7 @@
 	}
 
       /* This abort means the Itype has an incorrect scope, i.e. that its
-	 scope does not correspond to the subprogram it is declared in.  */
+	 scope does not correspond to the subprogram it is first used in.  */
       gcc_unreachable ();
     }
 
@@ -371,7 +371,9 @@
      In that case, we will abort below when we try to save a new GCC tree
      for this object.  We also need to handle the case of getting a dummy
      type when a Full_View exists but be careful so as not to trigger its
-     premature elaboration.  */
+     premature elaboration.  Likewise for a cloned subtype without its own
+     freeze node, which typically happens when a generic gets instantiated
+     on an incomplete or private type.  */
   if ((!definition || (is_type && imported_p))
       && present_gnu_tree (gnat_entity))
     {
@@ -385,11 +387,27 @@
 	      || No (Freeze_Node (Full_View (gnat_entity)))))
 	{
 	  gnu_decl
-	    = gnat_to_gnu_entity (Full_View (gnat_entity), NULL_TREE, false);
+	    = gnat_to_gnu_entity (Full_View (gnat_entity), NULL_TREE,
+				  false);
 	  save_gnu_tree (gnat_entity, NULL_TREE, false);
 	  save_gnu_tree (gnat_entity, gnu_decl, false);
 	}
 
+      if (TREE_CODE (gnu_decl) == TYPE_DECL
+	  && TYPE_IS_DUMMY_P (TREE_TYPE (gnu_decl))
+	  && Ekind (gnat_entity) == E_Record_Subtype
+	  && No (Freeze_Node (gnat_entity))
+	  && Present (Cloned_Subtype (gnat_entity))
+	  && (present_gnu_tree (Cloned_Subtype (gnat_entity))
+	      || No (Freeze_Node (Cloned_Subtype (gnat_entity)))))
+	{
+	  gnu_decl
+	    = gnat_to_gnu_entity (Cloned_Subtype (gnat_entity), NULL_TREE,
+				  false);
+	  save_gnu_tree (gnat_entity, NULL_TREE, false);
+	  save_gnu_tree (gnat_entity, gnu_decl, false);
+	}
+
       return gnu_decl;
     }
 
@@ -3367,13 +3385,13 @@
     case E_Record_Subtype:
       /* If Cloned_Subtype is Present it means this record subtype has
 	 identical layout to that type or subtype and we should use
-	 that GCC type for this one.  The front end guarantees that
+	 that GCC type for this one.  The front-end guarantees that
 	 the component list is shared.  */
       if (Present (Cloned_Subtype (gnat_entity)))
 	{
 	  gnu_decl = gnat_to_gnu_entity (Cloned_Subtype (gnat_entity),
 					 NULL_TREE, false);
-	  saved = true;
+	  maybe_present = true;
 	  break;
 	}
 
@@ -3787,8 +3805,8 @@
     case E_Access_Subtype:
       /* We treat this as identical to its base type; any constraint is
 	 meaningful only to the front-end.  */
-      gnu_decl = gnat_to_gnu_entity (Etype (gnat_entity), NULL_TREE, false);
-      saved = true;
+      gnu_decl = gnat_to_gnu_entity (gnat_equiv_type, NULL_TREE, false);
+      maybe_present = true;
 
       /* The designated subtype must be elaborated as well, if it does
 	 not have its own freeze node.  But designated subtypes created
@@ -4974,6 +4992,10 @@
 	gnat_equiv = Equivalent_Type (gnat_entity);
       break;
 
+    case E_Access_Subtype:
+      gnat_equiv = Etype (gnat_entity);
+      break;
+
     case E_Class_Wide_Type:
       gnat_equiv = Root_Type (gnat_entity);
       break;
@@ -6065,7 +6087,8 @@
 set_nonaliased_component_on_array_type (tree type)
 {
   TYPE_NONALIASED_COMPONENT (type) = 1;
-  TYPE_NONALIASED_COMPONENT (TYPE_CANONICAL (type)) = 1;
+  if (TYPE_CANONICAL (type))
+    TYPE_NONALIASED_COMPONENT (TYPE_CANONICAL (type)) = 1;
 }
 
 /* Set TYPE_REVERSE_STORAGE_ORDER on an array type built by means of
@@ -6075,7 +6098,8 @@
 set_reverse_storage_order_on_array_type (tree type)
 {
   TYPE_REVERSE_STORAGE_ORDER (type) = 1;
-  TYPE_REVERSE_STORAGE_ORDER (TYPE_CANONICAL (type)) = 1;
+  if (TYPE_CANONICAL (type))
+    TYPE_REVERSE_STORAGE_ORDER (TYPE_CANONICAL (type)) = 1;
 }
 
 /* Return true if DISCR1 and DISCR2 represent the same discriminant.  */
Index: gcc/ada/gcc-interface/trans.c
===================================================================
--- a/src/gcc/ada/gcc-interface/trans.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/ada/gcc-interface/trans.c	(.../branches/gcc-8-branch)
@@ -3534,6 +3534,20 @@
   return NULL_TREE;
 }
 
+/* Apply FUNC to all the sub-trees of nested functions in NODE.  FUNC is called
+   with the DATA and the address of each sub-tree.  If FUNC returns a non-NULL
+   value, the traversal is stopped.  */
+
+static void
+walk_nesting_tree (struct cgraph_node *node, walk_tree_fn func, void *data)
+{
+  for (node = node->nested; node; node = node->next_nested)
+    {
+      walk_tree_without_duplicates (&DECL_SAVED_TREE (node->decl), func, data);
+      walk_nesting_tree (node, func, data);
+    }
+}
+
 /* Finalize the Named Return Value optimization for FNDECL.  The NRV bitmap
    contains the candidates for Named Return Value and OTHER is a list of
    the other return values.  GNAT_RET is a representative return node.  */
@@ -3541,7 +3555,6 @@
 static void
 finalize_nrv (tree fndecl, bitmap nrv, vec<tree, va_gc> *other, Node_Id gnat_ret)
 {
-  struct cgraph_node *node;
   struct nrv_data data;
   walk_tree_fn func;
   unsigned int i;
@@ -3562,10 +3575,7 @@
     return;
 
   /* Prune also the candidates that are referenced by nested functions.  */
-  node = cgraph_node::get_create (fndecl);
-  for (node = node->nested; node; node = node->next_nested)
-    walk_tree_without_duplicates (&DECL_SAVED_TREE (node->decl), prune_nrv_r,
-				  &data);
+  walk_nesting_tree (cgraph_node::get_create (fndecl), prune_nrv_r, &data);
   if (bitmap_empty_p (nrv))
     return;
 
@@ -4575,7 +4585,7 @@
 	 since the parent is a procedure call, so put it back here.  Note that
 	 we might have a dummy type here if the actual is the dereference of a
 	 pointer to it, but that's OK if the formal is passed by reference.  */
-      tree gnu_actual_type = gnat_to_gnu_type (Etype (gnat_actual));
+      tree gnu_actual_type = get_unpadded_type (Etype (gnat_actual));
       if (TYPE_IS_DUMMY_P (gnu_actual_type))
 	gcc_assert (is_true_formal_parm && DECL_BY_REF_P (gnu_formal));
       else if (suppress_type_conversion
@@ -8167,8 +8177,9 @@
   else if (!TYPE_IS_DUMMY_P (t))
     TREE_VISITED (t) = 1;
 
+  /* The test in gimplify_type_sizes is on the main variant.  */
   if (TYPE_P (t))
-    TYPE_SIZES_GIMPLIFIED (t) = 1;
+    TYPE_SIZES_GIMPLIFIED (TYPE_MAIN_VARIANT (t)) = 1;
 
   return NULL_TREE;
 }
Index: gcc/ada/exp_ch9.adb
===================================================================
--- a/src/gcc/ada/exp_ch9.adb	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/ada/exp_ch9.adb	(.../branches/gcc-8-branch)
@@ -8144,18 +8144,17 @@
       Proc : Entity_Id;
 
    begin
-      --  Try to use System.Relative_Delays.Delay_For only if available. This
-      --  is the implementation used on restricted platforms when Ada.Calendar
-      --  is not available.
+      --  Try to use Ada.Calendar.Delays.Delay_For if available.
 
-      if RTE_Available (RO_RD_Delay_For) then
-         Proc := RTE (RO_RD_Delay_For);
+      if RTE_Available (RO_CA_Delay_For) then
+         Proc := RTE (RO_CA_Delay_For);
 
-      --  Otherwise, use Ada.Calendar.Delays.Delay_For and emit an error
-      --  message if not available.
+      --  Otherwise, use System.Relative_Delays.Delay_For and emit an error
+      --  message if not available. This is the implementation used on
+      --  restricted platforms when Ada.Calendar is not available.
 
       else
-         Proc := RTE (RO_CA_Delay_For);
+         Proc := RTE (RO_RD_Delay_For);
       end if;
 
       Rewrite (N,
Index: gcc/ada/osint.adb
===================================================================
--- a/src/gcc/ada/osint.adb	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/ada/osint.adb	(.../branches/gcc-8-branch)
@@ -250,8 +250,7 @@
       Attr : aliased File_Attributes;
    end record;
 
-   No_File_Info_Cache : constant File_Info_Cache :=
-                          (No_File, Unknown_Attributes);
+   No_File_Info_Cache : constant File_Info_Cache := (No_File, (others => 0));
 
    package File_Name_Hash_Table is new GNAT.HTable.Simple_HTable (
      Header_Num => File_Hash_Num,
Index: gcc/ada/osint.ads
===================================================================
--- a/src/gcc/ada/osint.ads	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/ada/osint.ads	(.../branches/gcc-8-branch)
@@ -255,10 +255,26 @@
    --  from the disk and then cached in the File_Attributes parameter (possibly
    --  along with other values).
 
-   type File_Attributes is private;
-   Unknown_Attributes : constant File_Attributes;
+   File_Attributes_Size : constant Natural := 32;
+   --  This should be big enough to fit a "struct file_attributes" on any
+   --  system. It doesn't cause any malfunction if it is too big (which avoids
+   --  the need for either mapping the struct exactly or importing the sizeof
+   --  from C, which would result in dynamic code). However, it does waste
+   --  space (e.g. when a component of this type appears in a record, if it is
+   --  unnecessarily large). Note: for runtime units, use System.OS_Constants.
+   --  SIZEOF_struct_file_attributes instead, which has the exact value.
+
+   type File_Attributes is
+     array (1 .. File_Attributes_Size)
+       of System.Storage_Elements.Storage_Element;
+   for File_Attributes'Alignment use Standard'Maximum_Alignment;
+
+   Unknown_Attributes : File_Attributes;
    --  A cache for various attributes for a file (length, accessibility,...)
-   --  This must be initialized to Unknown_Attributes prior to the first call.
+   --  Will be initialized properly at elaboration (for efficiency later on,
+   --  avoid function calls every time we want to reset the attributes) prior
+   --  to the first usage. We cannot make it constant since the compiler may
+   --  put it in a read-only section.
 
    function Is_Directory
      (Name : C_File_Name;
@@ -754,22 +770,4 @@
    --  detected, the file being written is deleted, and a fatal error is
    --  signalled.
 
-   File_Attributes_Size : constant Natural := 32;
-   --  This should be big enough to fit a "struct file_attributes" on any
-   --  system. It doesn't cause any malfunction if it is too big (which avoids
-   --  the need for either mapping the struct exactly or importing the sizeof
-   --  from C, which would result in dynamic code). However, it does waste
-   --  space (e.g. when a component of this type appears in a record, if it is
-   --  unnecessarily large). Note: for runtime units, use System.OS_Constants.
-   --  SIZEOF_struct_file_attributes instead, which has the exact value.
-
-   type File_Attributes is
-     array (1 .. File_Attributes_Size)
-       of System.Storage_Elements.Storage_Element;
-   for File_Attributes'Alignment use Standard'Maximum_Alignment;
-
-   Unknown_Attributes : constant File_Attributes := (others => 0);
-   --  Will be initialized properly at elaboration (for efficiency later on,
-   --  avoid function calls every time we want to reset the attributes).
-
 end Osint;
Index: gcc/tree-ssa-address.c
===================================================================
--- a/src/gcc/tree-ssa-address.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-ssa-address.c	(.../branches/gcc-8-branch)
@@ -259,6 +259,20 @@
 	 ? expand_expr (addr->index, NULL_RTX, pointer_mode, EXPAND_NORMAL)
 	 : NULL_RTX);
 
+  /* addr->base could be an SSA_NAME that was set to a constant value.  The
+     call to expand_expr may expose that constant.  If so, fold the value
+     into OFF and clear BSE.  Otherwise we may later try to pull a mode from
+     BSE to generate a REG, which won't work with constants because they
+     are modeless.  */
+  if (bse && GET_CODE (bse) == CONST_INT)
+    {
+      if (off)
+	off = simplify_gen_binary (PLUS, pointer_mode, bse, off);
+      else
+	off = bse;
+      gcc_assert (GET_CODE (off) == CONST_INT);
+      bse = NULL_RTX;
+    }
   gen_addr_rtx (pointer_mode, sym, bse, idx, st, off, &address, NULL, NULL);
   if (pointer_mode != address_mode)
     address = convert_memory_address (address_mode, address);
Index: gcc/common/config/aarch64/aarch64-common.c
===================================================================
--- a/src/gcc/common/config/aarch64/aarch64-common.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/common/config/aarch64/aarch64-common.c	(.../branches/gcc-8-branch)
@@ -41,6 +41,8 @@
 
 #undef	TARGET_OPTION_OPTIMIZATION_TABLE
 #define TARGET_OPTION_OPTIMIZATION_TABLE aarch_option_optimization_table
+#undef TARGET_OPTION_INIT_STRUCT
+#define TARGET_OPTION_INIT_STRUCT aarch64_option_init_struct
 
 /* Set default optimization options.  */
 static const struct default_options aarch_option_optimization_table[] =
@@ -113,8 +115,6 @@
     }
 }
 
-struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;
-
 /* An ISA extension in the co-processor and main instruction set space.  */
 struct aarch64_option_extension
 {
@@ -122,17 +122,30 @@
   const unsigned long flag_canonical;
   const unsigned long flags_on;
   const unsigned long flags_off;
+  const bool is_synthetic;
 };
 
 /* ISA extensions in AArch64.  */
 static const struct aarch64_option_extension all_extensions[] =
 {
-#define AARCH64_OPT_EXTENSION(NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, Z) \
-  {NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF},
+#define AARCH64_OPT_EXTENSION(NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, \
+			      SYNTHETIC, Z) \
+  {NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, SYNTHETIC},
 #include "config/aarch64/aarch64-option-extensions.def"
-  {NULL, 0, 0, 0}
+  {NULL, 0, 0, 0, false}
 };
 
+/* A copy of the ISA extensions list for AArch64 sorted by the popcount of
+   bits and extension turned on.  Cached for efficiency.  */
+static struct aarch64_option_extension all_extensions_by_on[] =
+{
+#define AARCH64_OPT_EXTENSION(NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, \
+			      SYNTHETIC, Z) \
+  {NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, SYNTHETIC},
+#include "config/aarch64/aarch64-option-extensions.def"
+  {NULL, 0, 0, 0, false}
+};
+
 struct processor_name_to_arch
 {
   const std::string processor_name;
@@ -232,6 +245,76 @@
   return AARCH64_PARSE_OK;
 }
 
+/* Comparer to sort aarch64's feature extensions by population count. Largest
+   first.  */
+
+typedef const struct aarch64_option_extension opt_ext;
+
+int opt_ext_cmp (const void* a, const void* b)
+{
+  opt_ext *opt_a = (opt_ext *)a;
+  opt_ext *opt_b = (opt_ext *)b;
+
+  /* We consider the total set of bits an options turns on to be the union of
+     the singleton set containing the option itself and the set of options it
+     turns on as a dependency.  As an example +dotprod turns on FL_DOTPROD and
+     FL_SIMD.  As such the set of bits represented by this option is
+     {FL_DOTPROD, FL_SIMD}. */
+  unsigned long total_flags_a = opt_a->flag_canonical & opt_a->flags_on;
+  unsigned long total_flags_b = opt_b->flag_canonical & opt_b->flags_on;
+  int popcnt_a = popcount_hwi ((HOST_WIDE_INT)total_flags_a);
+  int popcnt_b = popcount_hwi ((HOST_WIDE_INT)total_flags_b);
+  int order = popcnt_b - popcnt_a;
+
+  /* If they have the same amount of bits set, give it a more
+     deterministic ordering by using the value of the bits themselves.  */
+  if (order == 0)
+    return total_flags_b - total_flags_a;
+
+  return order;
+}
+
+/* Implement TARGET_OPTION_INIT_STRUCT.  */
+
+static void
+aarch64_option_init_struct (struct gcc_options *opts ATTRIBUTE_UNUSED)
+{
+    /* Sort the extensions based on how many bits they set, order the larger
+       counts first.  We sort the list because this makes processing the
+       feature bits O(n) instead of O(n^2).  While n is small, the function
+       to calculate the feature strings is called on every options push,
+       pop and attribute change (arm_neon headers, lto etc all cause this to
+       happen quite frequently).  It is a trade-off between time and space and
+       so time won.  */
+    int n_extensions
+      = sizeof (all_extensions) / sizeof (struct aarch64_option_extension);
+    qsort (&all_extensions_by_on, n_extensions,
+	   sizeof (struct aarch64_option_extension), opt_ext_cmp);
+}
+
+/* Checks to see if enough bits from the option OPT are enabled in
+   ISA_FLAG_BITS to be able to replace the individual options with the
+   canonicalized version of the option.  This is done based on two rules:
+
+   1) Synthetic groups, such as +crypto we only care about the bits that are
+      turned on. e.g. +aes+sha2 can be replaced with +crypto.
+
+   2) Options that themselves have a bit, such as +rdma, in this case, all the
+      feature bits they turn on must be available and the bit for the option
+      itself must be.  In this case it's effectively a reduction rather than a
+      grouping. e.g. +fp+simd is not enough to turn on +rdma, for that you would
+      need +rdma+fp+simd which is reduced down to +rdma.
+*/
+
+static bool
+aarch64_contains_opt (unsigned long isa_flag_bits, opt_ext *opt)
+{
+  unsigned long flags_check
+    = opt->is_synthetic ? opt->flags_on : opt->flag_canonical;
+
+  return (isa_flag_bits & flags_check) == flags_check;
+}
+
 /* Return a string representation of ISA_FLAGS.  DEFAULT_ARCH_FLAGS
    gives the default set of flags which are implied by whatever -march
    we'd put out.  Our job is to figure out the minimal set of "+" and
@@ -245,27 +328,98 @@
   const struct aarch64_option_extension *opt = NULL;
   std::string outstr = "";
 
-  /* Pass one: Find all the things we need to turn on.  As a special case,
-     we always want to put out +crc if it is enabled.  */
-  for (opt = all_extensions; opt->name != NULL; opt++)
-    if ((isa_flags & opt->flag_canonical
-	 && !(default_arch_flags & opt->flag_canonical))
-	|| (default_arch_flags & opt->flag_canonical
-            && opt->flag_canonical == AARCH64_ISA_CRC))
-      {
-	outstr += "+";
-	outstr += opt->name;
-      }
+  unsigned long isa_flag_bits = isa_flags;
 
-  /* Pass two: Find all the things we need to turn off.  */
-  for (opt = all_extensions; opt->name != NULL; opt++)
-    if ((~isa_flags) & opt->flag_canonical
-	&& !((~default_arch_flags) & opt->flag_canonical))
+  /* Pass one: Minimize the search space by reducing the set of options
+     to the smallest set that still turns on the same features as before in
+     conjunction with the bits that are turned on by default for the selected
+     architecture.  */
+  for (opt = all_extensions_by_on; opt->name != NULL; opt++)
+    {
+      /* If the bit is on by default, then all the options it turns on are also
+	 on by default due to the transitive dependencies.
+
+         If the option is enabled explicitly in the set then we need to emit
+	 an option for it.  Since this list is sorted by extensions setting the
+	 largest number of featers first, we can be sure that nothing else will
+	 ever need to set the bits we already set.  Consider the following
+	 situation:
+
+	  Feat1 = A + B + C
+	  Feat2 = A + B
+	  Feat3 = A + D
+	  Feat4 = B + C
+	  Feat5 = C
+
+	The following results are expected:
+
+	  A + C = A + Feat5
+	  B + C = Feat4
+	  Feat4 + A = Feat1
+	  Feat2 + Feat5 = Feat1
+	  Feat1 + C = Feat1
+          Feat3 + Feat4 = Feat1 + D
+
+	This search assumes that all invidual feature bits are use visible,
+	in other words the user must be able to do +A, +B, +C and +D.  */
+      if (aarch64_contains_opt (isa_flag_bits | default_arch_flags, opt))
       {
-	outstr += "+no";
-	outstr += opt->name;
+	/* We remove all the dependent bits, to prevent them from being turned
+	   on twice.  This only works because we assume that all there are
+	   individual options to set all bits standalone.  */
+	isa_flag_bits &= ~opt->flags_on;
+	isa_flag_bits |= opt->flag_canonical;
       }
+    }
 
+   /* By toggling bits on and off, we may have set bits on that are already
+      enabled by default.  So we mask the default set out so we don't emit an
+      option for them.  Instead of checking for this each time during Pass One
+      we just mask all default bits away at the end.  */
+   isa_flag_bits &= ~default_arch_flags;
+
+   /* We now have the smallest set of features we need to process.  A subsequent
+      linear scan of the bits in isa_flag_bits will allow us to print the ext
+      names.  However as a special case if CRC was enabled before, always print
+      it.  This is required because some CPUs have an incorrect specification
+      in older assemblers.  Even though CRC should be the default for these
+      cases the -mcpu values won't turn it on.  */
+  if (isa_flags & AARCH64_ISA_CRC)
+    isa_flag_bits |= AARCH64_ISA_CRC;
+
+  /* Pass Two:
+     Print the option names that we're sure we must turn on.  These are only
+     optional extension names.  Mandatory ones have already been removed and
+     ones we explicitly want off have been too.  */
+  for (opt = all_extensions_by_on; opt->name != NULL; opt++)
+    {
+      if (isa_flag_bits & opt->flag_canonical)
+	{
+	  outstr += "+";
+	  outstr += opt->name;
+	}
+    }
+
+  /* Pass Three:
+     Print out a +no for any mandatory extension that we are
+     turning off.  By this point aarch64_parse_extension would have ensured
+     that any optional extensions are turned off.  The only things left are
+     things that can't be turned off usually, e.g. something that is on by
+     default because it's mandatory and we want it off.  For turning off bits
+     we don't guarantee the smallest set of flags, but instead just emit all
+     options the user has specified.
+
+     The assembler requires all +<opts> to be printed before +no<opts>.  */
+  for (opt = all_extensions_by_on; opt->name != NULL; opt++)
+    {
+      if ((~isa_flags) & opt->flag_canonical
+		&& !((~default_arch_flags) & opt->flag_canonical))
+	{
+	  outstr += "+no";
+	  outstr += opt->name;
+	}
+    }
+
   return outstr;
 }
 
@@ -345,5 +499,7 @@
   return aarch64_rewrite_selected_cpu (argv[argc - 1]);
 }
 
+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;
+
 #undef AARCH64_CPU_NAME_LENGTH
 
Index: gcc/tree-ssa-ifcombine.c
===================================================================
--- a/src/gcc/tree-ssa-ifcombine.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-ssa-ifcombine.c	(.../branches/gcc-8-branch)
@@ -40,6 +40,7 @@
 #include "gimplify-me.h"
 #include "tree-cfg.h"
 #include "tree-ssa.h"
+#include "params.h"
 
 #ifndef LOGICAL_OP_NON_SHORT_CIRCUIT
 #define LOGICAL_OP_NON_SHORT_CIRCUIT \
@@ -556,7 +557,11 @@
 	{
 	  tree t1, t2;
 	  gimple_stmt_iterator gsi;
-	  if (!LOGICAL_OP_NON_SHORT_CIRCUIT || flag_sanitize_coverage)
+	  bool logical_op_non_short_circuit = LOGICAL_OP_NON_SHORT_CIRCUIT;
+	  if (PARAM_VALUE (PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT) != -1)
+	    logical_op_non_short_circuit
+	      = PARAM_VALUE (PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT);
+	  if (!logical_op_non_short_circuit || flag_sanitize_coverage)
 	    return false;
 	  /* Only do this optimization if the inner bb contains only the conditional. */
 	  if (!gsi_one_before_end_p (gsi_start_nondebug_after_labels_bb (inner_cond_bb)))
Index: gcc/lto-streamer-in.c
===================================================================
--- a/src/gcc/lto-streamer-in.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/lto-streamer-in.c	(.../branches/gcc-8-branch)
@@ -1131,6 +1131,14 @@
 		      ? !MAY_HAVE_DEBUG_MARKER_STMTS
 		      : !MAY_HAVE_DEBUG_BIND_STMTS))
 		remove = true;
+	      /* In case the linemap overflows locations can be dropped
+		 to zero.  Thus do not keep nonsensical inline entry markers
+		 we'd later ICE on.  */
+	      tree block;
+	      if (gimple_debug_inline_entry_p (stmt)
+		  && (block = gimple_block (stmt))
+		  && !inlined_function_outer_scope_p (block))
+		remove = true;
 	      if (is_gimple_call (stmt)
 		  && gimple_call_internal_p (stmt))
 		{
Index: gcc/fortran/interface.c
===================================================================
--- a/src/gcc/fortran/interface.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/interface.c	(.../branches/gcc-8-branch)
@@ -2941,9 +2941,11 @@
 
       if (f->sym == NULL)
 	{
+	  /* These errors have to be issued, otherwise an ICE can occur.
+	     See PR 78865.  */
 	  if (where)
-	    gfc_error ("Missing alternate return spec in subroutine call "
-		       "at %L", where);
+	    gfc_error_now ("Missing alternate return specifier in subroutine "
+			   "call at %L", where);
 	  return false;
 	}
 
@@ -2950,8 +2952,8 @@
       if (a->expr == NULL)
 	{
 	  if (where)
-	    gfc_error ("Unexpected alternate return spec in subroutine "
-		       "call at %L", where);
+	    gfc_error_now ("Unexpected alternate return specifier in "
+			   "subroutine call at %L", where);
 	  return false;
 	}
 
@@ -3655,6 +3657,7 @@
 	gfc_warning (OPT_Wimplicit_procedure,
 		     "Procedure %qs called at %L is not explicitly declared",
 		     sym->name, where);
+      gfc_find_proc_namespace (sym->ns)->implicit_interface_calls = 1;
     }
 
   if (sym->attr.if_source == IFSRC_UNKNOWN)
Index: gcc/fortran/trans-expr.c
===================================================================
--- a/src/gcc/fortran/trans-expr.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/trans-expr.c	(.../branches/gcc-8-branch)
@@ -352,7 +352,7 @@
    of refs following.  */
 
 gfc_expr *
-gfc_find_and_cut_at_last_class_ref (gfc_expr *e)
+gfc_find_and_cut_at_last_class_ref (gfc_expr *e, bool is_mold)
 {
   gfc_expr *base_expr;
   gfc_ref *ref, *class_ref, *tail = NULL, *array_ref;
@@ -394,7 +394,10 @@
       e->ref = NULL;
     }
 
-  base_expr = gfc_copy_expr (e);
+  if (is_mold)
+    base_expr = gfc_expr_to_initialize (e);
+  else
+    base_expr = gfc_copy_expr (e);
 
   /* Restore the original tail expression.  */
   if (class_ref)
@@ -3834,7 +3837,8 @@
 
 
 static void
-conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr)
+conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr,
+		   gfc_actual_arglist *actual_args)
 {
   tree tmp;
 
@@ -3852,7 +3856,7 @@
   else
     {
       if (!sym->backend_decl)
-	sym->backend_decl = gfc_get_extern_function_decl (sym);
+	sym->backend_decl = gfc_get_extern_function_decl (sym, actual_args);
 
       TREE_USED (sym->backend_decl) = 1;
 
@@ -6276,7 +6280,7 @@
 
   /* Generate the actual call.  */
   if (base_object == NULL_TREE)
-    conv_function_val (se, sym, expr);
+    conv_function_val (se, sym, expr, args);
   else
     conv_base_obj_fcn_val (se, base_object, expr);
 
@@ -8385,24 +8389,7 @@
     }
 }
 
-/* Indentify class valued proc_pointer assignments.  */
 
-static bool
-pointer_assignment_is_proc_pointer (gfc_expr * expr1, gfc_expr * expr2)
-{
-  gfc_ref * ref;
-
-  ref = expr1->ref;
-  while (ref && ref->next)
-     ref = ref->next;
-
-  return ref && ref->type == REF_COMPONENT
-      && ref->u.c.component->attr.proc_pointer
-      && expr2->expr_type == EXPR_VARIABLE
-      && expr2->symtree->n.sym->attr.flavor == FL_PROCEDURE;
-}
-
-
 /* Do everything that is needed for a CLASS function expr2.  */
 
 static tree
@@ -8454,7 +8441,7 @@
   tree desc;
   tree tmp;
   tree expr1_vptr = NULL_TREE;
-  bool scalar, non_proc_pointer_assign;
+  bool scalar, non_proc_ptr_assign;
   gfc_ss *ss;
 
   gfc_start_block (&block);
@@ -8462,7 +8449,9 @@
   gfc_init_se (&lse, NULL);
 
   /* Usually testing whether this is not a proc pointer assignment.  */
-  non_proc_pointer_assign = !pointer_assignment_is_proc_pointer (expr1, expr2);
+  non_proc_ptr_assign = !(gfc_expr_attr (expr1).proc_pointer
+			&& expr2->expr_type == EXPR_VARIABLE
+			&& expr2->symtree->n.sym->attr.flavor == FL_PROCEDURE);
 
   /* Check whether the expression is a scalar or not; we cannot use
      expr1->rank as it can be nonzero for proc pointers.  */
@@ -8472,7 +8461,7 @@
     gfc_free_ss_chain (ss);
 
   if (expr1->ts.type == BT_DERIVED && expr2->ts.type == BT_CLASS
-      && expr2->expr_type != EXPR_FUNCTION && non_proc_pointer_assign)
+      && expr2->expr_type != EXPR_FUNCTION && non_proc_ptr_assign)
     {
       gfc_add_data_component (expr2);
       /* The following is required as gfc_add_data_component doesn't
@@ -8492,7 +8481,7 @@
       else
 	gfc_conv_expr (&rse, expr2);
 
-      if (non_proc_pointer_assign && expr1->ts.type == BT_CLASS)
+      if (non_proc_ptr_assign && expr1->ts.type == BT_CLASS)
 	{
 	  trans_class_vptr_len_assignment (&block, expr1, expr2, &rse, NULL,
 					   NULL);
Index: gcc/fortran/trans-array.c
===================================================================
--- a/src/gcc/fortran/trans-array.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/trans-array.c	(.../branches/gcc-8-branch)
@@ -1164,6 +1164,7 @@
   tree nelem;
   tree cond;
   tree or_expr;
+  tree elemsize;
   tree class_expr = NULL_TREE;
   int n, dim, tmp_dim;
   int total_dim = 0;
@@ -1329,10 +1330,15 @@
 	}
     }
 
+  if (class_expr == NULL_TREE)
+    elemsize = fold_convert (gfc_array_index_type,
+			     TYPE_SIZE_UNIT (gfc_get_element_type (type)));
+  else
+    elemsize = gfc_class_vtab_size_get (class_expr);
+
   /* Get the size of the array.  */
   if (size && !callee_alloc)
     {
-      tree elemsize;
       /* If or_expr is true, then the extent in at least one
 	 dimension is zero and the size is set to zero.  */
       size = fold_build3_loc (input_location, COND_EXPR, gfc_array_index_type,
@@ -1339,11 +1345,6 @@
 			      or_expr, gfc_index_zero_node, size);
 
       nelem = size;
-      if (class_expr == NULL_TREE)
-	elemsize = fold_convert (gfc_array_index_type,
-			TYPE_SIZE_UNIT (gfc_get_element_type (type)));
-      else
-	elemsize = gfc_class_vtab_size_get (class_expr);
 
       size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,
 			      size, elemsize);
@@ -1354,6 +1355,10 @@
       size = NULL_TREE;
     }
 
+  /* Set the span.  */
+  tmp = fold_convert (gfc_array_index_type, elemsize);
+  gfc_conv_descriptor_span_set (pre, desc, tmp);
+
   gfc_trans_allocate_array_storage (pre, post, info, size, nelem, initial,
 				    dynamic, dealloc);
 
@@ -2652,6 +2657,9 @@
   if (ss_info->type != GFC_SS_REFERENCE)
     return false;
 
+  if (ss_info->data.scalar.needs_temporary)
+    return false;
+
   /* If the actual argument can be absent (in other words, it can
      be a NULL reference), don't try to evaluate it; pass instead
      the reference directly.  */
@@ -3414,10 +3422,8 @@
   if (build_class_array_ref (se, base, index))
     return;
 
-  if (expr && ((is_subref_array (expr)
-		&& GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (info->descriptor)))
-	       || (expr->ts.deferred && (expr->expr_type == EXPR_VARIABLE
-					 || expr->expr_type == EXPR_FUNCTION))))
+  if (expr && (expr->ts.deferred && (expr->expr_type == EXPR_VARIABLE
+				     || expr->expr_type == EXPR_FUNCTION)))
     decl = expr->symtree->n.sym->backend_decl;
 
   /* A pointer array component can be detected from its field decl. Fix
@@ -9527,9 +9533,15 @@
   if (sym->ts.type == BT_CLASS
       && !sym->attr.associate_var
       && CLASS_DATA (sym)->attr.allocatable
-      && expr->ref && expr->ref->type == REF_COMPONENT
-      && strcmp (expr->ref->u.c.component->name, "_data") == 0
-      && expr->ref->next == NULL)
+      && expr->ref
+      && ((expr->ref->type == REF_ARRAY && expr->ref->u.ar.type == AR_FULL
+	   && expr->ref->next == NULL)
+	  || (expr->ref->type == REF_COMPONENT
+	      && strcmp (expr->ref->u.c.component->name, "_data") == 0
+	      && (expr->ref->next == NULL
+		  || (expr->ref->next->type == REF_ARRAY
+		      && expr->ref->next->u.ar.type == AR_FULL
+		      && expr->ref->next->next == NULL)))))
     return true;
 
   /* An allocatable variable.  */
@@ -10350,6 +10362,8 @@
 {
   gfc_ref *ref;
 
+  gfc_fix_class_refs (expr);
+
   for (ref = expr->ref; ref; ref = ref->next)
     if (ref->type == REF_ARRAY && ref->u.ar.type != AR_ELEMENT)
       break;
Index: gcc/fortran/symbol.c
===================================================================
--- a/src/gcc/fortran/symbol.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/symbol.c	(.../branches/gcc-8-branch)
@@ -522,7 +522,7 @@
   /* The copying of procedure dummy arguments for module procedures in
      a submodule occur whilst the current state is COMP_CONTAINS. It
      is necessary, therefore, to let this through.  */
-  if (attr->dummy
+  if (name && attr->dummy
       && (attr->function || attr->subroutine)
       && gfc_current_state () == COMP_CONTAINS
       && !(gfc_new_block && gfc_new_block->abr_modproc_decl))
@@ -554,6 +554,7 @@
 
   conf (external, intrinsic);
   conf (entry, intrinsic);
+  conf (abstract, intrinsic);
 
   if ((attr->if_source == IFSRC_DECL && !attr->procedure) || attr->contained)
     conf (external, subroutine);
@@ -1685,7 +1686,15 @@
     return false;
 
   attr->subroutine = 1;
-  return check_conflict (attr, name, where);
+
+  /* If we are looking at a BLOCK DATA statement and we encounter a
+     name with a leading underscore (which must be
+     compiler-generated), do not check. See PR 84394.  */
+
+  if (name && *name != '_' && gfc_current_state () != COMP_BLOCK_DATA)
+    return check_conflict (attr, name, where);
+  else
+    return true;
 }
 
 
@@ -1801,7 +1810,8 @@
   if (where == NULL)
     where = &gfc_current_locus;
 
-  if (attr->proc != PROC_UNKNOWN && !attr->module_procedure)
+  if (attr->proc != PROC_UNKNOWN && !attr->module_procedure
+      && attr->access == ACCESS_UNKNOWN)
     {
       if (attr->proc == PROC_ST_FUNCTION && t == PROC_INTERNAL
 	  && !gfc_notification_std (GFC_STD_F2008))
@@ -4352,7 +4362,7 @@
 /* Get a global symbol, creating it if it doesn't exist.  */
 
 gfc_gsymbol *
-gfc_get_gsymbol (const char *name)
+gfc_get_gsymbol (const char *name, bool bind_c)
 {
   gfc_gsymbol *s;
 
@@ -4363,6 +4373,7 @@
   s = XCNEW (gfc_gsymbol);
   s->type = GSYM_UNKNOWN;
   s->name = gfc_get_string ("%s", name);
+  s->bind_c = bind_c;
 
   gfc_insert_bbt (&gfc_gsym_root, s, gsym_compare);
 
Index: gcc/fortran/class.c
===================================================================
--- a/src/gcc/fortran/class.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/class.c	(.../branches/gcc-8-branch)
@@ -561,7 +561,7 @@
    ref to the _len component.  */
 
 gfc_expr *
-gfc_get_len_component (gfc_expr *e)
+gfc_get_len_component (gfc_expr *e, int k)
 {
   gfc_expr *ptr;
   gfc_ref *ref, **last;
@@ -586,6 +586,14 @@
     }
   /* And replace if with a ref to the _len component.  */
   gfc_add_len_component (ptr);
+  if (k != ptr->ts.kind)
+    {
+      gfc_typespec ts;
+      gfc_clear_ts (&ts);
+      ts.type = BT_INTEGER;
+      ts.kind = k;
+      gfc_convert_type_warn (ptr, &ts, 2, 0);
+    }
   return ptr;
 }
 
@@ -899,6 +907,9 @@
   if (!comp_is_finalizable (comp))
     return;
 
+  if (comp->finalized)
+    return;
+
   e = gfc_copy_expr (expr);
   if (!e->ref)
     e->ref = ref = gfc_get_ref ();
@@ -1026,6 +1037,7 @@
 			    sub_ns);
       gfc_free_expr (e);
     }
+  comp->finalized = true;
 }
 
 
@@ -2661,6 +2673,7 @@
 	      gfc_namespace *sub_ns;
 	      gfc_namespace *contained;
 	      gfc_expr *e;
+	      size_t e_size;
 
 	      gfc_get_symbol (name, ns, &vtype);
 	      if (!gfc_add_flavor (&vtype->attr, FL_DERIVED, NULL,
@@ -2695,11 +2708,13 @@
 	      e = gfc_get_expr ();
 	      e->ts = *ts;
 	      e->expr_type = EXPR_VARIABLE;
+	      if (ts->type == BT_CHARACTER)
+		e_size = ts->kind;
+	      else
+		gfc_element_size (e, &e_size);
 	      c->initializer = gfc_get_int_expr (gfc_size_kind,
 						 NULL,
-						 ts->type == BT_CHARACTER
-						 ? ts->kind
-						 : gfc_element_size (e));
+						 e_size);
 	      gfc_free_expr (e);
 
 	      /* Add component _extends.  */
Index: gcc/fortran/decl.c
===================================================================
--- a/src/gcc/fortran/decl.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/decl.c	(.../branches/gcc-8-branch)
@@ -1678,6 +1678,14 @@
       free (expr->value.character.string);
       expr->value.character.string = s;
       expr->value.character.length = len;
+      /* If explicit representation was given, clear it
+	 as it is no longer needed after padding.  */
+      if (expr->representation.length)
+	{
+	  expr->representation.length = 0;
+	  free (expr->representation.string);
+	  expr->representation.string = NULL;
+	}
     }
 }
 
@@ -7156,7 +7164,7 @@
      name is a global identifier.  */
   if (!binding_label || gfc_notification_std (GFC_STD_F2008))
     {
-      s = gfc_get_gsymbol (name);
+      s = gfc_get_gsymbol (name, false);
 
       if (s->defined || (s->type != GSYM_UNKNOWN && s->type != type))
 	{
@@ -7178,7 +7186,7 @@
       && (!gfc_notification_std (GFC_STD_F2008)
 	  || strcmp (name, binding_label) != 0))
     {
-      s = gfc_get_gsymbol (binding_label);
+      s = gfc_get_gsymbol (binding_label, true);
 
       if (s->defined || (s->type != GSYM_UNKNOWN && s->type != type))
 	{
Index: gcc/fortran/trans-openmp.c
===================================================================
--- a/src/gcc/fortran/trans-openmp.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/trans-openmp.c	(.../branches/gcc-8-branch)
@@ -548,6 +548,9 @@
 			     build3_loc (input_location, COND_EXPR,
 					 void_type_node, cond, then_b,
 					 else_b));
+      /* Avoid -W*uninitialized warnings.  */
+      if (DECL_P (decl))
+	TREE_NO_WARNING (decl) = 1;
     }
   else
     gfc_add_expr_to_block (&block, then_b);
@@ -654,6 +657,9 @@
   gfc_add_expr_to_block (&block,
 			 build3_loc (input_location, COND_EXPR,
 				     void_type_node, cond, then_b, else_b));
+  /* Avoid -W*uninitialized warnings.  */
+  if (DECL_P (dest))
+    TREE_NO_WARNING (dest) = 1;
 
   return gfc_finish_block (&block);
 }
Index: gcc/fortran/gfortran.h
===================================================================
--- a/src/gcc/fortran/gfortran.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/gfortran.h	(.../branches/gcc-8-branch)
@@ -1080,6 +1080,7 @@
   struct gfc_typebound_proc *tb;
   /* When allocatable/pointer and in a coarray the associated token.  */
   tree caf_token;
+  bool finalized;
 }
 gfc_component;
 
@@ -1856,6 +1857,9 @@
 
   /* Set to 1 for !$ACC ROUTINE namespaces.  */
   unsigned oacc_routine:1;
+
+  /* Set to 1 if there are any calls to procedures with implicit interface.  */
+  unsigned implicit_interface_calls:1;
 }
 gfc_namespace;
 
@@ -1883,6 +1887,7 @@
   enum gfc_symbol_type type;
 
   int defined, used;
+  bool bind_c;
   locus where;
   gfc_namespace *ns;
 }
@@ -3059,7 +3064,7 @@
 void gfc_free_dt_list (void);
 
 
-gfc_gsymbol *gfc_get_gsymbol (const char *);
+gfc_gsymbol *gfc_get_gsymbol (const char *, bool bind_c);
 gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, const char *);
 gfc_gsymbol *gfc_find_case_gsymbol (gfc_gsymbol *, const char *);
 
@@ -3426,7 +3431,7 @@
 bool gfc_is_class_container_ref (gfc_expr *e);
 gfc_expr *gfc_class_initializer (gfc_typespec *, gfc_expr *);
 unsigned int gfc_hash_value (gfc_symbol *);
-gfc_expr *gfc_get_len_component (gfc_expr *e);
+gfc_expr *gfc_get_len_component (gfc_expr *e, int);
 bool gfc_build_class_symbol (gfc_typespec *, symbol_attribute *,
 			     gfc_array_spec **);
 gfc_symbol *gfc_find_derived_vtab (gfc_symbol *);
Index: gcc/fortran/lang.opt
===================================================================
--- a/src/gcc/fortran/lang.opt	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/lang.opt	(.../branches/gcc-8-branch)
@@ -742,6 +742,13 @@
 Fortran Var(flag_sign_zero) Init(1)
 Apply negative sign to zero values.
 
+ftail-call-workaround
+Fortran Alias(ftail-call-workaround=,1,0)
+
+ftail-call-workaround=
+Fortran RejectNegative Joined UInteger IntegerRange(0, 2) Var(flag_tail_call_workaround) Init(1)
+Disallow tail call optimization when a calling routine may have omitted character lengths.
+
 funderscoring
 Fortran Var(flag_underscoring) Init(1)
 Append underscores to externally visible names.
Index: gcc/fortran/ChangeLog
===================================================================
--- a/src/gcc/fortran/ChangeLog	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/ChangeLog	(.../branches/gcc-8-branch)
@@ -1,3 +1,364 @@
+2013-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90563
+	* frontend-passes.c (insert_index): Suppress errors while
+	simplifying the resulting expression.
+
+2019-08-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Paul Thomas <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90786
+	PR fortran/90813
+	* trans-expr.c (pointer_assignment_is_proc_pointer) Remove as
+	it is very simple and only called from one place.
+	(gfc_trans_pointer_assignment): Rename non_proc_pointer_assign
+	as non_proc_ptr_assign. Assign to it directly, rather than call
+	to above, deleted function and use gfc_expr_attr instead of
+	only checking the reference chain.
+	* trans-decl.c (sym_identifier): New function.
+	(mangled_identifier): New function, doing most of the work
+	of gfc_sym_mangled_identifier.
+	(gfc_sym_mangled_identifier): Use mangled_identifier.  Add mangled
+	identifier to global symbol table.
+	(get_proc_pointer_decl): Use backend decl from global identifier
+	if present.
+
+2019-07-07  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91077
+	* trans-array.c (gfc_conv_scalarized_array_ref) Delete code
+	that gave symbol backend decl for subref arrays.
+
+2019-06-21  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90937
+	* trans-types.c (get_formal_from_actual_arglist): Get symbol from
+	current namespace so it will be freed later.  If symbol is of type
+	character, get an empty character length.
+
+2019-06-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Tom Trnka  <trnka@scm.com>
+
+	Backport from trunk
+	PR fortran/90744
+	* trans-types.c (get_formal_from_actual_arglist): Unset typespec
+	flags which make no sense for procedures without explicit
+	interface.
+
+2019-06-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90498
+	* trans-stmt.c (trans_associate_var) Do not use the saved
+	descriptor if the expression is a COMPONENT_REF.
+
+2019-06-09  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/57284
+	* resolve.c (find_array_spec): If this is a class expression
+	and the symbol and component array specs are the same, this is
+	not an error.
+	*trans-intrinsic.c (gfc_conv_intrinsic_size): If a class symbol
+	argument, has no namespace, it has come from the interface
+	mapping and the _data component must be accessed directly.
+
+2019-05-30  Marek Polacek  <polacek@redhat.com>
+
+	* lang.opt (ftail-call-workaround): Fix a typo.
+
+2019-05-30  Jakub Jelinek  <jakub@redhat.com>
+
+	* lang.opt (ftail-call-workaround=): Fix a typo - lenghts to lengths.
+
+2019-05-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/90329
+	Backported from mainline
+	2019-05-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/90329
+	* lang.opt (fbroken-callers): Remove.
+	(ftail-call-workaround, ftail-call-workaround=): New options.
+	* gfortran.h (struct gfc_namespace): Add implicit_interface_calls.
+	* interface.c (gfc_procedure_use): Set implicit_interface_calls
+	for calls to implicit interface procedures.
+	* trans-decl.c (create_function_arglist): Use flag_tail_call_workaround
+	instead of flag_broken_callers.  If it is not 2, also require
+	sym->ns->implicit_interface_calls.
+	* invoke.texi (fbroken-callers): Remove documentation.
+	(ftail-call-workaround, ftail-call-workaround=): Document.
+
+	2019-05-19  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/90329
+	* invoke.texi: Document -fbroken-callers.
+	* lang.opt: Add -fbroken-callers.
+	* trans-decl.c (create_function_arglist): Only set
+	DECL_HIDDEN_STRING_LENGTH if flag_broken_callers is set.
+
+	2019-05-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/90329
+	* trans-decl.c (create_function_arglist): Set
+	DECL_HIDDEN_STRING_LENGTH on hidden string length PARM_DECLs if
+	len is constant.
+
+2019-04-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-03-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/89651
+	* trans-openmp.c (gfc_omp_clause_default_ctor): Set TREE_NO_WARNING
+	on decl if adding COND_EXPR for allocatable.
+	(gfc_omp_clause_copy_ctor): Set TREE_NO_WARNING on dest.
+
+2019-04-24  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/87127
+	* resolve.c (check_host_association): If an external function
+	is typed but not declared explicitly to be external, change the
+	old symbol from a variable to an external function.
+
+2019-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/87352
+	* gfortran.h (gfc_component): Add finalized field.
+	* class.c (finalize_component): If the component is already
+	finalized, return early.  Set component->finalized on exit.
+
+2019-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/89981
+	* resolve.c (resolve_global_procedure): If the global symbol is an
+	ENTRY, also look up its name among the entries.
+
+2019-04-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89904
+	* check.c (gfc_check_transfer): Reject procedures as actual
+	arguments for SOURCE and MOLD of TRANSFER intrinsic.
+
+2019-03-31  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/83515
+	PR fortran/85797
+	* trans-types.c (gfc_typenode_for_spec): Handle conversion for
+	procedure pointers.
+	* target-memory.c (gfc_element_size): Handle size determination
+	for procedure pointers.
+
+2019-03-30  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/78865
+	Backport from trunk
+	* interface.c (compare_actual_formal): Change errors about
+	missing or extra to gfc_error_now to make sure they are issued.
+	Change "spec" to "specifier" in message.
+	* resolve.c (resolve_global_procedure): Also check for mismatching
+	interface with global symbols if the namespace has already been
+	resolved.
+
+2019-03-24  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/71861
+	Backport from trunk
+	* symbol.c (check_conflict): ABSTRACT attribute conflicts with
+	INTRINSIC attribute.
+
+2019-03-23  Thomas Koenig  <tkoeng@gcc.gnu.org>
+
+	PR fortran/68009
+	Backport from trunk
+	* iresolve.c: Include trans.h.
+	(gfc_resolve_fe_runtine_error): Set backend_decl on
+	resolved_sym.
+
+2019-03-17  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/84394
+	Backport from trunk
+	* symbol.c (gfc_add_subroutine): If we are encountering a
+	subrtoutine within a BLOCK DATA and the name starts with an
+	underscore, do not check.
+
+2019-03-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66089
+	Backport from trunk
+	* trans-array.c (gfc_scalar_elemental_arg_saved_as_reference):
+	Return false if a scalar tempoary is needed.
+	(gfc_walk_variable_expr): Fix up class refs.
+
+2019-03-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66695
+	PR fortran/77746
+	PR fortran/79485
+	Backport from trunk
+	* gfortran.h (gfc_symbol): Add bind_c component.
+	(gfc_get_gsymbol): Add argument bind_c.
+	* decl.c (add_global_entry): Add bind_c argument to
+	gfc_get_symbol.
+	* parse.c (parse_block_data): Likewise.
+	(parse_module): Likewise.
+	(add_global_procedure): Likewise.
+	(add_global_program): Likewise.
+	* resolve.c (resolve_common_blocks): Likewise.
+	(resolve_global_procedure): Likewise.
+	(gfc_verify_binding_labels): Likewise.
+	* symbol.c (gfc_get_gsymbol): Add argument bind_c. Set bind_c
+	in gsym.
+	* trans-decl.c (gfc_get_module_backend_decl): Add bind_c argument
+	to gfc_get_symbol.
+	(gfc_get_extern_function_decl): If the sym has a binding label
+	and it cannot be found in the global symbol tabel, it is the wrong
+	one and vice versa.
+
+2019-03-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87673
+	Backport from trunk
+	* match.c (gfc_match_type_spec): Remove call to
+	gfc_resolve_expr for character length.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71544
+	Backport from trunk
+	* trans-types.c (gfc_typenode_for_spec) Set ts->is_c_interop of
+	C_PTR and C_FUNPTR.
+	(create_fn_spec): Mark argument as escaping if ts->is_c_interop is set.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/87734
+	Backort from trunk
+	* symbol.c (gfc_add_procedure): Only throw an error if the
+	procedure has not been declared either PUBLIC or PRIVATE.
+	* resolve.c (is_illegal_recursion): Remove an assert().
+
+2019-03-06  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/71203
+	* expr.c (simplify_const_ref): Avoid null pointer dereference.
+
+2019-03-06  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/72714
+	Backport from trunk
+	* resolve.c (resolve_allocate_expr): Add some tests for coarrays.
+
+2019-03-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89077
+	* decl.c (gfc_set_constant_character_len): Clear original string
+	representation after padding has been performed to target length.
+	* resolve.c (gfc_resolve_substring_charlen): Check substring
+	length for constantness prior to general calculation of length.
+
+2019-03-03  Harald Anlauf  <anlauf@gmx.de>
+	    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/77583
+	* symbol.c (check_conflict): Check for valid procedure name
+	passed to error reporting routine.
+
+2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/89174
+	Backport from trunk
+	* trans-expr.c (gfc_find_and_cut_at_last_class_ref): Add is_mold
+	to garguments. If we are dealing with a MOLD, call
+	gfc_expr_to_initialize().
+	* trans-stmt.c (gfc_trans_allocate): For MOLD, pass is_mold=true
+	to gfc_find_and_cut_at_last_class_ref.
+	* trans.h (gfc_find_and_cut_at_last_class_ref): Add optional
+	argument is_mold with default false.
+
+2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87689
+	Backport from trunk
+	* gfortran.dg/lto/20091028-1_0.f90: Add -Wno-lto-type-mismatch to
+	options.
+	* gfortran.dg/lto/20091028-2_0.f90: Likewise.
+	* gfortran.dg/lto/pr87689_0.f: New file.
+	* gfortran.dg/lto/pr87689_1.f: New file.
+	* gfortran.dg/altreturn_9_0.f90: New file.
+	* gfortran.dg/altreturn_9_1.f90: New file.
+
+2019-03-02  Jerry DeLisle <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84387
+	* trans-io.c (transfer_expr): Do not return if there are no
+	components to the derived type or class.
+
+2019-03-02  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89516
+	* check.c (gfc_calculate_transfer_sizes): Correct checks for cases
+	where storage size of elements of MOLD is 0.
+
+	PR fortran/89492
+	* check.c (gfc_calculate_transfer_sizes): Handle cases where
+	storage size of elements of MOLD is 0.
+
+	PR fortran/89266
+	PR fortran/88326
+	* target-memory.c (gfc_element_size): Return false if element size
+	cannot be determined; element size is returned separately.
+	(gfc_target_expr_size): Return false if expression size cannot be
+	determined; expression size is returned separately.
+	* target-memory.h: Adjust prototypes.
+	* check.c (gfc_calculate_transfer_sizes): Adjust references to
+	gfc_target_expr_size, gfc_element_size.
+	* arith.c (hollerith2representation): Likewise.
+	* class.c (find_intrinsic_vtab): Likewise.
+	* simplify.c (gfc_simplify_sizeof): Likewise.
+
+2019-02-23  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/86119
+	Backport from trunk
+	* class.c (gfc_get_len_component): Add argument k for kind.
+	If the kind of the resulting expression is not equal to k,
+	convert it.
+	* gfortran.h (gfc_len_component): Adjust prototype.
+	* simplify.c (gfc_simplify_len): Pass kind to
+	gfc_get_len_component.
+
+2019-02-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/88117
+	* resolve.c (deferred_op_assign): Return if the lhs expression
+	has the pointer attribute.
+
+2019-02-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71066
+	Backport from trunk
+	* trans-decl.c (generate_coarray_sym_init):  For an array
+	constructor in a DATA statement of a coarray variable, set the
+	rank to 1 to avoid confusion later on.  If the constructor
+	contains only one value, use that for initiailizig.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: gcc/fortran/trans-stmt.c
===================================================================
--- a/src/gcc/fortran/trans-stmt.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/trans-stmt.c	(.../branches/gcc-8-branch)
@@ -1842,7 +1842,8 @@
 	    {
 	      if (e->symtree
 		  && DECL_LANG_SPECIFIC (e->symtree->n.sym->backend_decl)
-		 && GFC_DECL_SAVED_DESCRIPTOR (e->symtree->n.sym->backend_decl))
+		  && GFC_DECL_SAVED_DESCRIPTOR (e->symtree->n.sym->backend_decl)
+		  && TREE_CODE (target_expr) != COMPONENT_REF)
 		/* Use the original class descriptor stored in the saved
 		   descriptor to get the target_expr.  */
 		target_expr =
@@ -6606,7 +6607,7 @@
 	  /* Use class_init_assign to initialize expr.  */
 	  gfc_code *ini;
 	  ini = gfc_get_code (EXEC_INIT_ASSIGN);
-	  ini->expr1 = gfc_find_and_cut_at_last_class_ref (expr);
+	  ini->expr1 = gfc_find_and_cut_at_last_class_ref (expr, true);
 	  tmp = gfc_trans_class_init_assign (ini);
 	  gfc_free_statements (ini);
 	  gfc_add_expr_to_block (&block, tmp);
Index: gcc/fortran/expr.c
===================================================================
--- a/src/gcc/fortran/expr.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/expr.c	(.../branches/gcc-8-branch)
@@ -1784,8 +1784,14 @@
 			string_len = 0;
 
 		      if (!p->ts.u.cl)
-			p->ts.u.cl = gfc_new_charlen (p->symtree->n.sym->ns,
-						      NULL);
+			{
+			  if (p->symtree)
+			    p->ts.u.cl = gfc_new_charlen (p->symtree->n.sym->ns,
+							  NULL);
+			  else
+			    p->ts.u.cl = gfc_new_charlen (gfc_current_ns,
+							  NULL);
+			}
 		      else
 			gfc_free_expr (p->ts.u.cl->length);
 
Index: gcc/fortran/trans-types.c
===================================================================
--- a/src/gcc/fortran/trans-types.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/trans-types.c	(.../branches/gcc-8-branch)
@@ -1213,7 +1213,8 @@
         {
           spec->type = BT_INTEGER;
           spec->kind = gfc_index_integer_kind;
-          spec->f90_type = BT_VOID;
+	  spec->f90_type = BT_VOID;
+	  spec->is_c_interop = 1;  /* Mark as escaping later.  */
         }
       break;
     case BT_VOID:
@@ -1230,6 +1231,9 @@
 	    basetype = pfunc_type_node;
 	}
        break;
+    case BT_PROCEDURE:
+      basetype = pfunc_type_node;
+      break;
     default:
       gcc_unreachable ();
     }
@@ -2978,7 +2982,8 @@
 		    || f->sym->ts.u.derived->attr.pointer_comp))
 	    || (f->sym->ts.type == BT_CLASS
 		&& (CLASS_DATA (f->sym)->ts.u.derived->attr.proc_pointer_comp
-		    || CLASS_DATA (f->sym)->ts.u.derived->attr.pointer_comp)))
+		    || CLASS_DATA (f->sym)->ts.u.derived->attr.pointer_comp))
+	    || (f->sym->ts.type == BT_INTEGER && f->sym->ts.is_c_interop))
 	  spec[spec_len++] = '.';
 	else if (f->sym->attr.intent == INTENT_IN)
 	  spec[spec_len++] = 'r';
@@ -2991,9 +2996,64 @@
   return build_type_attribute_variant (fntype, tmp);
 }
 
+/* Helper function - if we do not find an interface for a procedure,
+   construct it from the actual arglist.  Luckily, this can only
+   happen for call by reference, so the information we actually need
+   to provide (and which would be impossible to guess from the call
+   itself) is not actually needed.  */
 
+static void
+get_formal_from_actual_arglist (gfc_symbol *sym, gfc_actual_arglist *actual_args)
+{
+  gfc_actual_arglist *a;
+  gfc_formal_arglist **f;
+  gfc_symbol *s;
+  char name[GFC_MAX_SYMBOL_LEN + 1];
+  static int var_num;
+
+  f = &sym->formal;
+  for (a = actual_args; a != NULL; a = a->next)
+    {
+      (*f) = gfc_get_formal_arglist ();
+      if (a->expr)
+	{
+	  snprintf (name, GFC_MAX_SYMBOL_LEN, "_formal_%d", var_num ++);
+	  gfc_get_symbol (name, gfc_current_ns, &s);
+	  if (a->expr->ts.type == BT_PROCEDURE)
+	    {
+	      s->attr.flavor = FL_PROCEDURE;
+	    }
+	  else
+	    {
+	      s->ts = a->expr->ts;
+
+	      if (s->ts.type == BT_CHARACTER)
+		  s->ts.u.cl = gfc_get_charlen ();
+
+	      s->ts.deferred = 0;
+	      s->ts.is_iso_c = 0;
+	      s->ts.is_c_interop = 0;
+	      s->attr.flavor = FL_VARIABLE;
+	      if (a->expr->rank > 0)
+		{
+		  s->attr.dimension = 1;
+		  s->as = gfc_get_array_spec ();
+		  s->as->type = AS_ASSUMED_SIZE;
+		}
+	    }
+	  s->attr.dummy = 1;
+	  s->attr.intent = INTENT_UNKNOWN;
+	  (*f)->sym = s;
+	}
+      else  /* If a->expr is NULL, this is an alternate rerturn.  */
+	(*f)->sym = NULL;
+
+      f = &((*f)->next);
+    }
+}
+
 tree
-gfc_get_function_type (gfc_symbol * sym)
+gfc_get_function_type (gfc_symbol * sym, gfc_actual_arglist *actual_args)
 {
   tree type;
   vec<tree, va_gc> *typelist = NULL;
@@ -3051,6 +3111,10 @@
 	    vec_safe_push (typelist, build_pointer_type(gfc_charlen_type_node));
 	}
     }
+  if (sym->backend_decl == error_mark_node && actual_args != NULL
+      && sym->formal == NULL && (sym->attr.proc == PROC_EXTERNAL
+				 || sym->attr.proc == PROC_UNKNOWN))
+    get_formal_from_actual_arglist (sym, actual_args);
 
   /* Build the argument types for the function.  */
   for (f = gfc_sym_get_dummy_args (sym); f; f = f->next)
Index: gcc/fortran/trans.h
===================================================================
--- a/src/gcc/fortran/trans.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/trans.h	(.../branches/gcc-8-branch)
@@ -412,7 +412,7 @@
 tree gfc_class_vptr_get (tree);
 tree gfc_class_len_get (tree);
 tree gfc_class_len_or_zero_get (tree);
-gfc_expr * gfc_find_and_cut_at_last_class_ref (gfc_expr *);
+gfc_expr * gfc_find_and_cut_at_last_class_ref (gfc_expr *, bool is_mold = false);
 /* Get an accessor to the class' vtab's * field, when a class handle is
    available.  */
 tree gfc_class_vtab_hash_get (tree);
@@ -579,7 +579,8 @@
 tree gfc_get_label_decl (gfc_st_label *);
 
 /* Return the decl for an external function.  */
-tree gfc_get_extern_function_decl (gfc_symbol *);
+tree gfc_get_extern_function_decl (gfc_symbol *,
+				   gfc_actual_arglist *args = NULL);
 
 /* Return the decl for a function.  */
 tree gfc_get_function_decl (gfc_symbol *);
Index: gcc/fortran/trans-types.h
===================================================================
--- a/src/gcc/fortran/trans-types.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/trans-types.h	(.../branches/gcc-8-branch)
@@ -88,7 +88,7 @@
 tree gfc_typenode_for_spec (gfc_typespec *, int c = 0);
 int gfc_copy_dt_decls_ifequal (gfc_symbol *, gfc_symbol *, bool);
 
-tree gfc_get_function_type (gfc_symbol *);
+tree gfc_get_function_type (gfc_symbol *, gfc_actual_arglist *args = NULL);
 
 tree gfc_type_for_size (unsigned, int);
 tree gfc_type_for_mode (machine_mode, int);
Index: gcc/fortran/frontend-passes.c
===================================================================
--- a/src/gcc/fortran/frontend-passes.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/frontend-passes.c	(.../branches/gcc-8-branch)
@@ -2461,7 +2461,12 @@
   data.sym = sym;
   mpz_init_set (data.val, val);
   gfc_expr_walker (&n, callback_insert_index, (void *) &data);
+
+  /* Suppress errors here - we could get errors here such as an
+     out of bounds access for arrays, see PR 90563.  */
+  gfc_push_suppress_errors ();
   gfc_simplify_expr (n, 0);
+  gfc_pop_suppress_errors ();
 
   if (n->expr_type == EXPR_CONSTANT)
     {
Index: gcc/fortran/resolve.c
===================================================================
--- a/src/gcc/fortran/resolve.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/resolve.c	(.../branches/gcc-8-branch)
@@ -1045,7 +1045,7 @@
 	}
       if (!gsym)
 	{
-	  gsym = gfc_get_gsymbol (common_root->n.common->name);
+	  gsym = gfc_get_gsymbol (common_root->n.common->name, false);
 	  gsym->type = GSYM_COMMON;
 	  gsym->where = common_root->n.common->where;
 	  gsym->defined = 1;
@@ -1067,7 +1067,7 @@
 	}
       if (!gsym)
 	{
-	  gsym = gfc_get_gsymbol (common_root->n.common->binding_label);
+	  gsym = gfc_get_gsymbol (common_root->n.common->binding_label, true);
 	  gsym->type = GSYM_COMMON;
 	  gsym->where = common_root->n.common->where;
 	  gsym->defined = 1;
@@ -1681,8 +1681,6 @@
       || gfc_fl_struct (sym->attr.flavor))
     return false;
 
-  gcc_assert (sym->attr.flavor == FL_PROCEDURE);
-
   /* If we've got an ENTRY, find real procedure.  */
   if (sym->attr.entry && sym->ns->entries)
     proc_sym = sym->ns->entries->sym;
@@ -2484,7 +2482,8 @@
 
   type = sub ? GSYM_SUBROUTINE : GSYM_FUNCTION;
 
-  gsym = gfc_get_gsymbol (sym->binding_label ? sym->binding_label : sym->name);
+  gsym = gfc_get_gsymbol (sym->binding_label ? sym->binding_label : sym->name,
+			  sym->binding_label != NULL);
 
   if ((gsym->type != GSYM_UNKNOWN && gsym->type != type))
     gfc_global_used (gsym, where);
@@ -2494,64 +2493,64 @@
       && gsym->type != GSYM_UNKNOWN
       && !gsym->binding_label
       && gsym->ns
-      && gsym->ns->resolved != -1
       && gsym->ns->proc_name
       && not_in_recursive (sym, gsym->ns)
       && not_entry_self_reference (sym, gsym->ns))
     {
       gfc_symbol *def_sym;
+      def_sym = gsym->ns->proc_name;
 
       /* Resolve the gsymbol namespace if needed.  */
-      if (!gsym->ns->resolved)
+      if (gsym->ns->resolved != -1)
 	{
-	  gfc_dt_list *old_dt_list;
+	  if (!gsym->ns->resolved)
+	    {
+	      gfc_dt_list *old_dt_list;
 
-	  /* Stash away derived types so that the backend_decls do not
-	     get mixed up.  */
-	  old_dt_list = gfc_derived_types;
-	  gfc_derived_types = NULL;
+	      /* Stash away derived types so that the backend_decls
+	     do not get mixed up.  */
+	      old_dt_list = gfc_derived_types;
+	      gfc_derived_types = NULL;
 
-	  gfc_resolve (gsym->ns);
+	      gfc_resolve (gsym->ns);
 
-	  /* Store the new derived types with the global namespace.  */
-	  if (gfc_derived_types)
-	    gsym->ns->derived_types = gfc_derived_types;
+	      /* Store the new derived types with the global namespace.  */
+	      if (gfc_derived_types)
+		gsym->ns->derived_types = gfc_derived_types;
 
-	  /* Restore the derived types of this namespace.  */
-	  gfc_derived_types = old_dt_list;
-	}
+	      /* Restore the derived types of this namespace.  */
+	      gfc_derived_types = old_dt_list;
+	    }
 
-      /* Make sure that translation for the gsymbol occurs before
-	 the procedure currently being resolved.  */
-      ns = gfc_global_ns_list;
-      for (; ns && ns != gsym->ns; ns = ns->sibling)
-	{
-	  if (ns->sibling == gsym->ns)
+	  /* Make sure that translation for the gsymbol occurs before
+	     the procedure currently being resolved.  */
+	  ns = gfc_global_ns_list;
+	  for (; ns && ns != gsym->ns; ns = ns->sibling)
 	    {
-	      ns->sibling = gsym->ns->sibling;
-	      gsym->ns->sibling = gfc_global_ns_list;
-	      gfc_global_ns_list = gsym->ns;
-	      break;
+	      if (ns->sibling == gsym->ns)
+		{
+		  ns->sibling = gsym->ns->sibling;
+		  gsym->ns->sibling = gfc_global_ns_list;
+		  gfc_global_ns_list = gsym->ns;
+		  break;
+		}
 	    }
-	}
 
-      def_sym = gsym->ns->proc_name;
+	  /* This can happen if a binding name has been specified.  */
+	  if (gsym->binding_label && gsym->sym_name != def_sym->name)
+	    gfc_find_symbol (gsym->sym_name, gsym->ns, 0, &def_sym);
 
-      /* This can happen if a binding name has been specified.  */
-      if (gsym->binding_label && gsym->sym_name != def_sym->name)
-	gfc_find_symbol (gsym->sym_name, gsym->ns, 0, &def_sym);
-
-      if (def_sym->attr.entry_master)
-	{
-	  gfc_entry_list *entry;
-	  for (entry = gsym->ns->entries; entry; entry = entry->next)
-	    if (strcmp (entry->sym->name, sym->name) == 0)
-	      {
-		def_sym = entry->sym;
-		break;
-	      }
+	  if (def_sym->attr.entry_master || def_sym->attr.entry)
+	    {
+	      gfc_entry_list *entry;
+	      for (entry = gsym->ns->entries; entry; entry = entry->next)
+		if (strcmp (entry->sym->name, sym->name) == 0)
+		  {
+		    def_sym = entry->sym;
+		    break;
+		  }
+	    }
 	}
-
       if (sym->attr.function && !gfc_compare_types (&sym->ts, &def_sym->ts))
 	{
 	  gfc_error ("Return type mismatch of function %qs at %L (%s/%s)",
@@ -4633,9 +4632,13 @@
   gfc_array_spec *as;
   gfc_component *c;
   gfc_ref *ref;
+  bool class_as = false;
 
   if (e->symtree->n.sym->ts.type == BT_CLASS)
-    as = CLASS_DATA (e->symtree->n.sym)->as;
+    {
+      as = CLASS_DATA (e->symtree->n.sym)->as;
+      class_as = true;
+    }
   else
     as = e->symtree->n.sym->as;
 
@@ -4654,7 +4657,7 @@
 	c = ref->u.c.component;
 	if (c->attr.dimension)
 	  {
-	    if (as != NULL)
+	    if (as != NULL && !(class_as && as == c->as))
 	      gfc_internal_error ("find_array_spec(): unused as(1)");
 	    as = c->as;
 	  }
@@ -4881,6 +4884,7 @@
   gfc_ref *char_ref;
   gfc_expr *start, *end;
   gfc_typespec *ts = NULL;
+  mpz_t diff;
 
   for (char_ref = e->ref; char_ref; char_ref = char_ref->next)
     {
@@ -4932,12 +4936,26 @@
       return;
     }
 
-  /* Length = (end - start + 1).  */
-  e->ts.u.cl->length = gfc_subtract (end, start);
-  e->ts.u.cl->length = gfc_add (e->ts.u.cl->length,
-				gfc_get_int_expr (gfc_charlen_int_kind,
-						  NULL, 1));
+  /* Length = (end - start + 1).
+     Check first whether it has a constant length.  */
+  if (gfc_dep_difference (end, start, &diff))
+    {
+      gfc_expr *len = gfc_get_constant_expr (BT_INTEGER, gfc_charlen_int_kind,
+					     &e->where);
 
+      mpz_add_ui (len->value.integer, diff, 1);
+      mpz_clear (diff);
+      e->ts.u.cl->length = len;
+      /* The check for length < 0 is handled below */
+    }
+  else
+    {
+      e->ts.u.cl->length = gfc_subtract (end, start);
+      e->ts.u.cl->length = gfc_add (e->ts.u.cl->length,
+				    gfc_get_int_expr (gfc_charlen_int_kind,
+						      NULL, 1));
+    }
+
   /* F2008, 6.4.1:  Both the starting point and the ending point shall
      be within the range 1, 2, ..., n unless the starting point exceeds
      the ending point, in which case the substring has length zero.  */
@@ -5615,11 +5633,14 @@
 
 
 /* Checks to see that the correct symbol has been host associated.
-   The only situation where this arises is that in which a twice
-   contained function is parsed after the host association is made.
-   Therefore, on detecting this, change the symbol in the expression
-   and convert the array reference into an actual arglist if the old
-   symbol is a variable.  */
+   The only situations where this arises are:
+	(i)  That in which a twice contained function is parsed after
+	     the host association is made. On detecting this, change
+	     the symbol in the expression and convert the array reference
+	     into an actual arglist if the old symbol is a variable; or
+	(ii) That in which an external function is typed but not declared
+	     explcitly to be external. Here, the old symbol is changed
+	     from a variable to an external function.  */
 static bool
 check_host_association (gfc_expr *e)
 {
@@ -5709,6 +5730,26 @@
 	  gfc_resolve_expr (e);
 	  sym->refs++;
 	}
+      /* This case corresponds to a call, from a block or a contained
+	 procedure, to an external function, which has not been declared
+	 as being external in the main program but has been typed.  */
+      else if (sym && old_sym != sym
+	       && !e->ref
+	       && sym->ts.type == BT_UNKNOWN
+	       && old_sym->ts.type != BT_UNKNOWN
+	       && sym->attr.flavor == FL_PROCEDURE
+	       && old_sym->attr.flavor == FL_VARIABLE
+	       && sym->ns->parent == old_sym->ns
+	       && sym->ns->proc_name
+	       && (sym->ns->proc_name->attr.flavor == FL_LABEL
+		   || sym->ns->proc_name->attr.flavor == FL_PROCEDURE))
+	{
+	  old_sym->attr.flavor = FL_PROCEDURE;
+	  old_sym->attr.external = 1;
+	  old_sym->attr.function = 1;
+	  old_sym->result = old_sym;
+	  gfc_resolve_expr (e);
+	}
     }
   /* This might have changed!  */
   return e->expr_type == EXPR_FUNCTION;
@@ -7640,13 +7681,54 @@
 
   if (codimension)
     for (i = ar->dimen; i < ar->dimen + ar->codimen; i++)
-      if (ar->dimen_type[i] == DIMEN_THIS_IMAGE)
-	{
-	  gfc_error ("Coarray specification required in ALLOCATE statement "
-		     "at %L", &e->where);
-	  goto failure;
-	}
+      {
+	switch (ar->dimen_type[i])
+	  {
+	  case DIMEN_THIS_IMAGE:
+	    gfc_error ("Coarray specification required in ALLOCATE statement "
+		       "at %L", &e->where);
+	    goto failure;
 
+	  case  DIMEN_RANGE:
+	    if (ar->start[i] == 0 || ar->end[i] == 0)
+	      {
+		/* If ar->stride[i] is NULL, we issued a previous error.  */
+		if (ar->stride[i] == NULL)
+		  gfc_error ("Bad array specification in ALLOCATE statement "
+			     "at %L", &e->where);
+		goto failure;
+	      }
+	    else if (gfc_dep_compare_expr (ar->start[i], ar->end[i]) == 1)
+	      {
+		gfc_error ("Upper cobound is less than lower cobound at %L",
+			   &ar->start[i]->where);
+		goto failure;
+	      }
+	    break;
+
+	  case DIMEN_ELEMENT:
+	    if (ar->start[i]->expr_type == EXPR_CONSTANT)
+	      {
+		gcc_assert (ar->start[i]->ts.type == BT_INTEGER);
+		if (mpz_cmp_si (ar->start[i]->value.integer, 1) < 0)
+		  {
+		    gfc_error ("Upper cobound is less than lower cobound "
+			       " of 1 at %L", &ar->start[i]->where);
+		    goto failure;
+		  }
+	      }
+	    break;
+
+	  case DIMEN_STAR:
+	    break;
+
+	  default:
+	    gfc_error ("Bad array specification in ALLOCATE statement at %L",
+		       &e->where);
+	    goto failure;
+
+	  }
+      }
   for (i = 0; i < ar->dimen; i++)
     {
       if (ar->type == AR_ELEMENT || ar->type == AR_FULL)
@@ -11011,6 +11093,9 @@
   if (!gfc_check_dependency ((*code)->expr1, (*code)->expr2, 1))
     return false;
 
+  if (gfc_expr_attr ((*code)->expr1).pointer)
+    return false;
+
   tmp_expr = get_temp_from_expr ((*code)->expr1, ns);
   tmp_expr->where = (*code)->loc;
 
@@ -11647,7 +11732,7 @@
 	  && (gsym->type == GSYM_FUNCTION || gsym->type == GSYM_SUBROUTINE)))
     {
       if (!gsym)
-	gsym = gfc_get_gsymbol (sym->binding_label);
+	gsym = gfc_get_gsymbol (sym->binding_label, true);
       gsym->where = sym->declared_at;
       gsym->sym_name = sym->name;
       gsym->binding_label = sym->binding_label;
Index: gcc/fortran/iresolve.c
===================================================================
--- a/src/gcc/fortran/iresolve.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/iresolve.c	(.../branches/gcc-8-branch)
@@ -35,6 +35,7 @@
 #include "intrinsic.h"
 #include "constructor.h"
 #include "arith.h"
+#include "trans.h"
 
 /* Given printf-like arguments, return a stable version of the result string.
 
@@ -2377,6 +2378,10 @@
     a->name = "%VAL";
 
   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);
+  /* We set the backend_decl here because runtime_error is a
+     variadic function and we would use the wrong calling
+     convention otherwise.  */
+  c->resolved_sym->backend_decl = gfor_fndecl_runtime_error;
 }
 
 void
Index: gcc/fortran/trans-decl.c
===================================================================
--- a/src/gcc/fortran/trans-decl.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/trans-decl.c	(.../branches/gcc-8-branch)
@@ -342,39 +342,45 @@
     }
 }
 
+/* Return the name of an identifier.  */
 
+static const char *
+sym_identifier (gfc_symbol *sym)
+{
+  if (sym->attr.is_main_program && strcmp (sym->name, "main") == 0)
+    return "MAIN__";
+  else
+    return sym->name;
+}
+
 /* Convert a gfc_symbol to an identifier of the same name.  */
 
 static tree
 gfc_sym_identifier (gfc_symbol * sym)
 {
-  if (sym->attr.is_main_program && strcmp (sym->name, "main") == 0)
-    return (get_identifier ("MAIN__"));
-  else
-    return (get_identifier (sym->name));
+  return get_identifier (sym_identifier (sym));
 }
 
+/* Construct mangled name from symbol name.   */
 
-/* Construct mangled name from symbol name.  */
-
-static tree
-gfc_sym_mangled_identifier (gfc_symbol * sym)
+static const char *
+mangled_identifier (gfc_symbol *sym)
 {
-  char name[GFC_MAX_MANGLED_SYMBOL_LEN + 1];
-
+  static char name[GFC_MAX_MANGLED_SYMBOL_LEN + 1];
   /* Prevent the mangling of identifiers that have an assigned
      binding label (mainly those that are bind(c)).  */
+
   if (sym->attr.is_bind_c == 1 && sym->binding_label)
-    return get_identifier (sym->binding_label);
+    return sym->binding_label;
 
   if (!sym->fn_result_spec)
     {
       if (sym->module == NULL)
-	return gfc_sym_identifier (sym);
+	return sym_identifier (sym);
       else
 	{
 	  snprintf (name, sizeof name, "__%s_MOD_%s", sym->module, sym->name);
-	  return get_identifier (name);
+	  return name;
 	}
     }
   else
@@ -389,18 +395,41 @@
 		    sym->ns->proc_name->module,
 		    sym->ns->proc_name->name,
 		    sym->name);
-	  return get_identifier (name);
+	  return name;
 	}
       else
 	{
 	  snprintf (name, sizeof name, "__%s_PROC_%s",
 		    sym->ns->proc_name->name, sym->name);
-	  return get_identifier (name);
+	  return name;
 	}
     }
 }
 
+/* Get mangled identifier, adding the symbol to the global table if
+   it is not yet already there.  */
 
+static tree
+gfc_sym_mangled_identifier (gfc_symbol * sym)
+{
+  tree result;
+  gfc_gsymbol *gsym;
+  const char *name;
+
+  name = mangled_identifier (sym);
+  result = get_identifier (name);
+
+  gsym = gfc_find_gsymbol (gfc_gsym_root, name);
+  if (gsym == NULL)
+    {
+      gsym = gfc_get_gsymbol (name, false);
+      gsym->ns = sym->ns;
+      gsym->sym_name = sym->name;
+    }
+
+  return result;
+}
+
 /* Construct mangled function name from symbol name.  */
 
 static tree
@@ -839,7 +868,7 @@
 	{
 	  if (!gsym)
 	    {
-	      gsym = gfc_get_gsymbol (sym->module);
+	      gsym = gfc_get_gsymbol (sym->module, false);
 	      gsym->type = GSYM_MODULE;
 	      gsym->ns = gfc_get_namespace (NULL, 0);
 	    }
@@ -1905,6 +1934,22 @@
   tree decl;
   tree attributes;
 
+  if (sym->module || sym->fn_result_spec)
+    {
+      const char *name;
+      gfc_gsymbol *gsym;
+
+      name = mangled_identifier (sym);
+      gsym = gfc_find_gsymbol (gfc_gsym_root, name);
+      if (gsym != NULL)
+	{
+	  gfc_symbol *s;
+	  gfc_find_symbol (sym->name, gsym->ns, 0, &s);
+	  if (s && s->backend_decl)
+	    return s->backend_decl;
+	}
+    }
+
   decl = sym->backend_decl;
   if (decl)
     return decl;
@@ -1977,7 +2022,7 @@
 /* Get a basic decl for an external function.  */
 
 tree
-gfc_get_extern_function_decl (gfc_symbol * sym)
+gfc_get_extern_function_decl (gfc_symbol * sym, gfc_actual_arglist *actual_args)
 {
   tree type;
   tree fndecl;
@@ -2002,10 +2047,23 @@
     return get_proc_pointer_decl (sym);
 
   /* See if this is an external procedure from the same file.  If so,
-     return the backend_decl.  */
-  gsym =  gfc_find_gsymbol (gfc_gsym_root, sym->binding_label
-					   ? sym->binding_label : sym->name);
+     return the backend_decl.  If we are looking at a BIND(C)
+     procedure and the symbol is not BIND(C), or vice versa, we
+     haven't found the right procedure.  */
 
+  if (sym->binding_label)
+    {
+      gsym = gfc_find_gsymbol (gfc_gsym_root, sym->binding_label);
+      if (gsym && !gsym->bind_c)
+	gsym = NULL;
+    }
+  else
+    {
+      gsym = gfc_find_gsymbol (gfc_gsym_root, sym->name);
+      if (gsym && gsym->bind_c)
+	gsym = NULL;
+    }
+
   if (gsym && !gsym->defined)
     gsym = NULL;
 
@@ -2150,7 +2208,7 @@
       mangled_name = gfc_sym_mangled_function_id (sym);
     }
 
-  type = gfc_get_function_type (sym);
+  type = gfc_get_function_type (sym, actual_args);
   fndecl = build_decl (input_location,
 		       FUNCTION_DECL, name, type);
 
@@ -2500,6 +2558,17 @@
 	  TREE_READONLY (length) = 1;
 	  gfc_finish_decl (length);
 
+	  /* Marking the length DECL_HIDDEN_STRING_LENGTH will lead
+	     to tail calls being disabled.  Only do that if we
+	     potentially have broken callers.  */
+	  if (flag_tail_call_workaround
+	      && f->sym->ts.u.cl
+	      && f->sym->ts.u.cl->length
+	      && f->sym->ts.u.cl->length->expr_type == EXPR_CONSTANT
+	      && (flag_tail_call_workaround == 2
+		  || f->sym->ns->implicit_interface_calls))
+	    DECL_HIDDEN_STRING_LENGTH (length) = 1;
+
 	  /* Remember the passed value.  */
           if (!f->sym->ts.u.cl ||  f->sym->ts.u.cl->passed_length)
             {
@@ -5384,6 +5453,33 @@
   /* Handle "static" initializer.  */
   if (sym->value)
     {
+      if (sym->value->expr_type == EXPR_ARRAY)
+	{
+	  gfc_constructor *c, *cnext;
+
+	  /* Test if the array has more than one element.  */
+	  c = gfc_constructor_first (sym->value->value.constructor);
+	  gcc_assert (c);  /* Empty constructor should not happen here.  */
+	  cnext = gfc_constructor_next (c);
+
+	  if (cnext)
+	    {
+	      /* An EXPR_ARRAY with a rank > 1 here has to come from a
+		 DATA statement.  Set its rank here as not to confuse
+		 the following steps.   */
+	      sym->value->rank = 1;
+	    }
+	  else
+	    {
+	      /* There is only a single value in the constructor, use
+		 it directly for the assignment.  */
+	      gfc_expr *new_expr;
+	      new_expr = gfc_copy_expr (c->expr);
+	      gfc_free_expr (sym->value);
+	      sym->value = new_expr;
+	    }
+	}
+
       sym->attr.pointer = 1;
       tmp = gfc_trans_assignment (gfc_lval_expr_from_sym (sym), sym->value,
 				  true, false);
Index: gcc/fortran/target-memory.c
===================================================================
--- a/src/gcc/fortran/target-memory.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/target-memory.c	(.../branches/gcc-8-branch)
@@ -73,10 +73,10 @@
 
 
 /* Return the size of a single element of the given expression.
-   Identical to gfc_target_expr_size for scalars.  */
+   Equivalent to gfc_target_expr_size for scalars.  */
 
-size_t
-gfc_element_size (gfc_expr *e)
+bool
+gfc_element_size (gfc_expr *e, size_t *siz)
 {
   tree type;
 
@@ -83,16 +83,20 @@
   switch (e->ts.type)
     {
     case BT_INTEGER:
-      return size_integer (e->ts.kind);
+      *siz = size_integer (e->ts.kind);
+      return true;
     case BT_REAL:
-      return size_float (e->ts.kind);
+      *siz = size_float (e->ts.kind);
+      return true;
     case BT_COMPLEX:
-      return size_complex (e->ts.kind);
+      *siz = size_complex (e->ts.kind);
+      return true;
     case BT_LOGICAL:
-      return size_logical (e->ts.kind);
+      *siz = size_logical (e->ts.kind);
+      return true;
     case BT_CHARACTER:
       if (e->expr_type == EXPR_CONSTANT)
-	return size_character (e->value.character.length, e->ts.kind);
+	*siz = size_character (e->value.character.length, e->ts.kind);
       else if (e->ts.u.cl != NULL && e->ts.u.cl->length != NULL
 	       && e->ts.u.cl->length->expr_type == EXPR_CONSTANT
 	       && e->ts.u.cl->length->ts.type == BT_INTEGER)
@@ -100,17 +104,23 @@
 	  HOST_WIDE_INT length;
 
 	  gfc_extract_hwi (e->ts.u.cl->length, &length);
-	  return size_character (length, e->ts.kind);
+	  *siz = size_character (length, e->ts.kind);
 	}
       else
-	return 0;
+	{
+	  *siz = 0;
+	  return false;
+	}
+      return true;
 
     case BT_HOLLERITH:
-      return e->representation.length;
+      *siz = e->representation.length;
+      return true;
     case BT_DERIVED:
     case BT_CLASS:
     case BT_VOID:
     case BT_ASSUMED:
+    case BT_PROCEDURE:
       {
 	/* Determine type size without clobbering the typespec for ISO C
 	   binding types.  */
@@ -120,36 +130,43 @@
 	type = gfc_typenode_for_spec (&ts);
 	size = int_size_in_bytes (type);
 	gcc_assert (size >= 0);
-	return size;
+	*siz = size;
       }
+      return true;
     default:
       gfc_internal_error ("Invalid expression in gfc_element_size.");
-      return 0;
+      *siz = 0;
+      return false;
     }
+  return true;
 }
 
 
 /* Return the size of an expression in its target representation.  */
 
-size_t
-gfc_target_expr_size (gfc_expr *e)
+bool
+gfc_target_expr_size (gfc_expr *e, size_t *size)
 {
   mpz_t tmp;
-  size_t asz;
+  size_t asz, el_size;
 
   gcc_assert (e != NULL);
 
+  *size = 0;
   if (e->rank)
     {
       if (gfc_array_size (e, &tmp))
 	asz = mpz_get_ui (tmp);
       else
-	asz = 0;
+	return false;
     }
   else
     asz = 1;
 
-  return asz * gfc_element_size (e);
+  if (!gfc_element_size (e, &el_size))
+    return false;
+  *size = asz * el_size;
+  return true;
 }
 
 
@@ -675,7 +692,7 @@
 
   /* Otherwise, use the target-memory machinery to write a bitwise image, appropriate
      to the target, in a buffer and check off the initialized part of the buffer.  */
-  len = gfc_target_expr_size (e);
+  gfc_target_expr_size (e, &len);
   buffer = (unsigned char*)alloca (len);
   len = gfc_target_encode_expr (e, buffer, len);
 
@@ -722,8 +739,10 @@
       for (c = gfc_constructor_first (e->value.constructor);
 	   c; c = gfc_constructor_next (c))
 	{
-	  size_t elt_size = gfc_target_expr_size (c->expr);
+	  size_t elt_size;
 
+	  gfc_target_expr_size (c->expr, &elt_size);
+
 	  if (mpz_cmp_si (c->offset, 0) != 0)
 	    len = elt_size * (size_t)mpz_get_si (c->offset);
 
Index: gcc/fortran/match.c
===================================================================
--- a/src/gcc/fortran/match.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/match.c	(.../branches/gcc-8-branch)
@@ -2105,8 +2105,6 @@
       ts->type = BT_CHARACTER;
 
       m = gfc_match_char_spec (ts);
-      if (ts->u.cl && ts->u.cl->length)
-	gfc_resolve_expr (ts->u.cl->length);
 
       if (m == MATCH_NO)
 	m = MATCH_YES;
Index: gcc/fortran/trans-io.c
===================================================================
--- a/src/gcc/fortran/trans-io.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/trans-io.c	(.../branches/gcc-8-branch)
@@ -2408,8 +2408,6 @@
 
     case_bt_struct:
     case BT_CLASS:
-      if (ts->u.derived->components == NULL)
-	return;
       if (gfc_bt_struct (ts->type) || ts->type == BT_CLASS)
 	{
 	  gfc_symbol *derived;
Index: gcc/fortran/target-memory.h
===================================================================
--- a/src/gcc/fortran/target-memory.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/target-memory.h	(.../branches/gcc-8-branch)
@@ -24,8 +24,8 @@
 /* Convert a BOZ to REAL or COMPLEX.  */
 bool gfc_convert_boz (gfc_expr *, gfc_typespec *);
 
-size_t gfc_element_size (gfc_expr *);
-size_t gfc_target_expr_size (gfc_expr *);
+bool gfc_element_size (gfc_expr *, size_t *);
+bool gfc_target_expr_size (gfc_expr *, size_t *);
 
 /* Write a constant expression in binary form to a target buffer.  */
 size_t gfc_encode_character (int, size_t, const gfc_char_t *, unsigned char *,
Index: gcc/fortran/arith.c
===================================================================
--- a/src/gcc/fortran/arith.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/arith.c	(.../branches/gcc-8-branch)
@@ -2548,10 +2548,10 @@
 static void
 hollerith2representation (gfc_expr *result, gfc_expr *src)
 {
-  int src_len, result_len;
+  size_t src_len, result_len;
 
   src_len = src->representation.length - src->ts.u.pad;
-  result_len = gfc_target_expr_size (result);
+  gfc_target_expr_size (result, &result_len);
 
   if (src_len > result_len)
     {
Index: gcc/fortran/parse.c
===================================================================
--- a/src/gcc/fortran/parse.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/parse.c	(.../branches/gcc-8-branch)
@@ -5830,7 +5830,7 @@
     }
   else
     {
-      s = gfc_get_gsymbol (gfc_new_block->name);
+      s = gfc_get_gsymbol (gfc_new_block->name, false);
       if (s->defined
 	  || (s->type != GSYM_UNKNOWN && s->type != GSYM_BLOCK_DATA))
        gfc_global_used (s, &gfc_new_block->declared_at);
@@ -5912,7 +5912,7 @@
   gfc_gsymbol *s;
   bool error;
 
-  s = gfc_get_gsymbol (gfc_new_block->name);
+  s = gfc_get_gsymbol (gfc_new_block->name, false);
   if (s->defined || (s->type != GSYM_UNKNOWN && s->type != GSYM_MODULE))
     gfc_global_used (s, &gfc_new_block->declared_at);
   else
@@ -5976,7 +5976,7 @@
      name is a global identifier.  */
   if (!gfc_new_block->binding_label || gfc_notification_std (GFC_STD_F2008))
     {
-      s = gfc_get_gsymbol (gfc_new_block->name);
+      s = gfc_get_gsymbol (gfc_new_block->name, false);
 
       if (s->defined
 	  || (s->type != GSYM_UNKNOWN
@@ -6001,7 +6001,7 @@
       && (!gfc_notification_std (GFC_STD_F2008)
           || strcmp (gfc_new_block->name, gfc_new_block->binding_label) != 0))
     {
-      s = gfc_get_gsymbol (gfc_new_block->binding_label);
+      s = gfc_get_gsymbol (gfc_new_block->binding_label, true);
 
       if (s->defined
 	  || (s->type != GSYM_UNKNOWN
@@ -6033,7 +6033,7 @@
 
   if (gfc_new_block == NULL)
     return;
-  s = gfc_get_gsymbol (gfc_new_block->name);
+  s = gfc_get_gsymbol (gfc_new_block->name, false);
 
   if (s->defined || (s->type != GSYM_UNKNOWN && s->type != GSYM_PROGRAM))
     gfc_global_used (s, &gfc_new_block->declared_at);
Index: gcc/fortran/check.c
===================================================================
--- a/src/gcc/fortran/check.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/check.c	(.../branches/gcc-8-branch)
@@ -5413,17 +5413,42 @@
     return false;
 
   /* Calculate the size of the source.  */
-  *source_size = gfc_target_expr_size (source);
-  if (*source_size == 0)
+  if (!gfc_target_expr_size (source, source_size))
     return false;
 
   /* Determine the size of the element.  */
-  result_elt_size = gfc_element_size (mold);
-  if (result_elt_size == 0)
+  if (!gfc_element_size (mold, &result_elt_size))
     return false;
 
-  if (mold->expr_type == EXPR_ARRAY || mold->rank || size)
+  /* If the storage size of SOURCE is greater than zero and MOLD is an array,
+   * a scalar with the type and type parameters of MOLD shall not have a
+   * storage size equal to zero.
+   * If MOLD is a scalar and SIZE is absent, the result is a scalar.
+   * If MOLD is an array and SIZE is absent, the result is an array and of
+   * rank one. Its size is as small as possible such that its physical
+   * representation is not shorter than that of SOURCE.
+   * If SIZE is present, the result is an array of rank one and size SIZE.
+   */
+  if (result_elt_size == 0 && *source_size > 0 && !size
+      && mold->expr_type == EXPR_ARRAY)
     {
+      gfc_error ("%<MOLD%> argument of %<TRANSFER%> intrinsic at %L is an "
+		 "array and shall not have storage size 0 when %<SOURCE%> "
+		 "argument has size greater than 0", &mold->where);
+      return false;
+    }
+
+  if (result_elt_size == 0 && *source_size == 0 && !size)
+    {
+      *result_size = 0;
+      if (result_length_p)
+	*result_length_p = 0;
+      return true;
+    }
+
+  if ((result_elt_size > 0 && (mold->expr_type == EXPR_ARRAY || mold->rank))
+      || size)
+    {
       int result_length;
 
       if (size)
@@ -5452,6 +5477,26 @@
   size_t source_size;
   size_t result_size;
 
+  /* SOURCE shall be a scalar or array of any type.  */
+  if (source->ts.type == BT_PROCEDURE
+      && source->symtree->n.sym->attr.subroutine == 1)
+    {
+      gfc_error ("%<SOURCE%> argument of %<TRANSFER%> intrinsic at %L "
+                 "must not be a %s", &source->where,
+		 gfc_basic_typename (source->ts.type));
+      return false;
+    }
+
+  /* MOLD shall be a scalar or array of any type.  */
+  if (mold->ts.type == BT_PROCEDURE
+      && mold->symtree->n.sym->attr.subroutine == 1)
+    {
+      gfc_error ("%<MOLD%> argument of %<TRANSFER%> intrinsic at %L "
+                 "must not be a %s", &mold->where,
+		 gfc_basic_typename (mold->ts.type));
+      return false;
+    }
+
   if (mold->ts.type == BT_HOLLERITH)
     {
       gfc_error ("%<MOLD%> argument of %<TRANSFER%> intrinsic at %L must not be"
@@ -5459,6 +5504,8 @@
       return false;
     }
 
+  /* SIZE (optional) shall be an integer scalar.  The corresponding actual
+     argument shall not be an optional dummy argument.  */
   if (size != NULL)
     {
       if (!type_check (size, 2, BT_INTEGER))
Index: gcc/fortran/trans-intrinsic.c
===================================================================
--- a/src/gcc/fortran/trans-intrinsic.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/trans-intrinsic.c	(.../branches/gcc-8-branch)
@@ -6820,6 +6820,8 @@
   tree fncall0;
   tree fncall1;
   gfc_se argse;
+  gfc_expr *e;
+  gfc_symbol *sym = NULL;
 
   gfc_init_se (&argse, NULL);
   actual = expr->value.function.actual;
@@ -6827,15 +6829,34 @@
   if (actual->expr->ts.type == BT_CLASS)
     gfc_add_class_array_ref (actual->expr);
 
+  e = actual->expr;
+
+  /* These are emerging from the interface mapping, when a class valued
+     function appears as the rhs in a realloc on assign statement, where
+     the size of the result is that of one of the actual arguments.  */
+  if (e->expr_type == EXPR_VARIABLE
+      && e->symtree->n.sym->ns == NULL /* This is distinctive!  */
+      && e->symtree->n.sym->ts.type == BT_CLASS
+      && e->ref && e->ref->type == REF_COMPONENT
+      && strcmp (e->ref->u.c.component->name, "_data") == 0)
+    sym = e->symtree->n.sym;
+
   argse.data_not_needed = 1;
-  if (gfc_is_class_array_function (actual->expr))
+  if (gfc_is_class_array_function (e))
     {
       /* For functions that return a class array conv_expr_descriptor is not
 	 able to get the descriptor right.  Therefore this special case.  */
-      gfc_conv_expr_reference (&argse, actual->expr);
+      gfc_conv_expr_reference (&argse, e);
       argse.expr = gfc_build_addr_expr (NULL_TREE,
 					gfc_class_data_get (argse.expr));
     }
+  else if (sym && sym->backend_decl)
+    {
+      gcc_assert (GFC_CLASS_TYPE_P (TREE_TYPE (sym->backend_decl)));
+      argse.expr = sym->backend_decl;
+      argse.expr = gfc_build_addr_expr (NULL_TREE,
+					gfc_class_data_get (argse.expr));
+    }
   else
     {
       argse.want_pointer = 1;
Index: gcc/fortran/simplify.c
===================================================================
--- a/src/gcc/fortran/simplify.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/fortran/simplify.c	(.../branches/gcc-8-branch)
@@ -4469,7 +4469,7 @@
     /* The expression in assoc->target points to a ref to the _data component
        of the unlimited polymorphic entity.  To get the _len component the last
        _data ref needs to be stripped and a ref to the _len component added.  */
-    return gfc_get_len_component (e->symtree->n.sym->assoc->target);
+    return gfc_get_len_component (e->symtree->n.sym->assoc->target, k);
   else
     return NULL;
 }
@@ -6921,6 +6921,7 @@
 {
   gfc_expr *result = NULL;
   mpz_t array_size;
+  size_t res_size;
 
   if (x->ts.type == BT_CLASS || x->ts.deferred)
     return NULL;
@@ -6936,7 +6937,8 @@
 
   result = gfc_get_constant_expr (BT_INTEGER, gfc_index_integer_kind,
 				  &x->where);
-  mpz_set_si (result->value.integer, gfc_target_expr_size (x));
+  gfc_target_expr_size (x, &res_size);
+  mpz_set_si (result->value.integer, res_size);
 
   return result;
 }
@@ -6950,6 +6952,7 @@
 {
   gfc_expr *result = NULL;
   int k;
+  size_t siz;
 
   if (x->ts.type == BT_CLASS || x->ts.deferred)
     return NULL;
@@ -6965,7 +6968,8 @@
 
   result = gfc_get_constant_expr (BT_INTEGER, k, &x->where);
 
-  mpz_set_si (result->value.integer, gfc_element_size (x));
+  gfc_element_size (x, &siz);
+  mpz_set_si (result->value.integer, siz);
   mpz_mul_ui (result->value.integer, result->value.integer, BITS_PER_UNIT);
 
   return range_check (result, "STORAGE_SIZE");
Index: gcc/configure.ac
===================================================================
--- a/src/gcc/configure.ac	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/configure.ac	(.../branches/gcc-8-branch)
@@ -2595,17 +2595,13 @@
 	#
 	# ld: Software Generation Utilities - Solaris Link Editors: 5.11-1.1701:onnv-ab196087-6931056-03/25/10
 	#
-	# In Solaris 11.4, this was changed to
-	#
-	# ld: Solaris ELF Utilities: 11.4-1.3123
-	#
 	# ld and ld.so.1 are guaranteed to be updated in lockstep, so ld version
 	# numbers can be used in ld.so.1 feature checks even if a different
 	# linker is configured.
 	ld_ver=`$gcc_cv_ld -V 2>&1`
-	if echo "$ld_ver" | $EGREP 'Solaris Link Editors|Solaris ELF Utilities' > /dev/null; then
+	if echo "$ld_ver" | grep 'Solaris Link Editors' > /dev/null; then
 	  ld_vers=`echo $ld_ver | sed -n \
-	    -e 's,^.*: \(5\|1[0-9]\)\.[0-9][0-9]*-\([0-9]\.[0-9][0-9]*\).*$,\2,p'`
+	    -e 's,^.*: 5\.[0-9][0-9]*-\([0-9]\.[0-9][0-9]*\).*$,\1,p'`
 	  ld_vers_major=`expr "$ld_vers" : '\([0-9]*\)'`
 	  ld_vers_minor=`expr "$ld_vers" : '[0-9]*\.\([0-9]*\)'`
 	fi
Index: gcc/BASE-VER
===================================================================
--- a/src/gcc/BASE-VER	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/BASE-VER	(.../branches/gcc-8-branch)
@@ -1 +1 @@
-8.3.0
+8.3.1
Index: gcc/loop-unroll.c
===================================================================
--- a/src/gcc/loop-unroll.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/loop-unroll.c	(.../branches/gcc-8-branch)
@@ -399,7 +399,7 @@
     {
       /* However we cannot unroll completely at the RTL level a loop with
 	 constant number of iterations; it should have been peeled instead.  */
-      if ((unsigned) loop->unroll - 1 > desc->niter - 2)
+      if (desc->niter == 0 || (unsigned) loop->unroll > desc->niter - 1)
 	{
 	  if (dump_file)
 	    fprintf (dump_file, ";; Loop should have been peeled\n");
@@ -651,7 +651,7 @@
   if (loop->any_likely_upper_bound)
     loop->nb_iterations_likely_upper_bound
       = wi::udiv_trunc (loop->nb_iterations_likely_upper_bound, max_unroll + 1);
-  desc->niter_expr = GEN_INT (desc->niter);
+  desc->niter_expr = gen_int_mode (desc->niter, desc->mode);
 
   /* Remove the edges.  */
   FOR_EACH_VEC_ELT (remove_edges, i, e)
@@ -1019,9 +1019,9 @@
       preheader = split_edge (loop_preheader_edge (loop));
       /* Add in count of edge from switch block.  */
       preheader->count += iter_count;
-      branch_code = compare_and_jump_seq (copy_rtx (niter), GEN_INT (j), EQ,
-					  block_label (preheader), p,
-					  NULL);
+      branch_code = compare_and_jump_seq (copy_rtx (niter),
+					  gen_int_mode (j, desc->mode), EQ,
+					  block_label (preheader), p, NULL);
 
       /* We rely on the fact that the compare and jump cannot be optimized out,
 	 and hence the cfg we create is correct.  */
Index: gcc/tree-vect-data-refs.c
===================================================================
--- a/src/gcc/tree-vect-data-refs.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-vect-data-refs.c	(.../branches/gcc-8-branch)
@@ -206,26 +206,60 @@
     return true;
 
   /* STMT_A and STMT_B belong to overlapping groups.  All loads in a
-     group are emitted at the position of the last scalar load and all
-     stores in a group are emitted at the position of the last scalar store.
+     SLP group are emitted at the position of the last scalar load and
+     all loads in an interleaving group are emitted at the position
+     of the first scalar load.
+     Stores in a group are emitted at the position of the last scalar store.
      Compute that position and check whether the resulting order matches
-     the current one.  */
-  gimple *last_a = GROUP_FIRST_ELEMENT (stmtinfo_a);
+     the current one.
+     We have not yet decided between SLP and interleaving so we have
+     to conservatively assume both.  */
+  gimple *il_a;
+  gimple *last_a = il_a = GROUP_FIRST_ELEMENT (stmtinfo_a);
   if (last_a)
-    for (gimple *s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (last_a)); s;
-	 s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (s)))
-      last_a = get_later_stmt (last_a, s);
+    {
+      for (gimple *s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (last_a)); s;
+	   s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (s)))
+	last_a = get_later_stmt (last_a, s);
+      if (!DR_IS_WRITE (STMT_VINFO_DATA_REF (stmtinfo_a)))
+	{
+	  for (gimple *s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (il_a)); s;
+	       s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (s)))
+	    if (get_later_stmt (il_a, s) == il_a)
+	      il_a = s;
+	}
+      else
+	il_a = last_a;
+    }
   else
-    last_a = stmt_a;
-  gimple *last_b = GROUP_FIRST_ELEMENT (stmtinfo_b);
+    last_a = il_a = stmt_a;
+  gimple *il_b;
+  gimple *last_b = il_b = GROUP_FIRST_ELEMENT (stmtinfo_b);
   if (last_b)
-    for (gimple *s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (last_b)); s;
-	 s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (s)))
-      last_b = get_later_stmt (last_b, s);
+    {
+      for (gimple *s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (last_b)); s;
+	   s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (s)))
+	last_b = get_later_stmt (last_b, s);
+      if (!DR_IS_WRITE (STMT_VINFO_DATA_REF (stmtinfo_b)))
+	{
+	  for (gimple *s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (il_b)); s;
+	       s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (s)))
+	    if (get_later_stmt (il_b, s) == il_b)
+	      il_b = s;
+	}
+      else
+	il_b = last_b;
+    }
   else
-    last_b = stmt_b;
-  return ((get_later_stmt (last_a, last_b) == last_a)
-	  == (get_later_stmt (stmt_a, stmt_b) == stmt_a));
+    last_b = il_b = stmt_b;
+  bool a_after_b = (get_later_stmt (stmt_a, stmt_b) == stmt_a);
+  return (/* SLP */
+	  (get_later_stmt (last_a, last_b) == last_a) == a_after_b
+	  /* Interleaving */
+	  && (get_later_stmt (il_a, il_b) == il_a) == a_after_b
+	  /* Mixed */
+	  && (get_later_stmt (il_a, last_b) == il_a) == a_after_b
+	  && (get_later_stmt (last_a, il_b) == last_a) == a_after_b);
 }
 
 /* A subroutine of vect_analyze_data_ref_dependence.  Handle
Index: gcc/gimplify.c
===================================================================
--- a/src/gcc/gimplify.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/gimplify.c	(.../branches/gcc-8-branch)
@@ -4650,6 +4650,7 @@
      otherwise we'd generate a new temporary, and we can as well just
      use the decl we already have.  */
   else if (!TREE_ADDRESSABLE (decl)
+	   && !TREE_THIS_VOLATILE (decl)
 	   && init
 	   && (fallback & fb_lvalue) == 0
 	   && gimple_test_f (init))
@@ -6144,6 +6145,19 @@
 	  is_inout = false;
 	}
 
+      /* If we can't make copies, we can only accept memory.  */
+      if (TREE_ADDRESSABLE (TREE_TYPE (TREE_VALUE (link))))
+	{
+	  if (allows_mem)
+	    allows_reg = 0;
+	  else
+	    {
+	      error ("impossible constraint in %<asm%>");
+	      error ("non-memory output %d must stay in memory", i);
+	      return GS_ERROR;
+	    }
+	}
+
       if (!allows_reg && allows_mem)
 	mark_addressable (TREE_VALUE (link));
 
@@ -6639,6 +6653,7 @@
 	    }
 	  if (asan_poisoned_variables
 	      && DECL_ALIGN (temp) <= MAX_SUPPORTED_STACK_ALIGNMENT
+	      && !TREE_STATIC (temp)
 	      && dbg_cnt (asan_use_after_scope)
 	      && !gimplify_omp_ctxp)
 	    {
Index: gcc/lra-constraints.c
===================================================================
--- a/src/gcc/lra-constraints.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/lra-constraints.c	(.../branches/gcc-8-branch)
@@ -2315,6 +2315,8 @@
 		  break;
 
 		reg:
+		  if (mode == BLKmode)
+		    break;
 		  this_alternative = reg_class_subunion[this_alternative][cl];
 		  IOR_HARD_REG_SET (this_alternative_set,
 				    reg_class_contents[cl]);
@@ -2325,8 +2327,6 @@
 		      IOR_HARD_REG_SET (this_costly_alternative_set,
 					reg_class_contents[cl]);
 		    }
-		  if (mode == BLKmode)
-		    break;
 		  winreg = true;
 		  if (REG_P (op))
 		    {
@@ -6293,6 +6293,7 @@
 			add_to_hard_reg_set (&s, PSEUDO_REGNO_MODE (dst_regno),
 					     reg_renumber[dst_regno]);
 		      AND_COMPL_HARD_REG_SET (live_hard_regs, s);
+		      AND_COMPL_HARD_REG_SET (potential_reload_hard_regs, s);
 		    }
 		  /* We should invalidate potential inheritance or
 		     splitting for the current insn usages to the next
Index: gcc/calls.c
===================================================================
--- a/src/gcc/calls.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/calls.c	(.../branches/gcc-8-branch)
@@ -3754,6 +3754,28 @@
       || dbg_cnt (tail_call) == false)
     try_tail_call = 0;
 
+  /* Workaround buggy C/C++ wrappers around Fortran routines with
+     character(len=constant) arguments if the hidden string length arguments
+     are passed on the stack; if the callers forget to pass those arguments,
+     attempting to tail call in such routines leads to stack corruption.
+     Avoid tail calls in functions where at least one such hidden string
+     length argument is passed (partially or fully) on the stack in the
+     caller and the callee needs to pass any arguments on the stack.
+     See PR90329.  */
+  if (try_tail_call && maybe_ne (args_size.constant, 0))
+    for (tree arg = DECL_ARGUMENTS (current_function_decl);
+	 arg; arg = DECL_CHAIN (arg))
+      if (DECL_HIDDEN_STRING_LENGTH (arg) && DECL_INCOMING_RTL (arg))
+	{
+	  subrtx_iterator::array_type array;
+	  FOR_EACH_SUBRTX (iter, array, DECL_INCOMING_RTL (arg), NONCONST)
+	    if (MEM_P (*iter))
+	      {
+		try_tail_call = 0;
+		break;
+	      }
+	}
+
   /* If the user has marked the function as requiring tail-call
      optimization, attempt it.  */
   if (must_tail_call)
Index: gcc/multiple_target.c
===================================================================
--- a/src/gcc/multiple_target.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/multiple_target.c	(.../branches/gcc-8-branch)
@@ -103,10 +103,16 @@
     inode->resolve_alias (cgraph_node::get (resolver_decl));
 
   auto_vec<cgraph_edge *> edges_to_redirect;
-  auto_vec<ipa_ref *> references_to_redirect;
+  /* We need to capture the references by value rather than just pointers to them
+     and remove them right away, as removing them later would invalidate what
+     some other reference pointers point to.  */
+  auto_vec<ipa_ref> references_to_redirect;
 
-  for (unsigned i = 0; node->iterate_referring (i, ref); i++)
-    references_to_redirect.safe_push (ref);
+  while (node->iterate_referring (0, ref))
+    {
+      references_to_redirect.safe_push (*ref);
+      ref->remove_reference ();
+    }
 
   /* We need to remember NEXT_CALLER as it could be modified in the loop.  */
   for (cgraph_edge *e = node->callers; e ; e = e->next_caller)
@@ -146,15 +152,14 @@
 		}
 
 	      symtab_node *source = ref->referring;
-	      ref->remove_reference ();
 	      source->create_reference (inode, IPA_REF_ADDR);
 	    }
 	  else if (ref->use == IPA_REF_ALIAS)
 	    {
 	      symtab_node *source = ref->referring;
-	      ref->remove_reference ();
 	      source->create_reference (inode, IPA_REF_ALIAS);
-	      source->add_to_same_comdat_group (inode);
+	      if (inode->get_comdat_group ())
+		source->add_to_same_comdat_group (inode);
 	    }
 	  else
 	    gcc_unreachable ();
@@ -294,7 +299,8 @@
 /*  Creates target clone of NODE.  */
 
 static cgraph_node *
-create_target_clone (cgraph_node *node, bool definition, char *name)
+create_target_clone (cgraph_node *node, bool definition, char *name,
+		     tree attributes)
 {
   cgraph_node *new_node;
 
@@ -303,7 +309,9 @@
       new_node = node->create_version_clone_with_body (vNULL, NULL,
     						       NULL, false,
 						       NULL, NULL,
-						       name);
+						       name, attributes);
+      if (new_node == NULL)
+	return NULL;
       new_node->force_output = true;
     }
   else
@@ -310,6 +318,7 @@
     {
       tree new_decl = copy_node (node->decl);
       new_node = cgraph_node::get_create (new_decl);
+      DECL_ATTRIBUTES (new_decl) = attributes;
       /* Generate a new name for the new version.  */
       symtab->change_decl_assembler_name (new_node->decl,
 					  clone_function_name (node->decl,
@@ -399,22 +408,16 @@
 
       create_new_asm_name (attr, suffix);
       /* Create new target clone.  */
-      cgraph_node *new_node = create_target_clone (node, definition, suffix);
+      tree attributes = make_attribute ("target", attr,
+					DECL_ATTRIBUTES (node->decl));
+
+      cgraph_node *new_node = create_target_clone (node, definition, suffix,
+						   attributes);
+      if (new_node == NULL)
+	return false;
       new_node->local.local = false;
       XDELETEVEC (suffix);
 
-      /* Set new attribute for the clone.  */
-      tree attributes = make_attribute ("target", attr,
-					DECL_ATTRIBUTES (new_node->decl));
-      DECL_ATTRIBUTES (new_node->decl) = attributes;
-      location_t saved_loc = input_location;
-      input_location = DECL_SOURCE_LOCATION (node->decl);
-      if (!targetm.target_option.valid_attribute_p (new_node->decl, NULL,
-						    TREE_VALUE (attributes),
-						    0))
-	return false;
-
-      input_location = saved_loc;
       decl2_v = new_node->function_version ();
       if (decl2_v != NULL)
         continue;
@@ -441,13 +444,7 @@
 				    DECL_ATTRIBUTES (node->decl));
   DECL_ATTRIBUTES (node->decl) = attributes;
   node->local.local = false;
-  location_t saved_loc = input_location;
-  input_location = DECL_SOURCE_LOCATION (node->decl);
-  bool ret
-    = targetm.target_option.valid_attribute_p (node->decl, NULL,
-					       TREE_VALUE (attributes), 0);
-  input_location = saved_loc;
-  return ret;
+  return true;
 }
 
 static unsigned int
Index: gcc/expmed.c
===================================================================
--- a/src/gcc/expmed.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/expmed.c	(.../branches/gcc-8-branch)
@@ -3352,13 +3352,20 @@
 	      tem = gen_lowpart (nmode, op0);
 	    }
 
-	  insn = get_last_insn ();
-	  wide_int wval_so_far
-	    = wi::uhwi (val_so_far,
-			GET_MODE_PRECISION (as_a <scalar_mode> (nmode)));
-	  rtx c = immed_wide_int_const (wval_so_far, nmode);
-	  set_dst_reg_note (insn, REG_EQUAL, gen_rtx_MULT (nmode, tem, c),
-			    accum_inner);
+	  /* Don't add a REG_EQUAL note if tem is a paradoxical SUBREG.
+	     In that case, only the low bits of accum would be guaranteed to
+	     be equal to the content of the REG_EQUAL note, the upper bits
+	     can be anything.  */
+	  if (!paradoxical_subreg_p (tem))
+	    {
+	      insn = get_last_insn ();
+	      wide_int wval_so_far
+		= wi::uhwi (val_so_far,
+			    GET_MODE_PRECISION (as_a <scalar_mode> (nmode)));
+	      rtx c = immed_wide_int_const (wval_so_far, nmode);
+	      set_dst_reg_note (insn, REG_EQUAL, gen_rtx_MULT (nmode, tem, c),
+				accum_inner);
+	    }
 	}
     }
 
Index: gcc/emit-rtl.c
===================================================================
--- a/src/gcc/emit-rtl.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/emit-rtl.c	(.../branches/gcc-8-branch)
@@ -3940,6 +3940,7 @@
 	  break;
 
 	case REG_NON_LOCAL_GOTO:
+	case REG_LABEL_TARGET:
 	  for (insn = insn_last; insn != NULL_RTX; insn = PREV_INSN (insn))
 	    {
 	      if (JUMP_P (insn))
Index: gcc/gimple-fold.c
===================================================================
--- a/src/gcc/gimple-fold.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/gimple-fold.c	(.../branches/gcc-8-branch)
@@ -3031,11 +3031,10 @@
       gimple_seq stmts = NULL;
       gimple *repl = gimple_build_call (fn, 2, dest, fmt);
       gimple_seq_add_stmt_without_update (&stmts, repl);
-      if (gimple_call_lhs (stmt))
+      if (tree lhs = gimple_call_lhs (stmt))
 	{
-	  repl = gimple_build_assign (gimple_call_lhs (stmt),
-				      build_int_cst (integer_type_node,
-						     strlen (fmt_str)));
+	  repl = gimple_build_assign (lhs, build_int_cst (TREE_TYPE (lhs),
+							  strlen (fmt_str)));
 	  gimple_seq_add_stmt_without_update (&stmts, repl);
 	  gsi_replace_with_seq_vops (gsi, stmts);
 	  /* gsi now points at the assignment to the lhs, get a
@@ -3079,12 +3078,12 @@
       gimple_seq stmts = NULL;
       gimple *repl = gimple_build_call (fn, 2, dest, orig);
       gimple_seq_add_stmt_without_update (&stmts, repl);
-      if (gimple_call_lhs (stmt))
+      if (tree lhs = gimple_call_lhs (stmt))
 	{
-	  if (!useless_type_conversion_p (integer_type_node,
+	  if (!useless_type_conversion_p (TREE_TYPE (lhs),
 					  TREE_TYPE (orig_len)))
-	    orig_len = fold_convert (integer_type_node, orig_len);
-	  repl = gimple_build_assign (gimple_call_lhs (stmt), orig_len);
+	    orig_len = fold_convert (TREE_TYPE (lhs), orig_len);
+	  repl = gimple_build_assign (lhs, orig_len);
 	  gimple_seq_add_stmt_without_update (&stmts, repl);
 	  gsi_replace_with_seq_vops (gsi, stmts);
 	  /* gsi now points at the assignment to the lhs, get a
@@ -3164,10 +3163,10 @@
       gimple_seq stmts = NULL;
       gimple *repl = gimple_build_call (fn, 2, dest, fmt);
       gimple_seq_add_stmt_without_update (&stmts, repl);
-      if (gimple_call_lhs (stmt))
+      if (tree lhs = gimple_call_lhs (stmt))
 	{
-	  repl = gimple_build_assign (gimple_call_lhs (stmt),
-				      build_int_cst (integer_type_node, len));
+	  repl = gimple_build_assign (lhs,
+				      build_int_cst (TREE_TYPE (lhs), len));
 	  gimple_seq_add_stmt_without_update (&stmts, repl);
 	  gsi_replace_with_seq_vops (gsi, stmts);
 	  /* gsi now points at the assignment to the lhs, get a
@@ -3216,12 +3215,12 @@
       gimple_seq stmts = NULL;
       gimple *repl = gimple_build_call (fn, 2, dest, orig);
       gimple_seq_add_stmt_without_update (&stmts, repl);
-      if (gimple_call_lhs (stmt))
+      if (tree lhs = gimple_call_lhs (stmt))
 	{
-	  if (!useless_type_conversion_p (integer_type_node,
+	  if (!useless_type_conversion_p (TREE_TYPE (lhs),
 					  TREE_TYPE (orig_len)))
-	    orig_len = fold_convert (integer_type_node, orig_len);
-	  repl = gimple_build_assign (gimple_call_lhs (stmt), orig_len);
+	    orig_len = fold_convert (TREE_TYPE (lhs), orig_len);
+	  repl = gimple_build_assign (lhs, orig_len);
 	  gimple_seq_add_stmt_without_update (&stmts, repl);
 	  gsi_replace_with_seq_vops (gsi, stmts);
 	  /* gsi now points at the assignment to the lhs, get a
Index: gcc/tree-cfgcleanup.c
===================================================================
--- a/src/gcc/tree-cfgcleanup.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-cfgcleanup.c	(.../branches/gcc-8-branch)
@@ -43,6 +43,8 @@
 #include "gimple-match.h"
 #include "gimple-fold.h"
 #include "tree-ssa-loop-niter.h"
+#include "tree-into-ssa.h"
+#include "tree-cfgcleanup.h"
 
 
 /* The set of blocks in that at least one of the following changes happened:
@@ -761,7 +763,7 @@
 /* Iterate the cfg cleanups, while anything changes.  */
 
 static bool
-cleanup_tree_cfg_1 (void)
+cleanup_tree_cfg_1 (unsigned ssa_update_flags)
 {
   bool retval = false;
   basic_block bb;
@@ -786,6 +788,8 @@
 
   /* After doing the above SSA form should be valid (or an update SSA
      should be required).  */
+  if (ssa_update_flags)
+    update_ssa (ssa_update_flags);
 
   /* Continue by iterating over all basic blocks looking for BB merging
      opportunities.  */
@@ -828,7 +832,7 @@
    Return true if the flowgraph was modified, false otherwise.  */
 
 static bool
-cleanup_tree_cfg_noloop (void)
+cleanup_tree_cfg_noloop (unsigned ssa_update_flags)
 {
   bool changed;
 
@@ -908,7 +912,7 @@
 	  }
     }
 
-  changed |= cleanup_tree_cfg_1 ();
+  changed |= cleanup_tree_cfg_1 (ssa_update_flags);
 
   gcc_assert (dom_info_available_p (CDI_DOMINATORS));
 
@@ -966,9 +970,9 @@
 /* Cleanup cfg and repair loop structures.  */
 
 bool
-cleanup_tree_cfg (void)
+cleanup_tree_cfg (unsigned ssa_update_flags)
 {
-  bool changed = cleanup_tree_cfg_noloop ();
+  bool changed = cleanup_tree_cfg_noloop (ssa_update_flags);
 
   if (current_loops != NULL
       && loops_state_satisfies_p (LOOPS_NEED_FIXUP))
Index: gcc/cfgcleanup.c
===================================================================
--- a/src/gcc/cfgcleanup.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/cfgcleanup.c	(.../branches/gcc-8-branch)
@@ -2705,23 +2705,23 @@
 
 		      if (current_ir_type () == IR_RTL_CFGLAYOUT)
 			{
-			  if (BB_FOOTER (b)
-			      && BARRIER_P (BB_FOOTER (b)))
+			  rtx_insn *insn;
+			  for (insn = BB_FOOTER (b);
+			       insn; insn = NEXT_INSN (insn))
+			    if (BARRIER_P (insn))
+			      break;
+			  if (insn)
 			    FOR_EACH_EDGE (e, ei, b->preds)
-			      if ((e->flags & EDGE_FALLTHRU)
-				  && BB_FOOTER (e->src) == NULL)
+			      if ((e->flags & EDGE_FALLTHRU))
 				{
-				  if (BB_FOOTER (b))
+				  if (BB_FOOTER (b)
+				      && BB_FOOTER (e->src) == NULL)
 				    {
 				      BB_FOOTER (e->src) = BB_FOOTER (b);
 				      BB_FOOTER (b) = NULL;
 				    }
 				  else
-				    {
-				      start_sequence ();
-				      BB_FOOTER (e->src) = emit_barrier ();
-				      end_sequence ();
-				    }
+				    emit_barrier_after_bb (e->src);
 				}
 			}
 		      else
Index: gcc/tree-cfgcleanup.h
===================================================================
--- a/src/gcc/tree-cfgcleanup.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-cfgcleanup.h	(.../branches/gcc-8-branch)
@@ -22,7 +22,7 @@
 
 /* In tree-cfgcleanup.c  */
 extern bitmap cfgcleanup_altered_bbs;
-extern bool cleanup_tree_cfg (void);
+extern bool cleanup_tree_cfg (unsigned = 0);
 extern bool fixup_noreturn_call (gimple *stmt);
 
 #endif /* GCC_TREE_CFGCLEANUP_H */
Index: gcc/tree-sra.c
===================================================================
--- a/src/gcc/tree-sra.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-sra.c	(.../branches/gcc-8-branch)
@@ -1150,11 +1150,13 @@
   return false;
 }
 
-/* Return true if REF contains a VIEW_CONVERT_EXPR or a MEM_REF that performs
-   type conversion or a COMPONENT_REF with a bit-field field declaration.  */
+/* Return true if REF contains a VIEW_CONVERT_EXPR or a COMPONENT_REF with a
+   bit-field field declaration.  If TYPE_CHANGING_P is non-NULL, set the bool
+   it points to will be set if REF contains any of the above or a MEM_REF
+   expression that effectively performs type conversion.  */
 
 static bool
-contains_vce_or_bfcref_p (const_tree ref)
+contains_vce_or_bfcref_p (const_tree ref, bool *type_changing_p = NULL)
 {
   while (handled_component_p (ref))
     {
@@ -1161,11 +1163,16 @@
       if (TREE_CODE (ref) == VIEW_CONVERT_EXPR
 	  || (TREE_CODE (ref) == COMPONENT_REF
 	      && DECL_BIT_FIELD (TREE_OPERAND (ref, 1))))
-	return true;
+	{
+	  if (type_changing_p)
+	    *type_changing_p = true;
+	  return true;
+	}
       ref = TREE_OPERAND (ref, 0);
     }
 
-  if (TREE_CODE (ref) != MEM_REF
+  if (!type_changing_p
+      || TREE_CODE (ref) != MEM_REF
       || TREE_CODE (TREE_OPERAND (ref, 0)) != ADDR_EXPR)
     return false;
 
@@ -1172,7 +1179,7 @@
   tree mem = TREE_OPERAND (TREE_OPERAND (ref, 0), 0);
   if (TYPE_MAIN_VARIANT (TREE_TYPE (ref))
       != TYPE_MAIN_VARIANT (TREE_TYPE (mem)))
-    return true;
+    *type_changing_p = true;
 
   return false;
 }
@@ -1368,15 +1375,26 @@
       lacc->grp_assignment_write = 1;
       if (storage_order_barrier_p (rhs))
 	lacc->grp_unscalarizable_region = 1;
+
+      if (should_scalarize_away_bitmap && !is_gimple_reg_type (lacc->type))
+	{
+	  bool type_changing_p = false;
+	  contains_vce_or_bfcref_p (lhs, &type_changing_p);
+	  if (type_changing_p)
+	    bitmap_set_bit (cannot_scalarize_away_bitmap,
+			    DECL_UID (lacc->base));
+	}
     }
 
   if (racc)
     {
       racc->grp_assignment_read = 1;
-      if (should_scalarize_away_bitmap && !gimple_has_volatile_ops (stmt)
-	  && !is_gimple_reg_type (racc->type))
+      if (should_scalarize_away_bitmap && !is_gimple_reg_type (racc->type))
 	{
-	  if (contains_vce_or_bfcref_p (rhs))
+	  bool type_changing_p = false;
+	  contains_vce_or_bfcref_p (rhs, &type_changing_p);
+
+	  if (type_changing_p || gimple_has_volatile_ops (stmt))
 	    bitmap_set_bit (cannot_scalarize_away_bitmap,
 			    DECL_UID (racc->base));
 	  else
@@ -2729,8 +2747,12 @@
 
 	      rchild->grp_hint = 1;
 	      new_acc->grp_hint |= new_acc->grp_read;
-	      if (rchild->first_child)
-		ret |= propagate_subaccesses_across_link (new_acc, rchild);
+	      if (rchild->first_child
+		  && propagate_subaccesses_across_link (new_acc, rchild))
+		{
+		  ret = 1;
+		  add_access_to_work_queue (new_acc);
+		}
 	    }
 	  else
 	    {
Index: gcc/tree-predcom.c
===================================================================
--- a/src/gcc/tree-predcom.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-predcom.c	(.../branches/gcc-8-branch)
@@ -1712,7 +1712,7 @@
 
   gcc_assert (!chain->has_max_use_after);
 
-  /* If loop iterates for unknown times or fewer times than chain->lenght,
+  /* If loop iterates for unknown times or fewer times than chain->length,
      we still need to setup root variable and propagate it with PHI node.  */
   tree niters = number_of_latch_executions (loop);
   if (TREE_CODE (niters) != INTEGER_CST
Index: gcc/tree-streamer-out.c
===================================================================
--- a/src/gcc/tree-streamer-out.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-streamer-out.c	(.../branches/gcc-8-branch)
@@ -212,7 +212,7 @@
       bp_pack_var_len_unsigned (bp, EH_LANDING_PAD_NR (expr));
     }
 
-  if (TREE_CODE (expr) == FIELD_DECL)
+  else if (TREE_CODE (expr) == FIELD_DECL)
     {
       bp_pack_value (bp, DECL_PACKED (expr), 1);
       bp_pack_value (bp, DECL_NONADDRESSABLE_P (expr), 1);
@@ -220,12 +220,15 @@
       bp_pack_value (bp, expr->decl_common.off_align, 8);
     }
 
-  if (VAR_P (expr))
+  else if (VAR_P (expr))
     {
       bp_pack_value (bp, DECL_HAS_DEBUG_EXPR_P (expr), 1);
       bp_pack_value (bp, DECL_NONLOCAL_FRAME (expr), 1);
     }
 
+  else if (TREE_CODE (expr) == PARM_DECL)
+    bp_pack_value (bp, DECL_HIDDEN_STRING_LENGTH (expr), 1);
+
   if (TREE_CODE (expr) == RESULT_DECL
       || TREE_CODE (expr) == PARM_DECL
       || VAR_P (expr))
Index: gcc/tree-ssa-copy.c
===================================================================
--- a/src/gcc/tree-ssa-copy.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-ssa-copy.c	(.../branches/gcc-8-branch)
@@ -545,13 +545,12 @@
 	      duplicate_ssa_name_ptr_info (copy_of[i].value,
 					   SSA_NAME_PTR_INFO (var));
 	      /* Points-to information is cfg insensitive,
-		 but alignment info might be cfg sensitive, if it
-		 e.g. is derived from VRP derived non-zero bits.
-		 So, do not copy alignment info if the two SSA_NAMEs
-		 aren't defined in the same basic block.  */
+		 but [E]VRP might record context sensitive alignment
+		 info, non-nullness, etc.  So reset context sensitive
+		 info if the two SSA_NAMEs aren't defined in the same
+		 basic block.  */
 	      if (var_bb != copy_of_bb)
-		mark_ptr_info_alignment_unknown
-				(SSA_NAME_PTR_INFO (copy_of[i].value));
+		reset_flow_sensitive_info (copy_of[i].value);
 	    }
 	  else if (!POINTER_TYPE_P (TREE_TYPE (var))
 		   && SSA_NAME_RANGE_INFO (var)
Index: gcc/varasm.c
===================================================================
--- a/src/gcc/varasm.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/varasm.c	(.../branches/gcc-8-branch)
@@ -1857,21 +1857,13 @@
       tree pp_val = TREE_VALUE (patchable_function_entry_attr);
       tree patchable_function_entry_value1 = TREE_VALUE (pp_val);
 
-      if (tree_fits_uhwi_p (patchable_function_entry_value1))
-	patch_area_size = tree_to_uhwi (patchable_function_entry_value1);
-      else
-	gcc_unreachable ();
-
+      patch_area_size = tree_to_uhwi (patchable_function_entry_value1);
       patch_area_entry = 0;
-      if (list_length (pp_val) > 1)
+      if (TREE_CHAIN (pp_val) != NULL_TREE)
 	{
-	  tree patchable_function_entry_value2 =
-	    TREE_VALUE (TREE_CHAIN (pp_val));
-
-	  if (tree_fits_uhwi_p (patchable_function_entry_value2))
-	    patch_area_entry = tree_to_uhwi (patchable_function_entry_value2);
-	  else
-	    gcc_unreachable ();
+	  tree patchable_function_entry_value2
+	    = TREE_VALUE (TREE_CHAIN (pp_val));
+	  patch_area_entry = tree_to_uhwi (patchable_function_entry_value2);
 	}
     }
 
@@ -1878,7 +1870,7 @@
   if (patch_area_entry > patch_area_size)
     {
       if (patch_area_size > 0)
-	warning (OPT_Wattributes, "Patchable function entry > size");
+	warning (OPT_Wattributes, "patchable function entry > size");
       patch_area_entry = 0;
     }
 
@@ -1898,7 +1890,8 @@
   /* And the area after the label.  Record it if we haven't done so yet.  */
   if (patch_area_size > patch_area_entry)
     targetm.asm_out.print_patchable_function_entry (asm_out_file,
-					     patch_area_size-patch_area_entry,
+						    patch_area_size
+						    - patch_area_entry,
 						    patch_area_entry == 0);
 
   if (lookup_attribute ("no_split_stack", DECL_ATTRIBUTES (decl)))
@@ -5292,7 +5285,7 @@
     {
       int this_time;
       int shift;
-      HOST_WIDE_INT value;
+      unsigned HOST_WIDE_INT value;
       HOST_WIDE_INT next_byte = next_offset / BITS_PER_UNIT;
       HOST_WIDE_INT next_bit = next_offset % BITS_PER_UNIT;
 
@@ -5324,15 +5317,13 @@
 	      this_time = end - shift + 1;
 	    }
 
-	  /* Now get the bits from the appropriate constant word.  */
-	  value = TREE_INT_CST_ELT (local->val, shift / HOST_BITS_PER_WIDE_INT);
-	  shift = shift & (HOST_BITS_PER_WIDE_INT - 1);
+	  /* Now get the bits we want to insert.  */
+	  value = wi::extract_uhwi (wi::to_widest (local->val),
+				    shift, this_time);
 
 	  /* Get the result.  This works only when:
 	     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */
-	  local->byte |= (((value >> shift)
-			   & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))
-			  << (BITS_PER_UNIT - this_time - next_bit));
+	  local->byte |= value << (BITS_PER_UNIT - this_time - next_bit);
 	}
       else
 	{
@@ -5349,15 +5340,13 @@
 	    this_time
 	      = HOST_BITS_PER_WIDE_INT - (shift & (HOST_BITS_PER_WIDE_INT - 1));
 
-	  /* Now get the bits from the appropriate constant word.  */
-	  value = TREE_INT_CST_ELT (local->val, shift / HOST_BITS_PER_WIDE_INT);
-	  shift = shift & (HOST_BITS_PER_WIDE_INT - 1);
+	  /* Now get the bits we want to insert.  */
+	  value = wi::extract_uhwi (wi::to_widest (local->val),
+				    shift, this_time);
 
 	  /* Get the result.  This works only when:
 	     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */
-	  local->byte |= (((value >> shift)
-			   & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))
-			  << next_bit);
+	  local->byte |= value << next_bit;
 	}
 
       next_offset += this_time;
Index: gcc/rtl.c
===================================================================
--- a/src/gcc/rtl.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/rtl.c	(.../branches/gcc-8-branch)
@@ -731,6 +731,8 @@
     return CALL_INSN;
   if (ANY_RETURN_P (x))
     return JUMP_INSN;
+  if (GET_CODE (x) == ASM_OPERANDS && ASM_OPERANDS_LABEL_VEC (x))
+    return JUMP_INSN;
   if (GET_CODE (x) == SET)
     {
       if (GET_CODE (SET_DEST (x)) == PC)
@@ -757,6 +759,9 @@
 	  return CALL_INSN;
       if (has_return_p)
 	return JUMP_INSN;
+      if (GET_CODE (XVECEXP (x, 0, 0)) == ASM_OPERANDS
+	  && ASM_OPERANDS_LABEL_VEC (XVECEXP (x, 0, 0)))
+	return JUMP_INSN;
     }
 #ifdef GENERATOR_FILE
   if (GET_CODE (x) == MATCH_OPERAND
Index: gcc/rtl.h
===================================================================
--- a/src/gcc/rtl.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/rtl.h	(.../branches/gcc-8-branch)
@@ -4355,6 +4355,7 @@
 {
   switch (GET_CODE (x))
     {
+    case CONST_INT:
     case ROTATE:
     case ROTATERT:
     case SIGN_EXTRACT:
Index: gcc/dwarf2cfi.c
===================================================================
--- a/src/gcc/dwarf2cfi.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/dwarf2cfi.c	(.../branches/gcc-8-branch)
@@ -1762,7 +1762,7 @@
 
 	  /* Rule 6 */
 	case CONST_INT:
-	case POLY_INT_CST:
+	case CONST_POLY_INT:
 	  cur_trace->cfa_temp.reg = dwf_regno (dest);
 	  cur_trace->cfa_temp.offset = rtx_to_poly_int64 (src);
 	  break;
Index: gcc/tree-inline.c
===================================================================
--- a/src/gcc/tree-inline.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-inline.c	(.../branches/gcc-8-branch)
@@ -578,6 +578,92 @@
   return new_tree;
 }
 
+/* Helper function for remap_type_2, called through walk_tree.  */
+
+static tree
+remap_type_3 (tree *tp, int *walk_subtrees, void *data)
+{
+  copy_body_data *id = (copy_body_data *) data;
+
+  if (TYPE_P (*tp))
+    *walk_subtrees = 0;
+
+  else if (DECL_P (*tp) && remap_decl (*tp, id) != *tp)
+    return *tp;
+
+  return NULL_TREE;
+}
+
+/* Return true if TYPE needs to be remapped because remap_decl on any
+   needed embedded decl returns something other than that decl.  */
+
+static bool
+remap_type_2 (tree type, copy_body_data *id)
+{
+  tree t;
+
+#define RETURN_TRUE_IF_VAR(T) \
+  do								\
+    {								\
+      tree _t = (T);						\
+      if (_t)							\
+	{							\
+	  if (DECL_P (_t) && remap_decl (_t, id) != _t)		\
+	    return true;					\
+	  if (!TYPE_SIZES_GIMPLIFIED (type)			\
+	      && walk_tree (&_t, remap_type_3, id, NULL))	\
+	    return true;					\
+	}							\
+    }								\
+  while (0)
+
+  switch (TREE_CODE (type))
+    {
+    case POINTER_TYPE:
+    case REFERENCE_TYPE:
+    case FUNCTION_TYPE:
+    case METHOD_TYPE:
+      return remap_type_2 (TREE_TYPE (type), id);
+
+    case INTEGER_TYPE:
+    case REAL_TYPE:
+    case FIXED_POINT_TYPE:
+    case ENUMERAL_TYPE:
+    case BOOLEAN_TYPE:
+      RETURN_TRUE_IF_VAR (TYPE_MIN_VALUE (type));
+      RETURN_TRUE_IF_VAR (TYPE_MAX_VALUE (type));
+      return false;
+
+    case ARRAY_TYPE:
+      if (remap_type_2 (TREE_TYPE (type), id)
+	  || (TYPE_DOMAIN (type) && remap_type_2 (TYPE_DOMAIN (type), id)))
+	return true;
+      break;
+
+    case RECORD_TYPE:
+    case UNION_TYPE:
+    case QUAL_UNION_TYPE:
+      for (t = TYPE_FIELDS (type); t; t = DECL_CHAIN (t))
+	if (TREE_CODE (t) == FIELD_DECL)
+	  {
+	    RETURN_TRUE_IF_VAR (DECL_FIELD_OFFSET (t));
+	    RETURN_TRUE_IF_VAR (DECL_SIZE (t));
+	    RETURN_TRUE_IF_VAR (DECL_SIZE_UNIT (t));
+	    if (TREE_CODE (type) == QUAL_UNION_TYPE)
+	      RETURN_TRUE_IF_VAR (DECL_QUALIFIER (t));
+	  }
+      break;
+
+    default:
+      return false;
+    }
+
+  RETURN_TRUE_IF_VAR (TYPE_SIZE (type));
+  RETURN_TRUE_IF_VAR (TYPE_SIZE_UNIT (type));
+  return false;
+#undef RETURN_TRUE_IF_VAR
+}
+
 tree
 remap_type (tree type, copy_body_data *id)
 {
@@ -593,7 +679,10 @@
     return *node;
 
   /* The type only needs remapping if it's variably modified.  */
-  if (! variably_modified_type_p (type, id->src_fn))
+  if (! variably_modified_type_p (type, id->src_fn)
+      /* Don't remap if copy_decl method doesn't always return a new
+	 decl and for all embedded decls returns the passed in decl.  */
+      || (id->dont_remap_vla_if_no_change && !remap_type_2 (type, id)))
     {
       insert_decl_map (id, type, type);
       return type;
@@ -5539,6 +5628,10 @@
   if (CODE_CONTAINS_STRUCT (TREE_CODE (copy), TS_DECL_WRTL)
       && !TREE_STATIC (copy) && !DECL_EXTERNAL (copy))
     SET_DECL_RTL (copy, 0);
+  /* For vector typed decls make sure to update DECL_MODE according
+     to the new function context.  */
+  if (VECTOR_TYPE_P (TREE_TYPE (copy)))
+    SET_DECL_MODE (copy, TYPE_MODE (TREE_TYPE (copy)));
 
   /* These args would always appear unused, if not for this.  */
   TREE_USED (copy) = 1;
Index: gcc/tree-inline.h
===================================================================
--- a/src/gcc/tree-inline.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-inline.h	(.../branches/gcc-8-branch)
@@ -119,6 +119,13 @@
   /* > 0 if we are remapping a type currently.  */
   int remapping_type_depth;
 
+  /* Usually copy_decl callback always creates new decls, in that case
+     we want to remap all variably_modified_type_p types.  If this flag
+     is set, remap_type will do further checks to see if remap_decl
+     of any decls mentioned in the type will remap to anything but itself
+     and only in that case will actually remap the type.  */
+  bool dont_remap_vla_if_no_change;
+
   /* A function to be called when duplicating BLOCK nodes.  */
   void (*transform_lang_insert_block) (tree);
 
Index: gcc/omp-simd-clone.c
===================================================================
--- a/src/gcc/omp-simd-clone.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/omp-simd-clone.c	(.../branches/gcc-8-branch)
@@ -868,6 +868,18 @@
 
   if (tp != orig_tp)
     {
+      if (gimple_code (info->stmt) == GIMPLE_PHI
+	  && cand
+	  && TREE_CODE (*orig_tp) == ADDR_EXPR
+	  && TREE_CODE (TREE_OPERAND (*orig_tp, 0)) == PARM_DECL
+	  && cand->alias_ptr_type)
+	{
+	  gcc_assert (TREE_CODE (cand->alias_ptr_type) == SSA_NAME);
+	  *orig_tp = cand->alias_ptr_type;
+	  info->modified = true;
+	  return NULL_TREE;
+	}
+
       repl = build_fold_addr_expr (repl);
       gimple *stmt;
       if (is_gimple_debug (info->stmt))
@@ -884,7 +896,18 @@
 	  stmt = gimple_build_assign (make_ssa_name (TREE_TYPE (repl)), repl);
 	  repl = gimple_assign_lhs (stmt);
 	}
-      gimple_stmt_iterator gsi = gsi_for_stmt (info->stmt);
+      gimple_stmt_iterator gsi;
+      if (gimple_code (info->stmt) == GIMPLE_PHI)
+	{
+	  gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));
+	  /* Cache SSA_NAME for next time.  */
+	  if (cand
+	      && TREE_CODE (*orig_tp) == ADDR_EXPR
+	      && TREE_CODE (TREE_OPERAND (*orig_tp, 0)) == PARM_DECL)
+	    cand->alias_ptr_type = repl;
+	}
+      else
+	gsi = gsi_for_stmt (info->stmt);
       gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);
       *orig_tp = repl;
     }
@@ -985,6 +1008,31 @@
     {
       gimple_stmt_iterator gsi;
 
+      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+	{
+	  gphi *phi = as_a <gphi *> (gsi_stmt (gsi));
+	  int i, n = gimple_phi_num_args (phi);
+	  info.stmt = phi;
+	  struct walk_stmt_info wi;
+	  memset (&wi, 0, sizeof (wi));
+	  info.modified = false;
+	  wi.info = &info;
+	  for (i = 0; i < n; ++i)
+	    {
+	      int walk_subtrees = 1;
+	      tree arg = gimple_phi_arg_def (phi, i);
+	      tree op = arg;
+	      ipa_simd_modify_stmt_ops (&op, &walk_subtrees, &wi);
+	      if (op != arg)
+		{
+		  SET_PHI_ARG_DEF (phi, i, op);
+		  gcc_assert (TREE_CODE (op) == SSA_NAME);
+		  if (gimple_phi_arg_edge (phi, i)->flags & EDGE_ABNORMAL)
+		    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op) = 1;
+		}
+	    }
+	}
+
       gsi = gsi_start_bb (bb);
       while (!gsi_end_p (gsi))
 	{
Index: gcc/tree-streamer-in.c
===================================================================
--- a/src/gcc/tree-streamer-in.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-streamer-in.c	(.../branches/gcc-8-branch)
@@ -252,7 +252,7 @@
       LABEL_DECL_UID (expr) = -1;
     }
 
-  if (TREE_CODE (expr) == FIELD_DECL)
+  else if (TREE_CODE (expr) == FIELD_DECL)
     {
       DECL_PACKED (expr) = (unsigned) bp_unpack_value (bp, 1);
       DECL_NONADDRESSABLE_P (expr) = (unsigned) bp_unpack_value (bp, 1);
@@ -260,12 +260,15 @@
       expr->decl_common.off_align = bp_unpack_value (bp, 8);
     }
 
-  if (VAR_P (expr))
+  else if (VAR_P (expr))
     {
       DECL_HAS_DEBUG_EXPR_P (expr) = (unsigned) bp_unpack_value (bp, 1);
       DECL_NONLOCAL_FRAME (expr) = (unsigned) bp_unpack_value (bp, 1);
     }
 
+  else if (TREE_CODE (expr) == PARM_DECL)
+    DECL_HIDDEN_STRING_LENGTH (expr) = (unsigned) bp_unpack_value (bp, 1);
+
   if (TREE_CODE (expr) == RESULT_DECL
       || TREE_CODE (expr) == PARM_DECL
       || VAR_P (expr))
Index: gcc/vr-values.c
===================================================================
--- a/src/gcc/vr-values.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/vr-values.c	(.../branches/gcc-8-branch)
@@ -211,8 +211,13 @@
 	 the same.  We may not have is_new when transitioning to
 	 UNDEFINED.  If old_vr->type is VARYING, we shouldn't be
 	 called.  */
-      if (new_vr->type == VR_UNDEFINED)
+      if (old_vr->type == VR_VARYING)
 	{
+	  set_value_range_to_varying (new_vr);
+	  is_new = false;
+	}
+      else if (new_vr->type == VR_UNDEFINED)
+	{
 	  BITMAP_FREE (new_vr->equiv);
 	  set_value_range_to_varying (old_vr);
 	  set_value_range_to_varying (new_vr);
Index: gcc/resource.c
===================================================================
--- a/src/gcc/resource.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/resource.c	(.../branches/gcc-8-branch)
@@ -969,9 +969,13 @@
     {
       regset regs_live = DF_LR_IN (BASIC_BLOCK_FOR_FN (cfun, b));
       rtx_insn *start_insn, *stop_insn;
+      df_ref def;
 
       /* Compute hard regs live at start of block.  */
       REG_SET_TO_HARD_REG_SET (current_live_regs, regs_live);
+      FOR_EACH_ARTIFICIAL_DEF (def, b)
+	if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)
+	  SET_HARD_REG_BIT (current_live_regs, DF_REF_REGNO (def));
 
       /* Get starting and ending insn, handling the case where each might
 	 be a SEQUENCE.  */
Index: gcc/config.gcc
===================================================================
--- a/src/gcc/config.gcc	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config.gcc	(.../branches/gcc-8-branch)
@@ -4676,8 +4676,11 @@
 		;;
 	i[34567]86-*-dragonfly* | x86_64-*-dragonfly*)
 		;;
-	i[34567]86-*-freebsd* | x86_64-*-freebsd*)
+	i[34567]86-*-freebsd*)
 		;;
+	x86_64-*-freebsd*)
+		tmake_file="${tmake_file} i386/t-freebsd64"
+		;;
 	ia64*-*-linux*)
 		;;
 
Index: gcc/opts-global.c
===================================================================
--- a/src/gcc/opts-global.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/opts-global.c	(.../branches/gcc-8-branch)
@@ -103,10 +103,14 @@
 	   text, bad_lang);
   else if (lang_mask == CL_DRIVER)
     gcc_unreachable ();
-  else
+  else if (ok_langs[0] != '\0')
     /* Eventually this should become a hard error IMO.  */
     warning (0, "command line option %qs is valid for %s but not for %s",
 	     text, ok_langs, bad_lang);
+  else
+    /* Happens for -Werror=warning_name.  */
+    warning (0, "%<-Werror=%> argument %qs is not valid for %s",
+	     text, bad_lang);
 
   free (ok_langs);
   free (bad_lang);
Index: gcc/tree-ssa-structalias.c
===================================================================
--- a/src/gcc/tree-ssa-structalias.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-ssa-structalias.c	(.../branches/gcc-8-branch)
@@ -7552,7 +7552,10 @@
 	    }
 	  if (used)
 	    {
-	      bitmap_set_bit (rvars, restrict_var->id);
+	      /* Add all subvars to the set of restrict pointed-to set. */
+	      for (unsigned sv = restrict_var->head; sv != 0;
+		   sv = get_varinfo (sv)->next)
+		bitmap_set_bit (rvars, sv);
 	      varinfo_t escaped = get_varinfo (find (escaped_id));
 	      if (bitmap_bit_p (escaped->solution, restrict_var->id))
 		escaped_p = true;
Index: gcc/tree-core.h
===================================================================
--- a/src/gcc/tree-core.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-core.h	(.../branches/gcc-8-branch)
@@ -1644,6 +1644,7 @@
   /* In a VAR_DECL and PARM_DECL, this is DECL_READ_P.  */
   unsigned decl_read_flag : 1;
   /* In a VAR_DECL or RESULT_DECL, this is DECL_NONSHAREABLE.  */
+  /* In a PARM_DECL, this is DECL_HIDDEN_STRING_LENGTH.  */
   unsigned decl_nonshareable_flag : 1;
 
   /* DECL_OFFSET_ALIGN, used only for FIELD_DECLs.  */
Index: gcc/tree-cfg.c
===================================================================
--- a/src/gcc/tree-cfg.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-cfg.c	(.../branches/gcc-8-branch)
@@ -2307,7 +2307,7 @@
 		  new_bb = single_succ (new_bb);
 		  gcc_assert (new_bb != bb);
 		}
-	      new_gsi = gsi_start_bb (new_bb);
+	      new_gsi = gsi_after_labels (new_bb);
 	      gsi_remove (&i, false);
 	      gsi_insert_before (&new_gsi, stmt, GSI_NEW_STMT);
 	    }
Index: gcc/passes.c
===================================================================
--- a/src/gcc/passes.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/passes.c	(.../branches/gcc-8-branch)
@@ -1944,7 +1944,7 @@
   /* Always cleanup the CFG before trying to update SSA.  */
   if (flags & TODO_cleanup_cfg)
     {
-      cleanup_tree_cfg ();
+      cleanup_tree_cfg (flags & TODO_update_ssa_any);
 
       /* When cleanup_tree_cfg merges consecutive blocks, it may
 	 perform some simplistic propagation when removing single
Index: gcc/tree-ssa-reassoc.c
===================================================================
--- a/src/gcc/tree-ssa-reassoc.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-ssa-reassoc.c	(.../branches/gcc-8-branch)
@@ -2143,7 +2143,8 @@
 	  exp_type = boolean_type_node;
 	}
 
-      if (TREE_CODE (arg0) != SSA_NAME)
+      if (TREE_CODE (arg0) != SSA_NAME
+	  || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (arg0))
 	break;
       loc = gimple_location (stmt);
       switch (code)
Index: gcc/config/nvptx/nvptx.c
===================================================================
--- a/src/gcc/config/nvptx/nvptx.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/nvptx/nvptx.c	(.../branches/gcc-8-branch)
@@ -1377,7 +1377,7 @@
       fputs (";\n", file);
       if (!CONST_INT_P (size) || UINTVAL (align) > GET_MODE_SIZE (DImode))
 	fprintf (file,
-		 "\t\tand.u%d %%r%d, %%r%d, -" HOST_WIDE_INT_PRINT_DEC ";\n",
+		 "\t\tand.b%d %%r%d, %%r%d, -" HOST_WIDE_INT_PRINT_DEC ";\n",
 		 bits, regno, regno, UINTVAL (align));
     }
   if (cfun->machine->has_softstack)
Index: gcc/config/alpha/alpha.h
===================================================================
--- a/src/gcc/config/alpha/alpha.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/alpha/alpha.h	(.../branches/gcc-8-branch)
@@ -678,7 +678,7 @@
 
 #define CONSTANT_ADDRESS_P(X)   \
   (CONST_INT_P (X)		\
-   && (unsigned HOST_WIDE_INT) (INTVAL (X) + 0x8000) < 0x10000)
+   && (UINTVAL (X) + 0x8000) < 0x10000)
 
 /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx
    and check its validity for a certain class.
Index: gcc/config/s390/s390-c.c
===================================================================
--- a/src/gcc/config/s390/s390-c.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/s390/s390-c.c	(.../branches/gcc-8-branch)
@@ -477,16 +477,30 @@
     case S390_OVERLOADED_BUILTIN_s390_vec_xl:
     case S390_OVERLOADED_BUILTIN_s390_vec_xld2:
     case S390_OVERLOADED_BUILTIN_s390_vec_xlw4:
-      return build2 (MEM_REF, return_type,
-		     fold_build_pointer_plus ((*arglist)[1], (*arglist)[0]),
-		     build_int_cst (TREE_TYPE ((*arglist)[1]), 0));
+      {
+	/* Build a vector type with the alignment of the source
+	   location in order to enable correct alignment hints to be
+	   generated for vl.  */
+	tree mem_type = build_aligned_type (return_type,
+					    TYPE_ALIGN (TREE_TYPE (TREE_TYPE ((*arglist)[1]))));
+	return build2 (MEM_REF, mem_type,
+		       fold_build_pointer_plus ((*arglist)[1], (*arglist)[0]),
+		       build_int_cst (TREE_TYPE ((*arglist)[1]), 0));
+      }
     case S390_OVERLOADED_BUILTIN_s390_vec_xst:
     case S390_OVERLOADED_BUILTIN_s390_vec_xstd2:
     case S390_OVERLOADED_BUILTIN_s390_vec_xstw4:
-      return build2 (MODIFY_EXPR, TREE_TYPE((*arglist)[0]),
-		     build1 (INDIRECT_REF, TREE_TYPE((*arglist)[0]),
-			     fold_build_pointer_plus ((*arglist)[2], (*arglist)[1])),
-		     (*arglist)[0]);
+      {
+	/* Build a vector type with the alignment of the target
+	   location in order to enable correct alignment hints to be
+	   generated for vst.  */
+	tree mem_type = build_aligned_type (TREE_TYPE((*arglist)[0]),
+					    TYPE_ALIGN (TREE_TYPE (TREE_TYPE ((*arglist)[2]))));
+	return build2 (MODIFY_EXPR, mem_type,
+		       build1 (INDIRECT_REF, mem_type,
+			       fold_build_pointer_plus ((*arglist)[2], (*arglist)[1])),
+		       (*arglist)[0]);
+      }
     case S390_OVERLOADED_BUILTIN_s390_vec_load_pair:
       return build_constructor_va (return_type, 2,
 				   NULL_TREE, (*arglist)[0],
Index: gcc/config/s390/s390-builtin-types.def
===================================================================
--- a/src/gcc/config/s390/s390-builtin-types.def	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/s390/s390-builtin-types.def	(.../branches/gcc-8-branch)
@@ -260,6 +260,7 @@
 DEF_FN_TYPE_2 (BT_FN_V4SF_V4SF_UCHAR, BT_V4SF, BT_V4SF, BT_UCHAR)
 DEF_FN_TYPE_2 (BT_FN_V4SF_V4SF_V4SF, BT_V4SF, BT_V4SF, BT_V4SF)
 DEF_FN_TYPE_2 (BT_FN_V4SI_BV4SI_V4SI, BT_V4SI, BT_BV4SI, BT_V4SI)
+DEF_FN_TYPE_2 (BT_FN_V4SI_INT_VOIDCONSTPTR, BT_V4SI, BT_INT, BT_VOIDCONSTPTR)
 DEF_FN_TYPE_2 (BT_FN_V4SI_INT_VOIDPTR, BT_V4SI, BT_INT, BT_VOIDPTR)
 DEF_FN_TYPE_2 (BT_FN_V4SI_UV4SI_UV4SI, BT_V4SI, BT_UV4SI, BT_UV4SI)
 DEF_FN_TYPE_2 (BT_FN_V4SI_V2DI_V2DI, BT_V4SI, BT_V2DI, BT_V2DI)
@@ -492,6 +493,7 @@
 DEF_OV_TYPE (BT_OV_UV16QI_BV16QI_BV16QI, BT_UV16QI, BT_BV16QI, BT_BV16QI)
 DEF_OV_TYPE (BT_OV_UV16QI_BV16QI_BV16QI_INTPTR, BT_UV16QI, BT_BV16QI, BT_BV16QI, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_UV16QI_BV16QI_UV16QI, BT_UV16QI, BT_BV16QI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_UV16QI_LONG_UCHARCONSTPTR, BT_UV16QI, BT_LONG, BT_UCHARCONSTPTR)
 DEF_OV_TYPE (BT_OV_UV16QI_LONG_UCHARPTR, BT_UV16QI, BT_LONG, BT_UCHARPTR)
 DEF_OV_TYPE (BT_OV_UV16QI_UCHAR, BT_UV16QI, BT_UCHAR)
 DEF_OV_TYPE (BT_OV_UV16QI_UCHARCONSTPTR, BT_UV16QI, BT_UCHARCONSTPTR)
@@ -523,6 +525,7 @@
 DEF_OV_TYPE (BT_OV_UV16QI_V16QI, BT_UV16QI, BT_V16QI)
 DEF_OV_TYPE (BT_OV_UV16QI_V8HI_V8HI, BT_UV16QI, BT_V8HI, BT_V8HI)
 DEF_OV_TYPE (BT_OV_UV2DI_BV2DI_UV2DI, BT_UV2DI, BT_BV2DI, BT_UV2DI)
+DEF_OV_TYPE (BT_OV_UV2DI_LONG_ULONGLONGCONSTPTR, BT_UV2DI, BT_LONG, BT_ULONGLONGCONSTPTR)
 DEF_OV_TYPE (BT_OV_UV2DI_LONG_ULONGLONGPTR, BT_UV2DI, BT_LONG, BT_ULONGLONGPTR)
 DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONG, BT_UV2DI, BT_ULONGLONG)
 DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONGCONSTPTR, BT_UV2DI, BT_ULONGLONGCONSTPTR)
@@ -556,6 +559,8 @@
 DEF_OV_TYPE (BT_OV_UV4SI_BV4SI_BV4SI, BT_UV4SI, BT_BV4SI, BT_BV4SI)
 DEF_OV_TYPE (BT_OV_UV4SI_BV4SI_BV4SI_INTPTR, BT_UV4SI, BT_BV4SI, BT_BV4SI, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_UV4SI_BV4SI_UV4SI, BT_UV4SI, BT_BV4SI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_UV4SI_LONG_FLTPTR, BT_UV4SI, BT_LONG, BT_FLTPTR)
+DEF_OV_TYPE (BT_OV_UV4SI_LONG_UINTCONSTPTR, BT_UV4SI, BT_LONG, BT_UINTCONSTPTR)
 DEF_OV_TYPE (BT_OV_UV4SI_LONG_UINTPTR, BT_UV4SI, BT_LONG, BT_UINTPTR)
 DEF_OV_TYPE (BT_OV_UV4SI_UINT, BT_UV4SI, BT_UINT)
 DEF_OV_TYPE (BT_OV_UV4SI_UINTCONSTPTR, BT_UV4SI, BT_UINTCONSTPTR)
@@ -593,6 +598,7 @@
 DEF_OV_TYPE (BT_OV_UV8HI_BV8HI_BV8HI, BT_UV8HI, BT_BV8HI, BT_BV8HI)
 DEF_OV_TYPE (BT_OV_UV8HI_BV8HI_BV8HI_INTPTR, BT_UV8HI, BT_BV8HI, BT_BV8HI, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_UV8HI_BV8HI_UV8HI, BT_UV8HI, BT_BV8HI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_UV8HI_LONG_USHORTCONSTPTR, BT_UV8HI, BT_LONG, BT_USHORTCONSTPTR)
 DEF_OV_TYPE (BT_OV_UV8HI_LONG_USHORTPTR, BT_UV8HI, BT_LONG, BT_USHORTPTR)
 DEF_OV_TYPE (BT_OV_UV8HI_USHORT, BT_UV8HI, BT_USHORT)
 DEF_OV_TYPE (BT_OV_UV8HI_USHORTCONSTPTR, BT_UV8HI, BT_USHORTCONSTPTR)
@@ -626,6 +632,7 @@
 DEF_OV_TYPE (BT_OV_UV8HI_V4SI_V4SI, BT_UV8HI, BT_V4SI, BT_V4SI)
 DEF_OV_TYPE (BT_OV_UV8HI_V8HI, BT_UV8HI, BT_V8HI)
 DEF_OV_TYPE (BT_OV_V16QI_BV16QI_V16QI, BT_V16QI, BT_BV16QI, BT_V16QI)
+DEF_OV_TYPE (BT_OV_V16QI_LONG_SCHARCONSTPTR, BT_V16QI, BT_LONG, BT_SCHARCONSTPTR)
 DEF_OV_TYPE (BT_OV_V16QI_LONG_SCHARPTR, BT_V16QI, BT_LONG, BT_SCHARPTR)
 DEF_OV_TYPE (BT_OV_V16QI_SCHAR, BT_V16QI, BT_SCHAR)
 DEF_OV_TYPE (BT_OV_V16QI_SCHARCONSTPTR, BT_V16QI, BT_SCHARCONSTPTR)
@@ -660,6 +667,7 @@
 DEF_OV_TYPE (BT_OV_V2DF_DBLCONSTPTR_USHORT, BT_V2DF, BT_DBLCONSTPTR, BT_USHORT)
 DEF_OV_TYPE (BT_OV_V2DF_DBL_INT, BT_V2DF, BT_DBL, BT_INT)
 DEF_OV_TYPE (BT_OV_V2DF_DBL_V2DF_INT, BT_V2DF, BT_DBL, BT_V2DF, BT_INT)
+DEF_OV_TYPE (BT_OV_V2DF_LONG_DBLCONSTPTR, BT_V2DF, BT_LONG, BT_DBLCONSTPTR)
 DEF_OV_TYPE (BT_OV_V2DF_LONG_DBLPTR, BT_V2DF, BT_LONG, BT_DBLPTR)
 DEF_OV_TYPE (BT_OV_V2DF_UV2DI, BT_V2DF, BT_UV2DI)
 DEF_OV_TYPE (BT_OV_V2DF_UV2DI_INT, BT_V2DF, BT_UV2DI, BT_INT)
@@ -687,6 +695,7 @@
 DEF_OV_TYPE (BT_OV_V2DI_LONGLONG_INT, BT_V2DI, BT_LONGLONG, BT_INT)
 DEF_OV_TYPE (BT_OV_V2DI_LONGLONG_LONGLONG, BT_V2DI, BT_LONGLONG, BT_LONGLONG)
 DEF_OV_TYPE (BT_OV_V2DI_LONGLONG_V2DI_INT, BT_V2DI, BT_LONGLONG, BT_V2DI, BT_INT)
+DEF_OV_TYPE (BT_OV_V2DI_LONG_LONGLONGCONSTPTR, BT_V2DI, BT_LONG, BT_LONGLONGCONSTPTR)
 DEF_OV_TYPE (BT_OV_V2DI_LONG_LONGLONGPTR, BT_V2DI, BT_LONG, BT_LONGLONGPTR)
 DEF_OV_TYPE (BT_OV_V2DI_V16QI, BT_V2DI, BT_V16QI)
 DEF_OV_TYPE (BT_OV_V2DI_V2DI, BT_V2DI, BT_V2DI)
@@ -716,7 +725,7 @@
 DEF_OV_TYPE (BT_OV_V4SF_FLTCONSTPTR_USHORT, BT_V4SF, BT_FLTCONSTPTR, BT_USHORT)
 DEF_OV_TYPE (BT_OV_V4SF_FLT_INT, BT_V4SF, BT_FLT, BT_INT)
 DEF_OV_TYPE (BT_OV_V4SF_FLT_V4SF_INT, BT_V4SF, BT_FLT, BT_V4SF, BT_INT)
-DEF_OV_TYPE (BT_OV_V4SF_LONG_FLTPTR, BT_V4SF, BT_LONG, BT_FLTPTR)
+DEF_OV_TYPE (BT_OV_V4SF_LONG_FLTCONSTPTR, BT_V4SF, BT_LONG, BT_FLTCONSTPTR)
 DEF_OV_TYPE (BT_OV_V4SF_V4SF, BT_V4SF, BT_V4SF)
 DEF_OV_TYPE (BT_OV_V4SF_V4SF_BV4SI, BT_V4SF, BT_V4SF, BT_BV4SI)
 DEF_OV_TYPE (BT_OV_V4SF_V4SF_UCHAR, BT_V4SF, BT_V4SF, BT_UCHAR)
@@ -737,6 +746,7 @@
 DEF_OV_TYPE (BT_OV_V4SI_INTCONSTPTR_USHORT, BT_V4SI, BT_INTCONSTPTR, BT_USHORT)
 DEF_OV_TYPE (BT_OV_V4SI_INT_INT, BT_V4SI, BT_INT, BT_INT)
 DEF_OV_TYPE (BT_OV_V4SI_INT_V4SI_INT, BT_V4SI, BT_INT, BT_V4SI, BT_INT)
+DEF_OV_TYPE (BT_OV_V4SI_LONG_INTCONSTPTR, BT_V4SI, BT_LONG, BT_INTCONSTPTR)
 DEF_OV_TYPE (BT_OV_V4SI_LONG_INTPTR, BT_V4SI, BT_LONG, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_V4SI_UV4SI_V4SI_V4SI, BT_V4SI, BT_UV4SI, BT_V4SI, BT_V4SI)
 DEF_OV_TYPE (BT_OV_V4SI_V2DI_V2DI, BT_V4SI, BT_V2DI, BT_V2DI)
@@ -764,6 +774,7 @@
 DEF_OV_TYPE (BT_OV_V4SI_V8HI_V8HI, BT_V4SI, BT_V8HI, BT_V8HI)
 DEF_OV_TYPE (BT_OV_V4SI_V8HI_V8HI_V4SI, BT_V4SI, BT_V8HI, BT_V8HI, BT_V4SI)
 DEF_OV_TYPE (BT_OV_V8HI_BV8HI_V8HI, BT_V8HI, BT_BV8HI, BT_V8HI)
+DEF_OV_TYPE (BT_OV_V8HI_LONG_SHORTCONSTPTR, BT_V8HI, BT_LONG, BT_SHORTCONSTPTR)
 DEF_OV_TYPE (BT_OV_V8HI_LONG_SHORTPTR, BT_V8HI, BT_LONG, BT_SHORTPTR)
 DEF_OV_TYPE (BT_OV_V8HI_SHORT, BT_V8HI, BT_SHORT)
 DEF_OV_TYPE (BT_OV_V8HI_SHORTCONSTPTR, BT_V8HI, BT_SHORTCONSTPTR)
@@ -802,6 +813,7 @@
 DEF_OV_TYPE (BT_OV_VOID_UV2DI_LONG_ULONGLONGPTR, BT_VOID, BT_UV2DI, BT_LONG, BT_ULONGLONGPTR)
 DEF_OV_TYPE (BT_OV_VOID_UV2DI_ULONGLONGPTR_UINT, BT_VOID, BT_UV2DI, BT_ULONGLONGPTR, BT_UINT)
 DEF_OV_TYPE (BT_OV_VOID_UV2DI_UV2DI_ULONGLONGPTR_ULONGLONG, BT_VOID, BT_UV2DI, BT_UV2DI, BT_ULONGLONGPTR, BT_ULONGLONG)
+DEF_OV_TYPE (BT_OV_VOID_UV4SI_LONG_FLTPTR, BT_VOID, BT_UV4SI, BT_LONG, BT_FLTPTR)
 DEF_OV_TYPE (BT_OV_VOID_UV4SI_LONG_UINTPTR, BT_VOID, BT_UV4SI, BT_LONG, BT_UINTPTR)
 DEF_OV_TYPE (BT_OV_VOID_UV4SI_UINTPTR_UINT, BT_VOID, BT_UV4SI, BT_UINTPTR, BT_UINT)
 DEF_OV_TYPE (BT_OV_VOID_UV4SI_UV4SI_UINTPTR_ULONGLONG, BT_VOID, BT_UV4SI, BT_UV4SI, BT_UINTPTR, BT_ULONGLONG)
Index: gcc/config/s390/vector.md
===================================================================
--- a/src/gcc/config/s390/vector.md	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/s390/vector.md	(.../branches/gcc-8-branch)
@@ -944,7 +944,7 @@
 	(VEC_SHIFTS:VI (match_operand:VI 1 "register_operand"   "v")
 		       (match_operand:SI 2 "nonmemory_operand" "an")))]
   "TARGET_VX"
-  "<vec_shifts_mnem><bhfgq>\t%v0,%v1,%Y2"
+  "<vec_shifts_mnem><bhfgq>\t%v0,%v1,<addr_style_op_ops>"
   [(set_attr "op_type" "VRS")])
 
 ; Shift each element by corresponding vector element
Index: gcc/config/s390/s390.c
===================================================================
--- a/src/gcc/config/s390/s390.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/s390/s390.c	(.../branches/gcc-8-branch)
@@ -937,6 +937,8 @@
 	  continue;
 	}
 
+      /* A memory operand is rejected by the memory_operand predicate.
+	 Try making the address legal by copying it into a register.  */
       if (MEM_P (op[arity])
 	  && insn_op->predicate == memory_operand
 	  && (GET_MODE (XEXP (op[arity], 0)) == Pmode
@@ -960,10 +962,14 @@
 	{
 	  op[arity] = tmp_rtx;
 	}
-      else if (GET_MODE (op[arity]) == insn_op->mode
-	       || GET_MODE (op[arity]) == VOIDmode
-	       || (insn_op->predicate == address_operand
-		   && GET_MODE (op[arity]) == Pmode))
+
+      /* The predicate rejects the operand although the mode is fine.
+	 Copy the operand to register.  */
+      if (!insn_op->predicate (op[arity], insn_op->mode)
+	  && (GET_MODE (op[arity]) == insn_op->mode
+	      || GET_MODE (op[arity]) == VOIDmode
+	      || (insn_op->predicate == address_operand
+		  && GET_MODE (op[arity]) == Pmode)))
 	{
 	  /* An address_operand usually has VOIDmode in the expander
 	     so we cannot use this.  */
@@ -10106,6 +10112,21 @@
   s390_register_info_stdarg_gpr ();
 }
 
+/* Return true if REGNO is a global register, but not one
+   of the special ones that need to be saved/restored in anyway.  */
+
+static inline bool
+global_not_special_regno_p (int regno)
+{
+  return (global_regs[regno]
+	  /* These registers are special and need to be
+	     restored in any case.  */
+	  && !(regno == STACK_POINTER_REGNUM
+	       || regno == RETURN_REGNUM
+	       || regno == BASE_REGNUM
+	       || (flag_pic && regno == (int)PIC_OFFSET_TABLE_REGNUM)));
+}
+
 /* This function is called by s390_optimize_prologue in order to get
    rid of unnecessary GPR save/restore instructions.  The register info
    for the GPRs is re-computed and the ranges are re-calculated.  */
@@ -10121,8 +10142,10 @@
 
   s390_regs_ever_clobbered (clobbered_regs);
 
+  /* Global registers do not need to be saved and restored unless it
+     is one of our special regs.  (r12, r13, r14, or r15).  */
   for (i = 0; i < 32; i++)
-    clobbered_regs[i] = clobbered_regs[i] && !global_regs[i];
+    clobbered_regs[i] = clobbered_regs[i] && !global_not_special_regno_p (i);
 
   /* There is still special treatment needed for cases invisible to
      s390_regs_ever_clobbered.  */
@@ -10876,21 +10899,6 @@
   return emit_move_insn (gen_rtx_REG (DFmode, regnum), addr);
 }
 
-/* Return true if REGNO is a global register, but not one
-   of the special ones that need to be saved/restored in anyway.  */
-
-static inline bool
-global_not_special_regno_p (int regno)
-{
-  return (global_regs[regno]
-	  /* These registers are special and need to be
-	     restored in any case.  */
-	  && !(regno == STACK_POINTER_REGNUM
-	       || regno == RETURN_REGNUM
-	       || regno == BASE_REGNUM
-	       || (flag_pic && regno == (int)PIC_OFFSET_TABLE_REGNUM)));
-}
-
 /* Generate insn to save registers FIRST to LAST into
    the register save area located at offset OFFSET
    relative to register BASE.  */
@@ -16039,6 +16047,7 @@
 
   return ret;
 }
+#endif
 
 /* Set VAL to correct enum value according to the indirect-branch or
    function-return attribute in ATTR.  */
@@ -16112,6 +16121,7 @@
     s390_indirect_branch_attrvalue (attr, &cfun->machine->function_return_mem);
 }
 
+#if S390_USE_TARGET_ATTRIBUTE
 /* Restore targets globals from NEW_TREE and invalidate s390_previous_fndecl
    cache.  */
 
@@ -16127,6 +16137,7 @@
     TREE_TARGET_GLOBALS (new_tree) = save_target_globals_default_opts ();
   s390_previous_fndecl = NULL_TREE;
 }
+#endif
 
 /* Establish appropriate back-end context for processing the function
    FNDECL.  The argument might be NULL to indicate processing at top
@@ -16134,6 +16145,7 @@
 static void
 s390_set_current_function (tree fndecl)
 {
+#if S390_USE_TARGET_ATTRIBUTE
   /* Only change the context if the function changes.  This hook is called
      several times in the course of compiling a function, and we don't want to
      slow things down too much or call target_reinit when it isn't safe.  */
@@ -16165,10 +16177,9 @@
   if (old_tree != new_tree)
     s390_activate_target_options (new_tree);
   s390_previous_fndecl = fndecl;
-
+#endif
   s390_indirect_branch_settings (fndecl);
 }
-#endif
 
 /* Implement TARGET_USE_BY_PIECES_INFRASTRUCTURE_P.  */
 
@@ -16907,10 +16918,10 @@
 #undef TARGET_ASM_FILE_END
 #define TARGET_ASM_FILE_END s390_asm_file_end
 
-#if S390_USE_TARGET_ATTRIBUTE
 #undef TARGET_SET_CURRENT_FUNCTION
 #define TARGET_SET_CURRENT_FUNCTION s390_set_current_function
 
+#if S390_USE_TARGET_ATTRIBUTE
 #undef TARGET_OPTION_VALID_ATTRIBUTE_P
 #define TARGET_OPTION_VALID_ATTRIBUTE_P s390_valid_target_attribute_p
 
Index: gcc/config/s390/s390-builtins.def
===================================================================
--- a/src/gcc/config/s390/s390-builtins.def	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/s390/s390-builtins.def	(.../branches/gcc-8-branch)
@@ -328,36 +328,38 @@
 B_DEF      (s390_vgmf,                  vec_genmaskv4si,    0,                  B_VX,               O1_U8 | O2_U8,      BT_FN_UV4SI_UCHAR_UCHAR)
 B_DEF      (s390_vgmg,                  vec_genmaskv2di,    0,                  B_VX,               O1_U8 | O2_U8,      BT_FN_UV2DI_UCHAR_UCHAR)
 
-OB_DEF     (s390_vec_xl,                s390_vec_xl_s8,     s390_vec_xl_dbl,    B_VX,               BT_FN_V4SI_INT_VOIDPTR)
-OB_DEF_VAR (s390_vec_xl_s8,             MAX,                0,                  O1_LIT,             BT_OV_V16QI_LONG_SCHARPTR)               /* vl */
-OB_DEF_VAR (s390_vec_xl_u8,             MAX,                0,                  O1_LIT,             BT_OV_UV16QI_LONG_UCHARPTR)              /* vl */
-OB_DEF_VAR (s390_vec_xl_s16,            MAX,                0,                  O1_LIT,             BT_OV_V8HI_LONG_SHORTPTR)                /* vl */
-OB_DEF_VAR (s390_vec_xl_u16,            MAX,                0,                  O1_LIT,             BT_OV_UV8HI_LONG_USHORTPTR)              /* vl */
-OB_DEF_VAR (s390_vec_xl_s32,            MAX,                0,                  O1_LIT,             BT_OV_V4SI_LONG_INTPTR)                  /* vl */
-OB_DEF_VAR (s390_vec_xl_u32,            MAX,                0,                  O1_LIT,             BT_OV_UV4SI_LONG_UINTPTR)                /* vl */
-OB_DEF_VAR (s390_vec_xl_s64,            MAX,                0,                  O1_LIT,             BT_OV_V2DI_LONG_LONGLONGPTR)             /* vl */
-OB_DEF_VAR (s390_vec_xl_u64,            MAX,                0,                  O1_LIT,             BT_OV_UV2DI_LONG_ULONGLONGPTR)           /* vl */
-OB_DEF_VAR (s390_vec_xl_flt,            MAX,                0,                  O1_LIT,             BT_OV_V4SF_LONG_FLTPTR)                  /* vl */
-OB_DEF_VAR (s390_vec_xl_dbl,            MAX,                0,                  O1_LIT,             BT_OV_V2DF_LONG_DBLPTR)                  /* vl */
+OB_DEF     (s390_vec_xl,                s390_vec_xl_s8,     s390_vec_xl_dbl,    B_VX,               BT_FN_V4SI_INT_VOIDCONSTPTR)
+OB_DEF_VAR (s390_vec_xl_s8,             MAX,                0,                  O1_LIT,             BT_OV_V16QI_LONG_SCHARCONSTPTR)          /* vl */
+OB_DEF_VAR (s390_vec_xl_u8,             MAX,                0,                  O1_LIT,             BT_OV_UV16QI_LONG_UCHARCONSTPTR)         /* vl */
+OB_DEF_VAR (s390_vec_xl_s16,            MAX,                0,                  O1_LIT,             BT_OV_V8HI_LONG_SHORTCONSTPTR)           /* vl */
+OB_DEF_VAR (s390_vec_xl_u16,            MAX,                0,                  O1_LIT,             BT_OV_UV8HI_LONG_USHORTCONSTPTR)         /* vl */
+OB_DEF_VAR (s390_vec_xl_s32,            MAX,                0,                  O1_LIT,             BT_OV_V4SI_LONG_INTCONSTPTR)             /* vl */
+OB_DEF_VAR (s390_vec_xl_u32,            MAX,                0,                  O1_LIT,             BT_OV_UV4SI_LONG_UINTCONSTPTR)           /* vl */
+OB_DEF_VAR (s390_vec_xl_s64,            MAX,                0,                  O1_LIT,             BT_OV_V2DI_LONG_LONGLONGCONSTPTR)        /* vl */
+OB_DEF_VAR (s390_vec_xl_u64,            MAX,                0,                  O1_LIT,             BT_OV_UV2DI_LONG_ULONGLONGCONSTPTR)      /* vl */
+OB_DEF_VAR (s390_vec_xl_flt,            MAX,                0,                  O1_LIT,             BT_OV_V4SF_LONG_FLTCONSTPTR)             /* vl */
+OB_DEF_VAR (s390_vec_xl_dbl,            MAX,                0,                  O1_LIT,             BT_OV_V2DF_LONG_DBLCONSTPTR)             /* vl */
 
-OB_DEF     (s390_vec_xld2,              s390_vec_xld2_s8,   s390_vec_xld2_dbl,  B_DEP | B_VX,       BT_FN_V4SI_INT_VOIDPTR)
-OB_DEF_VAR (s390_vec_xld2_s8,           MAX,                0,                  O1_LIT,             BT_OV_V16QI_LONG_SCHARPTR)               /* vl */
-OB_DEF_VAR (s390_vec_xld2_u8,           MAX,                0,                  O1_LIT,             BT_OV_UV16QI_LONG_UCHARPTR)              /* vl */
-OB_DEF_VAR (s390_vec_xld2_s16,          MAX,                0,                  O1_LIT,             BT_OV_V8HI_LONG_SHORTPTR)                /* vl */
-OB_DEF_VAR (s390_vec_xld2_u16,          MAX,                0,                  O1_LIT,             BT_OV_UV8HI_LONG_USHORTPTR)              /* vl */
-OB_DEF_VAR (s390_vec_xld2_s32,          MAX,                0,                  O1_LIT,             BT_OV_V4SI_LONG_INTPTR)                  /* vl */
-OB_DEF_VAR (s390_vec_xld2_u32,          MAX,                0,                  O1_LIT,             BT_OV_UV4SI_LONG_UINTPTR)                /* vl */
-OB_DEF_VAR (s390_vec_xld2_s64,          MAX,                0,                  O1_LIT,             BT_OV_V2DI_LONG_LONGLONGPTR)             /* vl */
-OB_DEF_VAR (s390_vec_xld2_u64,          MAX,                0,                  O1_LIT,             BT_OV_UV2DI_LONG_ULONGLONGPTR)           /* vl */
-OB_DEF_VAR (s390_vec_xld2_dbl,          MAX,                0,                  O1_LIT,             BT_OV_V2DF_LONG_DBLPTR)                  /* vl */
+OB_DEF     (s390_vec_xld2,              s390_vec_xld2_s8,   s390_vec_xld2_dbl,  B_DEP | B_VX,       BT_FN_V4SI_INT_VOIDCONSTPTR)
+OB_DEF_VAR (s390_vec_xld2_s8,           MAX,                0,                  O1_LIT,             BT_OV_V16QI_LONG_SCHARCONSTPTR)          /* vl */
+OB_DEF_VAR (s390_vec_xld2_u8,           MAX,                0,                  O1_LIT,             BT_OV_UV16QI_LONG_UCHARCONSTPTR)         /* vl */
+OB_DEF_VAR (s390_vec_xld2_s16,          MAX,                0,                  O1_LIT,             BT_OV_V8HI_LONG_SHORTCONSTPTR)           /* vl */
+OB_DEF_VAR (s390_vec_xld2_u16,          MAX,                0,                  O1_LIT,             BT_OV_UV8HI_LONG_USHORTCONSTPTR)         /* vl */
+OB_DEF_VAR (s390_vec_xld2_s32,          MAX,                0,                  O1_LIT,             BT_OV_V4SI_LONG_INTCONSTPTR)             /* vl */
+OB_DEF_VAR (s390_vec_xld2_u32,          MAX,                0,                  O1_LIT,             BT_OV_UV4SI_LONG_UINTCONSTPTR)           /* vl */
+OB_DEF_VAR (s390_vec_xld2_s64,          MAX,                0,                  O1_LIT,             BT_OV_V2DI_LONG_LONGLONGCONSTPTR)        /* vl */
+OB_DEF_VAR (s390_vec_xld2_u64,          MAX,                0,                  O1_LIT,             BT_OV_UV2DI_LONG_ULONGLONGCONSTPTR)      /* vl */
+OB_DEF_VAR (s390_vec_xld2_flt,          MAX,                B_VXE,              O1_LIT,             BT_OV_V4SF_LONG_FLTCONSTPTR)             /* vl */
+OB_DEF_VAR (s390_vec_xld2_dbl,          MAX,                0,                  O1_LIT,             BT_OV_V2DF_LONG_DBLCONSTPTR)             /* vl */
 
-OB_DEF     (s390_vec_xlw4,              s390_vec_xlw4_s8,   s390_vec_xlw4_u32,  B_DEP | B_VX,       BT_FN_V4SI_INT_VOIDPTR)
-OB_DEF_VAR (s390_vec_xlw4_s8,           MAX,                0,                  O1_LIT,             BT_OV_V16QI_LONG_SCHARPTR)               /* vl */
-OB_DEF_VAR (s390_vec_xlw4_u8,           MAX,                0,                  O1_LIT,             BT_OV_UV16QI_LONG_UCHARPTR)              /* vl */
-OB_DEF_VAR (s390_vec_xlw4_s16,          MAX,                0,                  O1_LIT,             BT_OV_V8HI_LONG_SHORTPTR)                /* vl */
-OB_DEF_VAR (s390_vec_xlw4_u16,          MAX,                0,                  O1_LIT,             BT_OV_UV8HI_LONG_USHORTPTR)              /* vl */
-OB_DEF_VAR (s390_vec_xlw4_s32,          MAX,                0,                  O1_LIT,             BT_OV_V4SI_LONG_INTPTR)                  /* vl */
-OB_DEF_VAR (s390_vec_xlw4_u32,          MAX,                0,                  O1_LIT,             BT_OV_UV4SI_LONG_UINTPTR)                /* vl */
+OB_DEF     (s390_vec_xlw4,              s390_vec_xlw4_s8,   s390_vec_xlw4_flt,  B_DEP | B_VX,       BT_FN_V4SI_INT_VOIDCONSTPTR)
+OB_DEF_VAR (s390_vec_xlw4_s8,           MAX,                0,                  O1_LIT,             BT_OV_V16QI_LONG_SCHARCONSTPTR)          /* vl */
+OB_DEF_VAR (s390_vec_xlw4_u8,           MAX,                0,                  O1_LIT,             BT_OV_UV16QI_LONG_UCHARCONSTPTR)         /* vl */
+OB_DEF_VAR (s390_vec_xlw4_s16,          MAX,                0,                  O1_LIT,             BT_OV_V8HI_LONG_SHORTCONSTPTR)           /* vl */
+OB_DEF_VAR (s390_vec_xlw4_u16,          MAX,                0,                  O1_LIT,             BT_OV_UV8HI_LONG_USHORTCONSTPTR)         /* vl */
+OB_DEF_VAR (s390_vec_xlw4_s32,          MAX,                0,                  O1_LIT,             BT_OV_V4SI_LONG_INTCONSTPTR)             /* vl */
+OB_DEF_VAR (s390_vec_xlw4_u32,          MAX,                0,                  O1_LIT,             BT_OV_UV4SI_LONG_UINTCONSTPTR)           /* vl */
+OB_DEF_VAR (s390_vec_xlw4_flt,          MAX,                B_VXE,              O1_LIT,             BT_OV_V4SF_LONG_FLTCONSTPTR)             /* vl */
 
 OB_DEF     (s390_vec_splats,            s390_vec_splats_s8, s390_vec_splats_dbl,B_VX,               BT_FN_OV4SI_INT)
 OB_DEF_VAR (s390_vec_splats_s8,         s390_vlrepb,        0,                  0,                  BT_OV_V16QI_SCHAR)
@@ -746,7 +748,7 @@
 OB_DEF_VAR (s390_vec_xstd2_u64,         MAX,                0,                  O2_LIT,             BT_OV_VOID_UV2DI_LONG_ULONGLONGPTR)      /* vst */
 OB_DEF_VAR (s390_vec_xstd2_dbl,         MAX,                0,                  O2_LIT,             BT_OV_VOID_V2DF_LONG_DBLPTR)             /* vst */
 
-OB_DEF     (s390_vec_xstw4,             s390_vec_xstw4_s8,  s390_vec_xstw4_u32, B_DEP | B_VX,       BT_FN_VOID_OV4SI_INT_VOIDPTR)
+OB_DEF     (s390_vec_xstw4,             s390_vec_xstw4_s8,  s390_vec_xstw4_flt, B_DEP | B_VX,       BT_FN_VOID_OV4SI_INT_VOIDPTR)
 OB_DEF_VAR (s390_vec_xstw4_s8,          MAX,                0,                  O2_LIT,             BT_OV_VOID_V16QI_LONG_SCHARPTR)          /* vst */
 OB_DEF_VAR (s390_vec_xstw4_u8,          MAX,                0,                  O2_LIT,             BT_OV_VOID_UV16QI_LONG_UCHARPTR)         /* vst */
 OB_DEF_VAR (s390_vec_xstw4_s16,         MAX,                0,                  O2_LIT,             BT_OV_VOID_V8HI_LONG_SHORTPTR)           /* vst */
@@ -753,6 +755,7 @@
 OB_DEF_VAR (s390_vec_xstw4_u16,         MAX,                0,                  O2_LIT,             BT_OV_VOID_UV8HI_LONG_USHORTPTR)         /* vst */
 OB_DEF_VAR (s390_vec_xstw4_s32,         MAX,                0,                  O2_LIT,             BT_OV_VOID_V4SI_LONG_INTPTR)             /* vst */
 OB_DEF_VAR (s390_vec_xstw4_u32,         MAX,                0,                  O2_LIT,             BT_OV_VOID_UV4SI_LONG_UINTPTR)           /* vst */
+OB_DEF_VAR (s390_vec_xstw4_flt,         MAX,                B_VXE,              O2_LIT,             BT_OV_VOID_V4SF_LONG_FLTPTR)             /* vst */
 
 OB_DEF     (s390_vec_store_len,         s390_vec_store_len_s8,s390_vec_store_len_dbl,B_VX,          BT_FN_VOID_OV4SI_VOIDPTR_UINT)
 OB_DEF_VAR (s390_vec_store_len_s8,      s390_vstl,          0,                  0,                  BT_OV_VOID_V16QI_SCHARPTR_UINT)
Index: gcc/config/i386/t-freebsd64
===================================================================
--- a/src/gcc/config/i386/t-freebsd64	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/i386/t-freebsd64	(.../branches/gcc-8-branch)
@@ -0,0 +1,30 @@
+# Copyright (C) 2019 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# The 32-bit libraries are found in /usr/lib32
+
+# To support i386 and x86-64, the directory structrue
+# should be:
+#
+# 	/lib has x86-64 libraries.
+# 	/lib32 has i386 libraries.
+#
+
+MULTILIB_OPTIONS    = m32
+MULTILIB_DIRNAMES   = 32
+MULTILIB_OSDIRNAMES = ../lib32
Index: gcc/config/i386/i386.md
===================================================================
--- a/src/gcc/config/i386/i386.md	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/i386/i386.md	(.../branches/gcc-8-branch)
@@ -8942,7 +8942,24 @@
   [(parallel [(set (match_dup 0)
 		   (zero_extend:DI (and:SI (match_dup 1) (match_dup 2))))
 	      (clobber (reg:CC FLAGS_REG))])]
-  "operands[2] = gen_lowpart (SImode, operands[2]);")
+{
+  if (GET_CODE (operands[2]) == SYMBOL_REF
+      || GET_CODE (operands[2]) == LABEL_REF)
+    {
+      operands[2] = shallow_copy_rtx (operands[2]);
+      PUT_MODE (operands[2], SImode);
+    }
+  else if (GET_CODE (operands[2]) == CONST)
+    {
+      /* (const:DI (plus:DI (symbol_ref:DI ("...")) (const_int N))) */
+      operands[2] = copy_rtx (operands[2]);
+      PUT_MODE (operands[2], SImode);
+      PUT_MODE (XEXP (operands[2], 0), SImode);
+      PUT_MODE (XEXP (XEXP (operands[2], 0), 0), SImode);
+    }    
+  else
+    operands[2] = gen_lowpart (SImode, operands[2]);
+})
 
 ;; See comment for addsi_1_zext why we do use nonimmediate_operand
 (define_insn "*andsi_1_zext"
Index: gcc/config/i386/freebsd64.h
===================================================================
--- a/src/gcc/config/i386/freebsd64.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/i386/freebsd64.h	(.../branches/gcc-8-branch)
@@ -31,7 +31,7 @@
 
 #undef	LINK_SPEC
 #define LINK_SPEC "\
-  %{m32:-m elf_i386_fbsd} \
+  %{m32:-m elf_i386_fbsd}%{!m32:-m elf_x86_64_fbsd} \
   %{p:%nconsider using '-pg' instead of '-p' with gprof(1)} \
   %{v:-V} \
   %{assert*} %{R*} %{rpath*} %{defsym*} \
@@ -42,3 +42,6 @@
 	-dynamic-linker %(fbsd_dynamic_linker) } \
     %{static:-Bstatic}} \
   %{symbolic:-Bsymbolic}"
+
+#undef	MULTILIB_DEFAULTS
+#define MULTILIB_DEFAULTS { "m64" }
Index: gcc/config/i386/cpuid.h
===================================================================
--- a/src/gcc/config/i386/cpuid.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/i386/cpuid.h	(.../branches/gcc-8-branch)
@@ -178,10 +178,27 @@
 #define signature_VORTEX_ecx	0x436f5320
 #define signature_VORTEX_edx	0x36387865
 
+#ifndef __x86_64__
+/* At least one cpu (Winchip 2) does not set %ebx and %ecx
+   for cpuid leaf 1. Forcibly zero the two registers before
+   calling cpuid as a precaution.  */
 #define __cpuid(level, a, b, c, d)			\
+  do {							\
+    if (__builtin_constant_p (level) && (level) != 1)	\
+      __asm__ ("cpuid\n\t"				\
+	      : "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
+	      : "0" (level));				\
+    else						\
+      __asm__ ("cpuid\n\t"				\
+	      : "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
+	      : "0" (level), "1" (0), "2" (0));		\
+  } while (0)
+#else
+#define __cpuid(level, a, b, c, d)			\
   __asm__ ("cpuid\n\t"					\
 	   : "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
 	   : "0" (level))
+#endif
 
 #define __cpuid_count(level, count, a, b, c, d)		\
   __asm__ ("cpuid\n\t"					\
Index: gcc/config/i386/sse.md
===================================================================
--- a/src/gcc/config/i386/sse.md	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/i386/sse.md	(.../branches/gcc-8-branch)
@@ -1908,7 +1908,7 @@
   [(set (match_operand:VF1_128_256 0 "register_operand")
 	(unspec:VF1_128_256
 	  [(match_operand:VF1_128_256 1 "vector_operand")] UNSPEC_RSQRT))]
-  "TARGET_SSE_MATH"
+  "TARGET_SSE && TARGET_SSE_MATH"
 {
   ix86_emit_swsqrtsf (operands[0], operands[1], <MODE>mode, true);
   DONE;
@@ -16271,9 +16271,9 @@
     case 3:
       /* %X5 so that we don't emit any *WORD PTR for -masm=intel, as
 	 gas changed what it requires incompatibly.  */
-      return "vgatherpf0<ssemodesuffix>ps\t{%5%{%0%}|%X5%{%0%}}";
+      return "%M2vgatherpf0<ssemodesuffix>ps\t{%5%{%0%}|%X5%{%0%}}";
     case 2:
-      return "vgatherpf1<ssemodesuffix>ps\t{%5%{%0%}|%X5%{%0%}}";
+      return "%M2vgatherpf1<ssemodesuffix>ps\t{%5%{%0%}|%X5%{%0%}}";
     default:
       gcc_unreachable ();
     }
@@ -16318,9 +16318,9 @@
     case 3:
       /* %X5 so that we don't emit any *WORD PTR for -masm=intel, as
 	 gas changed what it requires incompatibly.  */
-      return "vgatherpf0<ssemodesuffix>pd\t{%5%{%0%}|%X5%{%0%}}";
+      return "%M2vgatherpf0<ssemodesuffix>pd\t{%5%{%0%}|%X5%{%0%}}";
     case 2:
-      return "vgatherpf1<ssemodesuffix>pd\t{%5%{%0%}|%X5%{%0%}}";
+      return "%M2vgatherpf1<ssemodesuffix>pd\t{%5%{%0%}|%X5%{%0%}}";
     default:
       gcc_unreachable ();
     }
@@ -16366,10 +16366,10 @@
     case 7:
       /* %X5 so that we don't emit any *WORD PTR for -masm=intel, as
 	 gas changed what it requires incompatibly.  */
-      return "vscatterpf0<ssemodesuffix>ps\t{%5%{%0%}|%X5%{%0%}}";
+      return "%M2vscatterpf0<ssemodesuffix>ps\t{%5%{%0%}|%X5%{%0%}}";
     case 2:
     case 6:
-      return "vscatterpf1<ssemodesuffix>ps\t{%5%{%0%}|%X5%{%0%}}";
+      return "%M2vscatterpf1<ssemodesuffix>ps\t{%5%{%0%}|%X5%{%0%}}";
     default:
       gcc_unreachable ();
     }
@@ -16415,10 +16415,10 @@
     case 7:
       /* %X5 so that we don't emit any *WORD PTR for -masm=intel, as
 	 gas changed what it requires incompatibly.  */
-      return "vscatterpf0<ssemodesuffix>pd\t{%5%{%0%}|%X5%{%0%}}";
+      return "%M2vscatterpf0<ssemodesuffix>pd\t{%5%{%0%}|%X5%{%0%}}";
     case 2:
     case 6:
-      return "vscatterpf1<ssemodesuffix>pd\t{%5%{%0%}|%X5%{%0%}}";
+      return "%M2vscatterpf1<ssemodesuffix>pd\t{%5%{%0%}|%X5%{%0%}}";
     default:
       gcc_unreachable ();
     }
@@ -19157,7 +19157,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:VEC_GATHER_MODE 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherd<ssemodesuffix>\t{%1, %7, %0|%0, %7, %1}"
+  "%M3v<sseintprefix>gatherd<ssemodesuffix>\t{%1, %7, %0|%0, %7, %1}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19177,7 +19177,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:VEC_GATHER_MODE 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherd<ssemodesuffix>\t{%1, %6, %0|%0, %6, %1}"
+  "%M2v<sseintprefix>gatherd<ssemodesuffix>\t{%1, %6, %0|%0, %6, %1}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19218,7 +19218,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:VEC_GATHER_MODE 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %7, %2|%2, %7, %5}"
+  "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %7, %2|%2, %7, %5}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19240,8 +19240,8 @@
   "TARGET_AVX2"
 {
   if (<MODE>mode != <VEC_GATHER_SRCDI>mode)
-    return "v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %x0|%x0, %6, %4}";
-  return "v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %0|%0, %6, %4}";
+    return "%M2v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %x0|%x0, %6, %4}";
+  return "%M2v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %0|%0, %6, %4}";
 }
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
@@ -19265,7 +19265,7 @@
 		     (const_int 2) (const_int 3)])))
    (clobber (match_scratch:VI4F_256 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %7, %0|%0, %7, %5}"
+  "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %7, %0|%0, %7, %5}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19288,7 +19288,7 @@
 		     (const_int 2) (const_int 3)])))
    (clobber (match_scratch:VI4F_256 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %0|%0, %6, %4}"
+  "%M2v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %0|%0, %6, %4}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19328,7 +19328,7 @@
   "TARGET_AVX512F"
 ;; %X6 so that we don't emit any *WORD PTR for -masm=intel, as
 ;; gas changed what it requires incompatibly.
-  "v<sseintprefix>gatherd<ssemodesuffix>\t{%6, %0%{%2%}|%0%{%2%}, %X6}"
+  "%M4v<sseintprefix>gatherd<ssemodesuffix>\t{%6, %0%{%2%}|%0%{%2%}, %X6}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19349,7 +19349,7 @@
   "TARGET_AVX512F"
 ;; %X5 so that we don't emit any *WORD PTR for -masm=intel, as
 ;; gas changed what it requires incompatibly.
-  "v<sseintprefix>gatherd<ssemodesuffix>\t{%5, %0%{%1%}|%0%{%1%}, %X5}"
+  "%M3v<sseintprefix>gatherd<ssemodesuffix>\t{%5, %0%{%1%}|%0%{%1%}, %X5}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19390,7 +19390,7 @@
   "TARGET_AVX512F"
 ;; %X6 so that we don't emit any *WORD PTR for -masm=intel, as
 ;; gas changed what it requires incompatibly.
-  "v<sseintprefix>gatherq<ssemodesuffix>\t{%6, %1%{%2%}|%1%{%2%}, %X6}"
+  "%M4v<sseintprefix>gatherq<ssemodesuffix>\t{%6, %1%{%2%}|%1%{%2%}, %X6}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19415,11 +19415,11 @@
   if (<MODE>mode != <VEC_GATHER_SRCDI>mode)
     {
       if (<MODE_SIZE> != 64)
-	return "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %x0%{%1%}|%x0%{%1%}, %X5}";
+	return "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %x0%{%1%}|%x0%{%1%}, %X5}";
       else
-	return "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %t0%{%1%}|%t0%{%1%}, %X5}";
+	return "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %t0%{%1%}|%t0%{%1%}, %X5}";
     }
-  return "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %0%{%1%}|%0%{%1%}, %X5}";
+  return "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %0%{%1%}|%0%{%1%}, %X5}";
 }
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
@@ -19458,7 +19458,7 @@
   "TARGET_AVX512F"
 ;; %X5 so that we don't emit any *WORD PTR for -masm=intel, as
 ;; gas changed what it requires incompatibly.
-  "v<sseintprefix>scatterd<ssemodesuffix>\t{%3, %5%{%1%}|%X5%{%1%}, %3}"
+  "%M0v<sseintprefix>scatterd<ssemodesuffix>\t{%3, %5%{%1%}|%X5%{%1%}, %3}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19496,7 +19496,7 @@
   "TARGET_AVX512F"
 ;; %X5 so that we don't emit any *WORD PTR for -masm=intel, as
 ;; gas changed what it requires incompatibly.
-  "v<sseintprefix>scatterq<ssemodesuffix>\t{%3, %5%{%1%}|%X5%{%1%}, %3}"
+  "%M0v<sseintprefix>scatterq<ssemodesuffix>\t{%3, %5%{%1%}|%X5%{%1%}, %3}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
Index: gcc/config/i386/darwin.h
===================================================================
--- a/src/gcc/config/i386/darwin.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/i386/darwin.h	(.../branches/gcc-8-branch)
@@ -130,7 +130,8 @@
 #undef CC1_SPEC
 #define CC1_SPEC "%(cc1_cpu) \
   %{!mkernel:%{!static:%{!mdynamic-no-pic:-fPIC}}} \
-  %{g: %{!fno-eliminate-unused-debug-symbols: -feliminate-unused-debug-symbols }} " \
+  %{g: %{!fno-eliminate-unused-debug-symbols: -feliminate-unused-debug-symbols }} \
+  %{mx32:%eDarwin is not an mx32 platform}" \
   DARWIN_CC1_SPEC
 
 #undef ASM_SPEC
Index: gcc/config/i386/i386.c
===================================================================
--- a/src/gcc/config/i386/i386.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/i386/i386.c	(.../branches/gcc-8-branch)
@@ -1024,17 +1024,9 @@
 
     case ASHIFT:
     case LSHIFTRT:
-      if (!REG_P (XEXP (src, 1))
-	  && (!SUBREG_P (XEXP (src, 1))
-	      || SUBREG_BYTE (XEXP (src, 1)) != 0
-	      || !REG_P (SUBREG_REG (XEXP (src, 1))))
-	  && (!CONST_INT_P (XEXP (src, 1))
-	      || !IN_RANGE (INTVAL (XEXP (src, 1)), 0, 63)))
+      if (!CONST_INT_P (XEXP (src, 1))
+	  || !IN_RANGE (INTVAL (XEXP (src, 1)), 0, 63))
 	return false;
-
-      if (GET_MODE (XEXP (src, 1)) != QImode
-	  && !CONST_INT_P (XEXP (src, 1)))
-	return false;
       break;
 
     case PLUS:
@@ -1630,15 +1622,10 @@
 	{
     	  if (CONST_INT_P (XEXP (src, 0)))
 	    gain -= vector_const_cost (XEXP (src, 0));
-	  if (CONST_INT_P (XEXP (src, 1)))
-	    {
-	      gain += ix86_cost->shift_const;
-	      if (INTVAL (XEXP (src, 1)) >= 32)
-		gain -= COSTS_N_INSNS (1);
-	    }
-	  else
-	    /* Additional gain for omitting two CMOVs.  */
-	    gain += ix86_cost->shift_var + COSTS_N_INSNS (2);
+
+	  gain += ix86_cost->shift_const;
+	  if (INTVAL (XEXP (src, 1)) >= 32)
+	    gain -= COSTS_N_INSNS (1);
 	}
       else if (GET_CODE (src) == PLUS
 	       || GET_CODE (src) == MINUS
@@ -1754,60 +1741,14 @@
 {
   rtx reg = regno_reg_rtx[regno];
   rtx vreg = gen_reg_rtx (DImode);
-  bool count_reg = false;
   df_ref ref;
 
   for (ref = DF_REG_DEF_CHAIN (regno); ref; ref = DF_REF_NEXT_REG (ref))
     if (!bitmap_bit_p (insns, DF_REF_INSN_UID (ref)))
       {
-	df_ref use;
-
-	/* Detect the count register of a shift instruction.  */
-	for (use = DF_REG_USE_CHAIN (regno); use; use = DF_REF_NEXT_REG (use))
-	  if (bitmap_bit_p (insns, DF_REF_INSN_UID (use)))
-	    {
-	      rtx_insn *insn = DF_REF_INSN (use);
-	      rtx def_set = single_set (insn);
-
-	      gcc_assert (def_set);
-
-	      rtx src = SET_SRC (def_set);
-
-	      if ((GET_CODE (src) == ASHIFT
-		   || GET_CODE (src) == ASHIFTRT
-		   || GET_CODE (src) == LSHIFTRT)
-		  && !CONST_INT_P (XEXP (src, 1))
-		  && reg_or_subregno (XEXP (src, 1)) == regno)
-		count_reg = true;
-	    }
-
 	start_sequence ();
-	if (count_reg)
-	  {
-	    rtx qreg = gen_lowpart (QImode, reg);
-	    rtx tmp = gen_reg_rtx (SImode);
 
-	    if (TARGET_ZERO_EXTEND_WITH_AND
-		&& optimize_function_for_speed_p (cfun))
-	      {
-		emit_move_insn (tmp, const0_rtx);
-		emit_insn (gen_movstrictqi
-			   (gen_lowpart (QImode, tmp), qreg));
-	      }
-	    else
-	      emit_insn (gen_rtx_SET
-			 (tmp, gen_rtx_ZERO_EXTEND (SImode, qreg)));
-
-	    if (!TARGET_INTER_UNIT_MOVES_TO_VEC)
-	      {
-		rtx slot = assign_386_stack_local (SImode, SLOT_STV_TEMP);
-		emit_move_insn (slot, tmp);
-		tmp = copy_rtx (slot);
-	      }
-
-	    emit_insn (gen_zero_extendsidi2 (vreg, tmp));
-	  }
-	else if (!TARGET_INTER_UNIT_MOVES_TO_VEC)
+	if (!TARGET_INTER_UNIT_MOVES_TO_VEC)
 	  {
 	    rtx tmp = assign_386_stack_local (DImode, SLOT_STV_TEMP);
 	    emit_move_insn (adjust_address (tmp, SImode, 0),
@@ -1855,23 +1796,9 @@
     if (bitmap_bit_p (insns, DF_REF_INSN_UID (ref)))
       {
 	rtx_insn *insn = DF_REF_INSN (ref);
-	if (count_reg)
-	  {
-	    rtx def_set = single_set (insn);
-	    gcc_assert (def_set);
 
-	    rtx src = SET_SRC (def_set);
+	replace_with_subreg_in_insn (insn, reg, vreg);
 
-	    if ((GET_CODE (src) == ASHIFT
-		 || GET_CODE (src) == ASHIFTRT
-		 || GET_CODE (src) == LSHIFTRT)
-		&& !CONST_INT_P (XEXP (src, 1))
-		&& reg_or_subregno (XEXP (src, 1)) == regno)
-	      XEXP (src, 1) = vreg;
-	  }
-	else
-	  replace_with_subreg_in_insn (insn, reg, vreg);
-
 	if (dump_file)
 	  fprintf (dump_file, "  Replaced r%d with r%d in insn %d\n",
 		   regno, REGNO (vreg), INSN_UID (insn));
@@ -1973,42 +1900,7 @@
 	    rtx src = SET_SRC (def_set);
 	    rtx dst = SET_DEST (def_set);
 
-	    if ((GET_CODE (src) == ASHIFT
-		 || GET_CODE (src) == ASHIFTRT
-		 || GET_CODE (src) == LSHIFTRT)
-		&& !CONST_INT_P (XEXP (src, 1))
-		&& reg_or_subregno (XEXP (src, 1)) == regno)
-	      {
-		rtx tmp2 = gen_reg_rtx (V2DImode);
-
-		start_sequence ();
-
-		if (TARGET_SSE4_1)
-		  emit_insn (gen_sse4_1_zero_extendv2qiv2di2
-			     (tmp2, gen_rtx_SUBREG (V16QImode, reg, 0)));
-		else
-		  {
-		    rtx vec_cst
-		      = gen_rtx_CONST_VECTOR (V2DImode,
-					      gen_rtvec (2, GEN_INT (0xff),
-							 const0_rtx));
-		    vec_cst
-		      = validize_mem (force_const_mem (V2DImode, vec_cst));
-
-		    emit_insn (gen_rtx_SET
-			       (tmp2,
-				gen_rtx_AND (V2DImode,
-					     gen_rtx_SUBREG (V2DImode, reg, 0),
-					     vec_cst)));
-		  }
-		rtx_insn *seq = get_insns ();
-		end_sequence ();
-
-		emit_insn_before (seq, insn);
-
-		XEXP (src, 1) = gen_rtx_SUBREG (DImode, tmp2, 0);
-	      }
-	    else if (!MEM_P (dst) || !REG_P (src))
+	    if (!MEM_P (dst) || !REG_P (src))
 	      replace_with_subreg_in_insn (insn, reg, reg);
 
 	    bitmap_clear_bit (conv, INSN_UID (insn));
@@ -4958,6 +4850,12 @@
 			   opts->x_param_values,
 			   opts_set->x_param_values);
 
+  /* PR86952: jump table usage with retpolines is slow.
+     The PR provides some numbers about the slowness.  */
+  if (ix86_indirect_branch != indirect_branch_keep
+      && !opts_set->x_flag_jump_tables)
+    opts->x_flag_jump_tables = 0;
+
   return true;
 }
 
@@ -18121,6 +18019,7 @@
    ; -- print a semicolon (after prefixes due to bug in older gas).
    ~ -- print "i" if TARGET_AVX2, "f" otherwise.
    ^ -- print addr32 prefix if TARGET_64BIT and Pmode != word_mode
+   M -- print addr32 prefix for TARGET_X32 with VSIB address.
    ! -- print MPX prefix for jxx/call/ret instructions if required.
  */
 
@@ -18668,6 +18567,26 @@
 	  putc (TARGET_AVX2 ? 'i' : 'f', file);
 	  return;
 
+	case 'M':
+	  if (TARGET_X32)
+	    {
+	      /* NB: 32-bit indices in VSIB address are sign-extended
+		 to 64 bits. In x32, if 32-bit address 0xf7fa3010 is
+		 sign-extended to 0xfffffffff7fa3010 which is invalid
+		 address.  Add addr32 prefix if there is no base
+		 register nor symbol.  */
+	      bool ok;
+	      struct ix86_address parts;
+	      ok = ix86_decompose_address (x, &parts);
+	      gcc_assert (ok && parts.index == NULL_RTX);
+	      if (parts.base == NULL_RTX
+		  && (parts.disp == NULL_RTX
+		      || !symbolic_operand (parts.disp,
+					    GET_MODE (parts.disp))))
+		fputs ("addr32 ", file);
+	    }
+	  return;
+
 	case '^':
 	  if (TARGET_64BIT && Pmode != word_mode)
 	    fputs ("addr32 ", file);
@@ -24062,6 +23981,8 @@
   else
     {
       code = is_min ? SMIN : SMAX;
+      if (MEM_P (if_true) && MEM_P (if_false))
+	if_true = force_reg (mode, if_true);
       tmp = gen_rtx_fmt_ee (code, mode, if_true, if_false);
     }
 
@@ -28757,6 +28678,25 @@
   return false;
 }
 
+/* Helper to output the jmp/call.  */
+static void
+ix86_output_jmp_thunk_or_indirect (const char *thunk_name,
+				   enum indirect_thunk_prefix need_prefix,
+				   const int regno)
+{
+  if (thunk_name != NULL)
+    {
+      if (need_prefix == indirect_thunk_prefix_bnd)
+	fprintf (asm_out_file, "\tbnd jmp\t");
+      else
+	fprintf (asm_out_file, "\tjmp\t");
+      assemble_name (asm_out_file, thunk_name);
+      putc ('\n', asm_out_file);
+    }
+  else
+    output_indirect_thunk (need_prefix, regno);
+}
+
 /* Output indirect branch via a call and return thunk.  CALL_OP is a
    register which contains the branch target.  XASM is the assembly
    template for CALL_OP.  Branch is a tail call if SIBCALL_P is true.
@@ -28798,25 +28738,17 @@
     thunk_name = NULL;
 
   if (sibcall_p)
-    {
-      if (thunk_name != NULL)
-	{
-	  if (need_prefix == indirect_thunk_prefix_bnd)
-	    fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
-	  else
-	    fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
-	}
-      else
-	output_indirect_thunk (need_prefix, regno);
-    }
+    ix86_output_jmp_thunk_or_indirect (thunk_name, need_prefix, regno);
   else
     {
       if (thunk_name != NULL)
 	{
 	  if (need_prefix == indirect_thunk_prefix_bnd)
-	    fprintf (asm_out_file, "\tbnd call\t%s\n", thunk_name);
+	    fprintf (asm_out_file, "\tbnd call\t");
 	  else
-	    fprintf (asm_out_file, "\tcall\t%s\n", thunk_name);
+	    fprintf (asm_out_file, "\tcall\t");
+	  assemble_name (asm_out_file, thunk_name);
+	  putc ('\n', asm_out_file);
 	  return;
 	}
 
@@ -28840,15 +28772,7 @@
 
       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, indirectlabel1);
 
-      if (thunk_name != NULL)
-	{
-	  if (need_prefix == indirect_thunk_prefix_bnd)
-	    fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
-	  else
-	    fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
-	}
-      else
-	output_indirect_thunk (need_prefix, regno);
+      ix86_output_jmp_thunk_or_indirect (thunk_name, need_prefix, regno);
 
       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, indirectlabel2);
 
@@ -28913,15 +28837,7 @@
   if (sibcall_p)
     {
       output_asm_insn (push_buf, &call_op);
-      if (thunk_name != NULL)
-	{
-	  if (need_prefix == indirect_thunk_prefix_bnd)
-	    fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
-	  else
-	    fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
-	}
-      else
-	output_indirect_thunk (need_prefix, regno);
+      ix86_output_jmp_thunk_or_indirect (thunk_name, need_prefix, regno);
     }
   else
     {
@@ -28980,15 +28896,7 @@
 
       output_asm_insn (push_buf, &call_op);
 
-      if (thunk_name != NULL)
-	{
-	  if (need_prefix == indirect_thunk_prefix_bnd)
-	    fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
-	  else
-	    fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
-	}
-      else
-	output_indirect_thunk (need_prefix, regno);
+      ix86_output_jmp_thunk_or_indirect (thunk_name, need_prefix, regno);
 
       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, indirectlabel2);
 
@@ -29057,13 +28965,15 @@
 	  if (need_prefix == indirect_thunk_prefix_bnd)
 	    {
 	      indirect_return_bnd_needed |= need_thunk;
-	      fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
+	      fprintf (asm_out_file, "\tbnd jmp\t");
 	    }
 	  else
 	    {
 	      indirect_return_needed |= need_thunk;
-	      fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
+	      fprintf (asm_out_file, "\tjmp\t");
 	    }
+	  assemble_name (asm_out_file, thunk_name);
+	  putc ('\n', asm_out_file);
 	}
       else
 	output_indirect_thunk (need_prefix, INVALID_REGNUM);
@@ -29104,7 +29014,7 @@
 		  indirect_return_via_cx_bnd = true;
 		  indirect_thunks_bnd_used |= 1 << CX_REG;
 		}
-	      fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
+	      fprintf (asm_out_file, "\tbnd jmp\t");
 	    }
 	  else
 	    {
@@ -29113,8 +29023,10 @@
 		  indirect_return_via_cx = true;
 		  indirect_thunks_used |= 1 << CX_REG;
 		}
-	      fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
+	      fprintf (asm_out_file, "\tjmp\t");
 	    }
+	  assemble_name (asm_out_file, thunk_name);
+	  putc ('\n', asm_out_file);
 	}
       else
 	output_indirect_thunk (need_prefix, regno);
@@ -32923,6 +32835,7 @@
     }
   /* Build result decl and add to function_decl. */
   t = build_decl (UNKNOWN_LOCATION, RESULT_DECL, NULL_TREE, ptr_type_node);
+  DECL_CONTEXT (t) = decl;
   DECL_ARTIFICIAL (t) = 1;
   DECL_IGNORED_P (t) = 1;
   DECL_RESULT (decl) = t;
@@ -39641,7 +39554,7 @@
 static bool
 use_rsqrt_p ()
 {
-  return (TARGET_SSE_MATH
+  return (TARGET_SSE && TARGET_SSE_MATH
 	  && flag_finite_math_only
 	  && !flag_trapping_math
 	  && flag_unsafe_math_optimizations);
@@ -45705,8 +45618,10 @@
           x2 -= 1;
      Compensate.  Ceil:
         if (x2 < x)
-          x2 -= -1;
-        return x2;
+          x2 += 1;
+	if (HONOR_SIGNED_ZEROS (mode))
+	  x2 = copysign (x2, x);
+	return x2;
    */
   machine_mode mode = GET_MODE (operand0);
   rtx xa, TWO52, tmp, one, res, mask;
@@ -45732,17 +45647,16 @@
   /* xa = copysign (xa, operand1) */
   ix86_sse_copysign_to_positive (xa, xa, res, mask);
 
-  /* generate 1.0 or -1.0 */
-  one = force_reg (mode,
-	           const_double_from_real_value (do_floor
-						 ? dconst1 : dconstm1, mode));
+  /* generate 1.0 */
+  one = force_reg (mode, const_double_from_real_value (dconst1, mode));
 
   /* Compensate: xa = xa - (xa > operand1 ? 1 : 0) */
   tmp = ix86_expand_sse_compare_mask (UNGT, xa, res, !do_floor);
   emit_insn (gen_rtx_SET (tmp, gen_rtx_AND (mode, one, tmp)));
-  /* We always need to subtract here to preserve signed zero.  */
-  tmp = expand_simple_binop (mode, MINUS,
+  tmp = expand_simple_binop (mode, do_floor ? MINUS : PLUS,
 			     xa, tmp, NULL_RTX, 0, OPTAB_DIRECT);
+  if (!do_floor && HONOR_SIGNED_ZEROS (mode))
+    ix86_sse_copysign_to_positive (tmp, tmp, res, mask);
   emit_move_insn (res, tmp);
 
   emit_label (label);
@@ -50999,7 +50913,7 @@
      there is no adddf3 pattern (since x87 floating point only has
      XFmode operations) so the default hook implementation gets this
      wrong.  */
-  return TARGET_80387 || TARGET_SSE_MATH;
+  return TARGET_80387 || (TARGET_SSE && TARGET_SSE_MATH);
 }
 
 /* Implement TARGET_ATOMIC_ASSIGN_EXPAND_FENV.  */
@@ -51007,7 +50921,7 @@
 static void
 ix86_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
 {
-  if (!TARGET_80387 && !TARGET_SSE_MATH)
+  if (!TARGET_80387 && !(TARGET_SSE && TARGET_SSE_MATH))
     return;
   tree exceptions_var = create_tmp_var_raw (integer_type_node);
   if (TARGET_80387)
@@ -51042,7 +50956,7 @@
       tree update_fldenv = build_call_expr (fldenv, 1, fenv_addr);
       *update = build2 (COMPOUND_EXPR, void_type_node, *update, update_fldenv);
     }
-  if (TARGET_SSE_MATH)
+  if (TARGET_SSE && TARGET_SSE_MATH)
     {
       tree mxcsr_orig_var = create_tmp_var_raw (unsigned_type_node);
       tree mxcsr_mod_var = create_tmp_var_raw (unsigned_type_node);
@@ -51399,7 +51313,7 @@
 	  return FLT_EVAL_METHOD_PROMOTE_TO_FLOAT;
 	else if (!TARGET_MIX_SSE_I387)
 	  {
-	    if (!TARGET_SSE_MATH)
+	    if (!(TARGET_SSE && TARGET_SSE_MATH))
 	      return FLT_EVAL_METHOD_PROMOTE_TO_LONG_DOUBLE;
 	    else if (TARGET_SSE2)
 	      return FLT_EVAL_METHOD_PROMOTE_TO_FLOAT;
Index: gcc/config/riscv/riscv.c
===================================================================
--- a/src/gcc/config/riscv/riscv.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/riscv/riscv.c	(.../branches/gcc-8-branch)
@@ -4389,6 +4389,32 @@
   return align;
 }
 
+/* Implement TARGET_PROMOTE_FUNCTION_MODE.  */
+
+/* This function is equivalent to default_promote_function_mode_always_promote
+   except that it returns a promoted mode even if type is NULL_TREE.  This is
+   needed by libcalls which have no type (only a mode) such as fixed conversion
+   routines that take a signed or unsigned char/short/int argument and convert
+   it to a fixed type.  */
+
+static machine_mode
+riscv_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,
+			     machine_mode mode,
+			     int *punsignedp ATTRIBUTE_UNUSED,
+			     const_tree fntype ATTRIBUTE_UNUSED,
+			     int for_return ATTRIBUTE_UNUSED)
+{
+  int unsignedp;
+
+  if (type != NULL_TREE)
+    return promote_mode (type, mode, punsignedp);
+
+  unsignedp = *punsignedp;
+  PROMOTE_MODE (mode, unsignedp, type);
+  *punsignedp = unsignedp;
+  return mode;
+}
+
 /* Initialize the GCC target structure.  */
 #undef TARGET_ASM_ALIGNED_HI_OP
 #define TARGET_ASM_ALIGNED_HI_OP "\t.half\t"
@@ -4430,7 +4456,7 @@
 #define TARGET_EXPAND_BUILTIN_VA_START riscv_va_start
 
 #undef  TARGET_PROMOTE_FUNCTION_MODE
-#define TARGET_PROMOTE_FUNCTION_MODE default_promote_function_mode_always_promote
+#define TARGET_PROMOTE_FUNCTION_MODE riscv_promote_function_mode
 
 #undef TARGET_RETURN_IN_MEMORY
 #define TARGET_RETURN_IN_MEMORY riscv_return_in_memory
Index: gcc/config/aarch64/driver-aarch64.c
===================================================================
--- a/src/gcc/config/aarch64/driver-aarch64.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/aarch64/driver-aarch64.c	(.../branches/gcc-8-branch)
@@ -36,7 +36,8 @@
   const char *feat_string;
 };
 
-#define AARCH64_OPT_EXTENSION(EXT_NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, FEATURE_STRING) \
+#define AARCH64_OPT_EXTENSION(EXT_NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, \
+			      SYNTHETIC, FEATURE_STRING) \
   { EXT_NAME, FLAG_CANONICAL, FEATURE_STRING },
 static struct aarch64_arch_extension aarch64_extensions[] =
 {
@@ -249,19 +250,24 @@
 	{
 	  for (i = 0; i < num_exts; i++)
 	    {
-	      char *p = NULL;
-	      char *feat_string
-		= concat (aarch64_extensions[i].feat_string, NULL);
+	      const char *p = aarch64_extensions[i].feat_string;
+
+	      /* If the feature contains no HWCAPS string then ignore it for the
+		 auto detection.  */
+	      if (*p == '\0')
+		continue;
+
 	      bool enabled = true;
 
 	      /* This may be a multi-token feature string.  We need
-		 to match all parts, which could be in any order.
-		 If this isn't a multi-token feature string, strtok is
-		 just going to return a pointer to feat_string.  */
-	      p = strtok (feat_string, " ");
-	      while (p != NULL)
+		 to match all parts, which could be in any order.  */
+	      size_t len = strlen (buf);
+	      do
 		{
-		  if (strstr (buf, p) == NULL)
+		  const char *end = strchr (p, ' ');
+		  if (end == NULL)
+		    end = strchr (p, '\0');
+		  if (memmem (buf, len, p, end - p) == NULL)
 		    {
 		      /* Failed to match this token.  Turn off the
 			 features we'd otherwise enable.  */
@@ -268,8 +274,11 @@
 		      enabled = false;
 		      break;
 		    }
-		  p = strtok (NULL, " ");
+		  if (*end == '\0')
+		    break;
+		  p = end + 1;
 		}
+	      while (1);
 
 	      if (enabled)
 		extension_flags |= aarch64_extensions[i].flag;
@@ -359,12 +368,12 @@
 not_found:
   {
    /* If detection fails we ignore the option.
-      Clean up and return empty string.  */
+      Clean up and return NULL.  */
 
     if (f)
       fclose (f);
 
-    return "";
+    return NULL;
   }
 }
 
Index: gcc/config/aarch64/iterators.md
===================================================================
--- a/src/gcc/config/aarch64/iterators.md	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/aarch64/iterators.md	(.../branches/gcc-8-branch)
@@ -578,7 +578,8 @@
 (define_mode_attr sizen [(QI "8") (HI "16") (SI "32") (DI "64")])
 
 ;; Give the ordinal of the MSB in the mode
-(define_mode_attr sizem1 [(QI "#7") (HI "#15") (SI "#31") (DI "#63")])
+(define_mode_attr sizem1 [(QI "#7") (HI "#15") (SI "#31") (DI "#63")
+			  (HF "#15") (SF "#31") (DF "#63")])
 
 ;; Attribute to describe constants acceptable in logical operations
 (define_mode_attr lconst [(SI "K") (DI "L")])
@@ -664,7 +665,7 @@
 			  (V8HF "16b") (V2SF  "8b")
 			  (V4SF "16b") (V2DF  "16b")
 			  (DI   "8b")  (DF    "8b")
-			  (SI   "8b")])
+			  (SI   "8b")  (SF    "8b")])
 
 ;; Define element mode for each vector mode.
 (define_mode_attr VEL [(V8QI  "QI") (V16QI "QI") (VNx16QI "QI")
Index: gcc/config/aarch64/aarch64.md
===================================================================
--- a/src/gcc/config/aarch64/aarch64.md	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/aarch64/aarch64.md	(.../branches/gcc-8-branch)
@@ -189,6 +189,7 @@
     UNSPEC_CLASTB
     UNSPEC_FADDA
     UNSPEC_REV_SUBREG
+    UNSPEC_COPYSIGN
 ])
 
 (define_c_enum "unspecv" [
@@ -5427,49 +5428,48 @@
 ;;   LDR d2, #(1 << 63)
 ;;   BSL v2.8b, [y], [x]
 ;;
-;; or another, equivalent, sequence using one of BSL/BIT/BIF.
-;; aarch64_simd_bsldf will select the best suited of these instructions
-;; to generate based on register allocation, and knows how to partially
-;; constant fold based on the values of X and Y, so expand through that.
+;; or another, equivalent, sequence using one of BSL/BIT/BIF.  Because
+;; we expect these operations to nearly always operate on
+;; floating-point values, we do not want the operation to be
+;; simplified into a bit-field insert operation that operates on the
+;; integer side, since typically that would involve three inter-bank
+;; register copies.  As we do not expect copysign to be followed by
+;; other logical operations on the result, it seems preferable to keep
+;; this as an unspec operation, rather than exposing the underlying
+;; logic to the compiler.
 
-(define_expand "copysigndf3"
-  [(match_operand:DF 0 "register_operand")
-   (match_operand:DF 1 "register_operand")
-   (match_operand:DF 2 "register_operand")]
+(define_expand "copysign<GPF:mode>3"
+  [(match_operand:GPF 0 "register_operand")
+   (match_operand:GPF 1 "register_operand")
+   (match_operand:GPF 2 "register_operand")]
   "TARGET_FLOAT && TARGET_SIMD"
 {
-  rtx mask = gen_reg_rtx (DImode);
-  emit_move_insn (mask, GEN_INT (HOST_WIDE_INT_1U << 63));
-  emit_insn (gen_aarch64_simd_bsldf (operands[0], mask,
-				     operands[2], operands[1]));
+  rtx bitmask = gen_reg_rtx (<V_INT_EQUIV>mode);
+  emit_move_insn (bitmask, GEN_INT (HOST_WIDE_INT_M1U
+				    << (GET_MODE_BITSIZE (<MODE>mode) - 1)));
+  emit_insn (gen_copysign<mode>3_insn (operands[0], operands[1], operands[2],
+				       bitmask));
   DONE;
 }
 )
 
-;; As above, but we must first get to a 64-bit value if we wish to use
-;; aarch64_simd_bslv2sf.
-
-(define_expand "copysignsf3"
-  [(match_operand:SF 0 "register_operand")
-   (match_operand:SF 1 "register_operand")
-   (match_operand:SF 2 "register_operand")]
+(define_insn "copysign<GPF:mode>3_insn"
+  [(set (match_operand:GPF 0 "register_operand" "=w,w,w,r")
+	(unspec:GPF [(match_operand:GPF 1 "register_operand" "w,0,w,r")
+		     (match_operand:GPF 2 "register_operand" "w,w,0,0")
+		     (match_operand:<V_INT_EQUIV> 3 "register_operand"
+		      "0,w,w,X")]
+	 UNSPEC_COPYSIGN))]
   "TARGET_FLOAT && TARGET_SIMD"
-{
-  rtx v_bitmask = gen_reg_rtx (V2SImode);
-
-  /* Juggle modes to get us in to a vector mode for BSL.  */
-  rtx op1 = lowpart_subreg (DImode, operands[1], SFmode);
-  rtx op2 = lowpart_subreg (V2SFmode, operands[2], SFmode);
-  rtx tmp = gen_reg_rtx (V2SFmode);
-  emit_move_insn (v_bitmask,
-		  aarch64_simd_gen_const_vector_dup (V2SImode,
-						     HOST_WIDE_INT_M1U << 31));
-  emit_insn (gen_aarch64_simd_bslv2sf (tmp, v_bitmask, op2, op1));
-  emit_move_insn (operands[0], lowpart_subreg (SFmode, tmp, V2SFmode));
-  DONE;
-}
+  "@
+   bsl\\t%0.<Vbtype>, %2.<Vbtype>, %1.<Vbtype>
+   bit\\t%0.<Vbtype>, %2.<Vbtype>, %3.<Vbtype>
+   bif\\t%0.<Vbtype>, %1.<Vbtype>, %3.<Vbtype>
+   bfxil\\t%<w1>0, %<w1>1, #0, <sizem1>"
+  [(set_attr "type" "neon_bsl<q>,neon_bsl<q>,neon_bsl<q>,bfm")]
 )
 
+
 ;; For xorsign (x, y), we want to generate:
 ;;
 ;; LDR   d2, #1<<63
Index: gcc/config/aarch64/aarch64-option-extensions.def
===================================================================
--- a/src/gcc/config/aarch64/aarch64-option-extensions.def	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/aarch64/aarch64-option-extensions.def	(.../branches/gcc-8-branch)
@@ -21,88 +21,97 @@
 
    Before using #include to read this file, define a macro:
 
-      AARCH64_OPT_EXTENSION(EXT_NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, FEATURE_STRING)
+      AARCH64_OPT_EXTENSION(EXT_NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF,
+			    SYNTHETIC, FEATURE_STRING)
 
-   EXT_NAME is the name of the extension, represented as a string constant.
-   FLAGS_CANONICAL is the canonical internal name for this flag.
-   FLAGS_ON are the bitwise-or of the features that enabling the extension
-   adds, or zero if enabling this extension has no effect on other features.
-   FLAGS_OFF are the bitwise-or of the features that disabling the extension
-   removes, or zero if disabling this extension has no effect on other
-   features.
-   FEAT_STRING is a string containing the entries in the 'Features' field of
-   /proc/cpuinfo on a GNU/Linux system that correspond to this architecture
-   extension being available.  Sometimes multiple entries are needed to enable
-   the extension (for example, the 'crypto' extension depends on four
-   entries: aes, pmull, sha1, sha2 being present).  In that case this field
-   should contain a space (" ") separated list of the strings in 'Features'
-   that are required.  Their order is not important.  */
+   - EXT_NAME is the name of the extension, represented as a string constant.
+   - FLAGS_CANONICAL is the canonical internal name for this flag.
+   - FLAGS_ON are the bitwise-or of the features that enabling the extension
+     adds, or zero if enabling this extension has no effect on other features.
+   - FLAGS_OFF are the bitwise-or of the features that disabling the extension
+     removes, or zero if disabling this extension has no effect on other
+     features.
+   - SYNTHETIC is a boolean to indicate whether the option is a purely synthetic
+     grouping of options and that the option itself has no feature bit (e.g.
+     crypto).  This is used to determine when sum of the individual options in
+     FLAGS_ON can be replaced by FLAG_CANONICAL in options minimization.  If the
+     group is synthetic then they can be replaced when all options in FLAGS_ON
+     are enabled, otherwise they can only be replaced when
+     FLAGS_ON | FLAG_CANONICAL are enabled.
+   - FEAT_STRING is a string containing the entries in the 'Features' field of
+     /proc/cpuinfo on a GNU/Linux system that correspond to this architecture
+     extension being available.  Sometimes multiple entries are needed to enable
+     the extension (for example, the 'crypto' extension depends on four
+     entries: aes, pmull, sha1, sha2 being present).  In that case this field
+     should contain a space (" ") separated list of the strings in 'Features'
+     that are required.  Their order is not important.  An empty string means
+     do not detect this feature during auto detection.  */
 
+/* NOTE: This file is being parsed by config.gcc and so the
+   AARCH64_OPT_EXTENSION must adhere to a strict format:
+   1) No space between the AARCH64_OPT_EXTENSION and the opening (.
+   2) No space between the opening ( and the extension name.
+   3) No space after the extension name before the ,.
+   4) Spaces are only allowed after a , and around |.
+   5) Everything must be on one line.  */
+
 /* Enabling "fp" just enables "fp".
    Disabling "fp" also disables "simd", "crypto", "fp16", "aes", "sha2",
    "sha3", sm3/sm4 and "sve".  */
-AARCH64_OPT_EXTENSION("fp", AARCH64_FL_FP, 0, AARCH64_FL_SIMD | AARCH64_FL_CRYPTO |\
-		      AARCH64_FL_F16 | AARCH64_FL_AES | AARCH64_FL_SHA2 |\
-		      AARCH64_FL_SHA3 | AARCH64_FL_SM4 | AARCH64_FL_SVE, "fp")
+AARCH64_OPT_EXTENSION("fp", AARCH64_FL_FP, 0, AARCH64_FL_SIMD | AARCH64_FL_CRYPTO | AARCH64_FL_F16 | AARCH64_FL_AES | AARCH64_FL_SHA2 | AARCH64_FL_SHA3 | AARCH64_FL_SM4 | AARCH64_FL_SVE, false, "fp")
 
 /* Enabling "simd" also enables "fp".
    Disabling "simd" also disables "crypto", "dotprod", "aes", "sha2", "sha3",
    "sm3/sm4" and "sve".  */
-AARCH64_OPT_EXTENSION("simd", AARCH64_FL_SIMD, AARCH64_FL_FP, AARCH64_FL_CRYPTO |\
-		      AARCH64_FL_DOTPROD | AARCH64_FL_AES | AARCH64_FL_SHA2 |\
-		      AARCH64_FL_SHA3 | AARCH64_FL_SM4 | AARCH64_FL_SVE,
-		      "asimd")
+AARCH64_OPT_EXTENSION("simd", AARCH64_FL_SIMD, AARCH64_FL_FP, AARCH64_FL_CRYPTO | AARCH64_FL_DOTPROD | AARCH64_FL_AES | AARCH64_FL_SHA2 | AARCH64_FL_SHA3 | AARCH64_FL_SM4 | AARCH64_FL_SVE, false, "asimd")
 
-/* Enabling "crypto" also enables "fp" and "simd".
+/* Enabling "crypto" also enables "fp", "simd", "aes" and "sha2".
    Disabling "crypto" disables "crypto", "aes", "sha2", "sha3" and "sm3/sm4".  */
-AARCH64_OPT_EXTENSION("crypto", AARCH64_FL_CRYPTO, AARCH64_FL_FP | AARCH64_FL_SIMD,\
-		      AARCH64_FL_AES | AARCH64_FL_SHA2 |AARCH64_FL_SHA3 | AARCH64_FL_SM4,\
-		      "aes pmull sha1 sha2")
+AARCH64_OPT_EXTENSION("crypto", AARCH64_FL_CRYPTO, AARCH64_FL_FP | AARCH64_FL_SIMD | AARCH64_FL_AES | AARCH64_FL_SHA2, AARCH64_FL_AES | AARCH64_FL_SHA2 |AARCH64_FL_SHA3 | AARCH64_FL_SM4, true, "aes pmull sha1 sha2")
 
 /* Enabling or disabling "crc" only changes "crc".  */
-AARCH64_OPT_EXTENSION("crc", AARCH64_FL_CRC, 0, 0, "crc32")
+AARCH64_OPT_EXTENSION("crc", AARCH64_FL_CRC, 0, 0, false, "crc32")
 
 /* Enabling or disabling "lse" only changes "lse".  */
-AARCH64_OPT_EXTENSION("lse", AARCH64_FL_LSE, 0, 0, "atomics")
+AARCH64_OPT_EXTENSION("lse", AARCH64_FL_LSE, 0, 0, false, "atomics")
 
 /* Enabling "fp16" also enables "fp".
    Disabling "fp16" disables "fp16", "fp16fml" and "sve".  */
-AARCH64_OPT_EXTENSION("fp16", AARCH64_FL_F16, AARCH64_FL_FP,
-		      AARCH64_FL_F16FML | AARCH64_FL_SVE, "fphp asimdhp")
+AARCH64_OPT_EXTENSION("fp16", AARCH64_FL_F16, AARCH64_FL_FP, AARCH64_FL_F16FML | AARCH64_FL_SVE, false, "fphp asimdhp")
 
 /* Enabling or disabling "rcpc" only changes "rcpc".  */
-AARCH64_OPT_EXTENSION("rcpc", AARCH64_FL_RCPC, 0, 0, "lrcpc")
+AARCH64_OPT_EXTENSION("rcpc", AARCH64_FL_RCPC, 0, 0, false, "lrcpc")
 
 /* Enabling "rdma" also enables "fp", "simd".
    Disabling "rdma" just disables "rdma".  */
-AARCH64_OPT_EXTENSION("rdma", AARCH64_FL_RDMA, AARCH64_FL_FP | AARCH64_FL_SIMD, 0, "asimdrdm")
+AARCH64_OPT_EXTENSION("rdma", AARCH64_FL_RDMA, AARCH64_FL_FP | AARCH64_FL_SIMD, 0, false, "asimdrdm")
 
 /* Enabling "dotprod" also enables "simd".
    Disabling "dotprod" only disables "dotprod".  */
-AARCH64_OPT_EXTENSION("dotprod", AARCH64_FL_DOTPROD, AARCH64_FL_SIMD, 0, "asimddp")
+AARCH64_OPT_EXTENSION("dotprod", AARCH64_FL_DOTPROD, AARCH64_FL_SIMD, 0, false, "asimddp")
 
 /* Enabling "aes" also enables "simd".
    Disabling "aes" just disables "aes".  */
-AARCH64_OPT_EXTENSION("aes", AARCH64_FL_AES, AARCH64_FL_SIMD, 0, "aes")
+AARCH64_OPT_EXTENSION("aes", AARCH64_FL_AES, AARCH64_FL_SIMD, 0, false, "aes")
 
 /* Enabling "sha2" also enables "simd".
    Disabling "sha2" just disables "sha2".  */
-AARCH64_OPT_EXTENSION("sha2", AARCH64_FL_SHA2, AARCH64_FL_SIMD, 0, "sha1 sha2")
+AARCH64_OPT_EXTENSION("sha2", AARCH64_FL_SHA2, AARCH64_FL_SIMD, 0, false, "sha1 sha2")
 
 /* Enabling "sha3" enables "simd" and "sha2".
    Disabling "sha3" just disables "sha3".  */
-AARCH64_OPT_EXTENSION("sha3", AARCH64_FL_SHA3, AARCH64_FL_SIMD | AARCH64_FL_SHA2, 0, "sha3 sha512")
+AARCH64_OPT_EXTENSION("sha3", AARCH64_FL_SHA3, AARCH64_FL_SIMD | AARCH64_FL_SHA2, 0, false, "sha3 sha512")
 
 /* Enabling "sm4" also enables "simd".
    Disabling "sm4" just disables "sm4".  */
-AARCH64_OPT_EXTENSION("sm4", AARCH64_FL_SM4, AARCH64_FL_SIMD, 0, "sm3 sm4")
+AARCH64_OPT_EXTENSION("sm4", AARCH64_FL_SM4, AARCH64_FL_SIMD, 0, false, "sm3 sm4")
 
 /* Enabling "fp16fml" also enables "fp" and "fp16".
    Disabling "fp16fml" just disables "fp16fml".  */
-AARCH64_OPT_EXTENSION("fp16fml", AARCH64_FL_F16FML, AARCH64_FL_FP | AARCH64_FL_F16, 0, "asimdfml")
+AARCH64_OPT_EXTENSION("fp16fml", AARCH64_FL_F16FML, AARCH64_FL_FP | AARCH64_FL_F16, 0, false, "asimdfml")
 
 /* Enabling "sve" also enables "fp16", "fp" and "simd".
    Disabling "sve" just disables "sve".  */
-AARCH64_OPT_EXTENSION("sve", AARCH64_FL_SVE, AARCH64_FL_FP | AARCH64_FL_SIMD | AARCH64_FL_F16, 0, "sve")
+AARCH64_OPT_EXTENSION("sve", AARCH64_FL_SVE, AARCH64_FL_FP | AARCH64_FL_SIMD | AARCH64_FL_F16, 0, false, "sve")
 
 #undef AARCH64_OPT_EXTENSION
Index: gcc/config/aarch64/aarch64-c.c
===================================================================
--- a/src/gcc/config/aarch64/aarch64-c.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/aarch64/aarch64-c.c	(.../branches/gcc-8-branch)
@@ -146,6 +146,7 @@
       builtin_define_with_int_value ("__ARM_FEATURE_SVE_BITS", bits);
     }
 
+  aarch64_def_or_undef (TARGET_LSE, "__ARM_FEATURE_ATOMICS", pfile);
   aarch64_def_or_undef (TARGET_AES, "__ARM_FEATURE_AES", pfile);
   aarch64_def_or_undef (TARGET_SHA2, "__ARM_FEATURE_SHA2", pfile);
   aarch64_def_or_undef (TARGET_SHA3, "__ARM_FEATURE_SHA3", pfile);
Index: gcc/config/aarch64/aarch64.c
===================================================================
--- a/src/gcc/config/aarch64/aarch64.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/aarch64/aarch64.c	(.../branches/gcc-8-branch)
@@ -15623,7 +15623,7 @@
 	return true;
       if (d->vec_flags == VEC_SVE_DATA)
 	return aarch64_evpc_sve_tbl (d);
-      else if (d->vec_flags == VEC_SVE_DATA)
+      else if (d->vec_flags == VEC_ADVSIMD)
 	return aarch64_evpc_tbl (d);
     }
   return false;
Index: gcc/config/rs6000/mmintrin.h
===================================================================
--- a/src/gcc/config/rs6000/mmintrin.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/rs6000/mmintrin.h	(.../branches/gcc-8-branch)
@@ -581,7 +581,7 @@
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _m_psubd (__m64 __m1, __m64 __m2)
 {
-  return _mm_add_pi32 (__m1, __m2);
+  return _mm_sub_pi32 (__m1, __m2);
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
Index: gcc/config/rs6000/power9.md
===================================================================
--- a/src/gcc/config/rs6000/power9.md	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/rs6000/power9.md	(.../branches/gcc-8-branch)
@@ -236,6 +236,9 @@
        (eq_attr "cpu" "power9"))
   "DU_super_power9,LSU_pair_power9")
 
+; Store forwarding latency is 6
+(define_bypass 6 "power9-*store*" "power9-*load*")
+
 (define_insn_reservation "power9-larx" 4
   (and (eq_attr "type" "load_l")
        (eq_attr "cpu" "power9"))
Index: gcc/config/rs6000/t-linux
===================================================================
--- a/src/gcc/config/rs6000/t-linux	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/rs6000/t-linux	(.../branches/gcc-8-branch)
@@ -4,7 +4,7 @@
 ifneq (,$(findstring powerpc64,$(target)))
 MULTILIB_OSDIRNAMES := .=../lib64$(call if_multiarch,:powerpc64-linux-gnu)
 else
-MULTIARCH_DIRNAME := powerpc-linux-gnu
+MULTIARCH_DIRNAME := $(call if_multiarch,powerpc-linux-gnu)
 endif
 ifneq (,$(findstring powerpcle,$(target)))
 MULTIARCH_DIRNAME := $(subst -linux,le-linux,$(MULTIARCH_DIRNAME))
Index: gcc/config/rs6000/rs6000-builtin.def
===================================================================
--- a/src/gcc/config/rs6000/rs6000-builtin.def	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/rs6000/rs6000-builtin.def	(.../branches/gcc-8-branch)
@@ -2442,13 +2442,22 @@
 BU_P9_OVERLOAD_2 (CMPEQB,	"byte_in_set")
 
 /* 1 argument crypto functions.  */
-BU_CRYPTO_1 (VSBOX,		"vsbox",	  CONST, crypto_vsbox)
+BU_CRYPTO_1 (VSBOX,		"vsbox",	  CONST, crypto_vsbox_v2di)
+BU_CRYPTO_1 (VSBOX_BE,		"vsbox_be",	  CONST, crypto_vsbox_v16qi)
 
 /* 2 argument crypto functions.  */
-BU_CRYPTO_2 (VCIPHER,		"vcipher",	  CONST, crypto_vcipher)
-BU_CRYPTO_2 (VCIPHERLAST,	"vcipherlast",	  CONST, crypto_vcipherlast)
-BU_CRYPTO_2 (VNCIPHER,		"vncipher",	  CONST, crypto_vncipher)
-BU_CRYPTO_2 (VNCIPHERLAST,	"vncipherlast",	  CONST, crypto_vncipherlast)
+BU_CRYPTO_2 (VCIPHER,		"vcipher",	  CONST, crypto_vcipher_v2di)
+BU_CRYPTO_2 (VCIPHER_BE,	"vcipher_be",	  CONST, crypto_vcipher_v16qi)
+BU_CRYPTO_2 (VCIPHERLAST,	"vcipherlast",
+	     CONST, crypto_vcipherlast_v2di)
+BU_CRYPTO_2 (VCIPHERLAST_BE,	"vcipherlast_be",
+	     CONST, crypto_vcipherlast_v16qi)
+BU_CRYPTO_2 (VNCIPHER,		"vncipher",	  CONST, crypto_vncipher_v2di)
+BU_CRYPTO_2 (VNCIPHER_BE,	"vncipher_be",	  CONST, crypto_vncipher_v16qi)
+BU_CRYPTO_2 (VNCIPHERLAST,	"vncipherlast",
+	     CONST, crypto_vncipherlast_v2di)
+BU_CRYPTO_2 (VNCIPHERLAST_BE,	"vncipherlast_be",
+	     CONST, crypto_vncipherlast_v16qi)
 BU_CRYPTO_2A (VPMSUMB,		"vpmsumb",	  CONST, crypto_vpmsumb)
 BU_CRYPTO_2A (VPMSUMH,		"vpmsumh",	  CONST, crypto_vpmsumh)
 BU_CRYPTO_2A (VPMSUMW,		"vpmsumw",	  CONST, crypto_vpmsumw)
Index: gcc/config/rs6000/rs6000-c.c
===================================================================
--- a/src/gcc/config/rs6000/rs6000-c.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/rs6000/rs6000-c.c	(.../branches/gcc-8-branch)
@@ -6605,12 +6605,14 @@
 
 	  arg2 = fold_for_warn (arg2);
 
-	  /* If the second argument is an integer constant, if the value is in
-	     the expected range, generate the built-in code if we can.  We need
-	     64-bit and direct move to extract the small integer vectors.  */
-	  if (TREE_CODE (arg2) == INTEGER_CST
-	      && wi::ltu_p (wi::to_wide (arg2), nunits))
+	  /* If the second argument is an integer constant, generate
+	     the built-in code if we can.  We need 64-bit and direct
+	     move to extract the small integer vectors.  */
+	  if (TREE_CODE (arg2) == INTEGER_CST)
 	    {
+	      wide_int selector = wi::to_wide (arg2);
+	      selector = wi::umod_trunc (selector, nunits);
+	      arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);
 	      switch (mode)
 		{
 		default:
@@ -6785,11 +6787,13 @@
       /* If we can use the VSX xxpermdi instruction, use that for insert.  */
       mode = TYPE_MODE (arg1_type);
       if ((mode == V2DFmode || mode == V2DImode) && VECTOR_UNIT_VSX_P (mode)
-	  && TREE_CODE (arg2) == INTEGER_CST
-	  && wi::ltu_p (wi::to_wide (arg2), 2))
+	  && TREE_CODE (arg2) == INTEGER_CST)
 	{
+	  wide_int selector = wi::to_wide (arg2);
+	  selector = wi::umod_trunc (selector, 2);
 	  tree call = NULL_TREE;
 
+	  arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);
 	  if (mode == V2DFmode)
 	    call = rs6000_builtin_decls[VSX_BUILTIN_VEC_SET_V2DF];
 	  else if (mode == V2DImode)
@@ -6801,11 +6805,12 @@
 	    return build_call_expr (call, 3, arg1, arg0, arg2);
 	}
       else if (mode == V1TImode && VECTOR_UNIT_VSX_P (mode)
-	       && TREE_CODE (arg2) == INTEGER_CST
-	       && wi::eq_p (wi::to_wide (arg2), 0))
+	       && TREE_CODE (arg2) == INTEGER_CST)
 	{
 	  tree call = rs6000_builtin_decls[VSX_BUILTIN_VEC_SET_V1TI];
+	  wide_int selector = wi::zero(32);
 
+	  arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);
 	  /* Note, __builtin_vec_insert_<xxx> has vector and scalar types
 	     reversed.  */
 	  return build_call_expr (call, 3, arg1, arg0, arg2);
@@ -6813,10 +6818,13 @@
 
       /* Build *(((arg1_inner_type*)&(vector type){arg1})+arg2) = arg0. */
       arg1_inner_type = TREE_TYPE (arg1_type);
-      arg2 = build_binary_op (loc, BIT_AND_EXPR, arg2,
-			      build_int_cst (TREE_TYPE (arg2),
-					     TYPE_VECTOR_SUBPARTS (arg1_type)
-					     - 1), 0);
+      if (TYPE_VECTOR_SUBPARTS (arg1_type) == 1)
+	arg2 = build_int_cst (TREE_TYPE (arg2), 0);
+      else
+	arg2 = build_binary_op (loc, BIT_AND_EXPR, arg2,
+				build_int_cst (TREE_TYPE (arg2),
+					       TYPE_VECTOR_SUBPARTS (arg1_type)
+					       - 1), 0);
       decl = build_decl (loc, VAR_DECL, NULL_TREE, arg1_type);
       DECL_EXTERNAL (decl) = 0;
       TREE_PUBLIC (decl) = 0;
Index: gcc/config/rs6000/rs6000-p8swap.c
===================================================================
--- a/src/gcc/config/rs6000/rs6000-p8swap.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/rs6000/rs6000-p8swap.c	(.../branches/gcc-8-branch)
@@ -2317,7 +2317,14 @@
 
   /* Pre-pass to recombine lvx and stvx patterns so we don't lose info.  */
   recombine_lvx_stvx_patterns (fun);
+
+  /* Rebuild ud- and du-chains.  */
+  df_remove_problem (df_chain);
   df_process_deferred_rescans ();
+  df_set_flags (DF_RD_PRUNE_DEAD_DEFS);
+  df_chain_add_problem (DF_DU_CHAIN | DF_UD_CHAIN);
+  df_analyze ();
+  df_set_flags (DF_DEFER_INSN_RESCAN);
 
   /* Allocate structure to represent webs of insns.  */
   insn_entry = XCNEWVEC (swap_web_entry, get_max_uid ());
Index: gcc/config/rs6000/rs6000.c
===================================================================
--- a/src/gcc/config/rs6000/rs6000.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/rs6000/rs6000.c	(.../branches/gcc-8-branch)
@@ -7374,7 +7374,6 @@
 	default:
 	  break;
 	case E_V1TImode:
-	  gcc_assert (INTVAL (elt) == 0 && inner_mode == TImode);
 	  emit_move_insn (target, gen_lowpart (TImode, vec));
 	  break;
 	case E_V2DFmode:
@@ -7425,6 +7424,10 @@
 
       switch (mode)
 	{
+	case E_V1TImode:
+	  emit_move_insn (target, gen_lowpart (TImode, vec));
+	  return;
+
 	case E_V2DFmode:
 	  emit_insn (gen_vsx_extract_v2df_var (target, vec, elt));
 	  return;
@@ -7454,18 +7457,32 @@
 	}
     }
 
-  gcc_assert (CONST_INT_P (elt));
-
   /* Allocate mode-sized buffer.  */
   mem = assign_stack_temp (mode, GET_MODE_SIZE (mode));
 
   emit_move_insn (mem, vec);
+  if (CONST_INT_P (elt))
+    {
+      int modulo_elt = INTVAL (elt) % GET_MODE_NUNITS (mode);
 
-  /* Add offset to field within buffer matching vector element.  */
-  mem = adjust_address_nv (mem, inner_mode,
-			   INTVAL (elt) * GET_MODE_SIZE (inner_mode));
+      /* Add offset to field within buffer matching vector element.  */
+      mem = adjust_address_nv (mem, inner_mode,
+			       modulo_elt * GET_MODE_SIZE (inner_mode));
+      emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));
+    }
+  else
+    {
+      unsigned int ele_size = GET_MODE_SIZE (inner_mode);
+      rtx num_ele_m1 = GEN_INT (GET_MODE_NUNITS (mode) - 1);
+      rtx new_addr = gen_reg_rtx (Pmode);
 
-  emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));
+      elt = gen_rtx_AND (Pmode, elt, num_ele_m1);
+      if (ele_size > 1)
+	elt = gen_rtx_MULT (Pmode, elt, GEN_INT (ele_size));
+      new_addr = gen_rtx_PLUS (Pmode, XEXP (mem, 0), elt);
+      new_addr = change_address (mem, inner_mode, new_addr);
+      emit_move_insn (target, new_addr);
+    }
 }
 
 /* Helper function to return the register number of a RTX.  */
@@ -7646,7 +7663,7 @@
 			      rtx tmp_altivec)
 {
   machine_mode mode = GET_MODE (src);
-  machine_mode scalar_mode = GET_MODE (dest);
+  machine_mode scalar_mode = GET_MODE_INNER (GET_MODE (src));
   unsigned scalar_size = GET_MODE_SIZE (scalar_mode);
   int byte_shift = exact_log2 (scalar_size);
 
@@ -7657,6 +7674,10 @@
      systems.  */
   if (MEM_P (src))
     {
+      int num_elements = GET_MODE_NUNITS (mode);
+      rtx num_ele_m1 = GEN_INT (num_elements - 1);
+
+      emit_insn (gen_anddi3 (element, element, num_ele_m1));
       gcc_assert (REG_P (tmp_gpr));
       emit_move_insn (dest, rs6000_adjust_vec_address (dest, src, element,
 						       tmp_gpr, scalar_mode));
@@ -7665,7 +7686,9 @@
 
   else if (REG_P (src) || SUBREG_P (src))
     {
-      int bit_shift = byte_shift + 3;
+      int num_elements = GET_MODE_NUNITS (mode);
+      int bits_in_element = mode_to_bits (GET_MODE_INNER (mode));
+      int bit_shift = 7 - exact_log2 (num_elements);
       rtx element2;
       int dest_regno = regno_or_subregno (dest);
       int src_regno = regno_or_subregno (src);
@@ -7741,7 +7764,7 @@
 	{
 	  if (!VECTOR_ELT_ORDER_BIG)
 	    {
-	      rtx num_ele_m1 = GEN_INT (GET_MODE_NUNITS (mode) - 1);
+	      rtx num_ele_m1 = GEN_INT (num_elements - 1);
 
 	      emit_insn (gen_anddi3 (tmp_gpr, element, num_ele_m1));
 	      emit_insn (gen_subdi3 (tmp_gpr, num_ele_m1, tmp_gpr));
@@ -7799,8 +7822,8 @@
 	    emit_insn (gen_vsx_vslo_v2di (tmp_altivec_di, src_v2di,
 					  tmp_altivec));
 	    emit_move_insn (tmp_gpr_di, tmp_altivec_di);
-	    emit_insn (gen_ashrdi3 (tmp_gpr_di, tmp_gpr_di,
-				    GEN_INT (64 - (8 * scalar_size))));
+	    emit_insn (gen_lshrdi3 (tmp_gpr_di, tmp_gpr_di,
+				    GEN_INT (64 - bits_in_element)));
 	    return;
 	  }
 
@@ -12592,7 +12615,9 @@
       if (elt_mode == TDmode && (cum->fregno % 2) == 1)
 	cum->fregno++;
 
-      if (USE_FP_FOR_ARG_P (cum, elt_mode))
+      if (USE_FP_FOR_ARG_P (cum, elt_mode)
+	  && !(TARGET_AIX && !TARGET_ELF
+	       && type != NULL && AGGREGATE_TYPE_P (type)))
 	{
 	  rtx rvec[GP_ARG_NUM_REG + AGGR_ARG_NUM_REG + 1];
 	  rtx r, off;
@@ -12728,7 +12753,9 @@
 
   align_words = rs6000_parm_start (mode, type, cum->words);
 
-  if (USE_FP_FOR_ARG_P (cum, elt_mode))
+  if (USE_FP_FOR_ARG_P (cum, elt_mode)
+      && !(TARGET_AIX && !TARGET_ELF
+	   && type != NULL && AGGREGATE_TYPE_P (type)))
     {
       unsigned long n_fpreg = (GET_MODE_SIZE (elt_mode) + 7) >> 3;
 
@@ -15417,9 +15444,17 @@
   op0 = expand_normal (arg0);
   op1 = expand_normal (arg1);
 
-  /* Call get_element_number to validate arg1 if it is a constant.  */
   if (TREE_CODE (arg1) == INTEGER_CST)
-    (void) get_element_number (TREE_TYPE (arg0), arg1);
+    {
+      unsigned HOST_WIDE_INT elt;
+      unsigned HOST_WIDE_INT size = TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0));
+      unsigned int truncated_selector;
+      /* Even if !tree_fits_uhwi_p (arg1)), TREE_INT_CST_LOW (arg0)
+	 returns low-order bits of INTEGER_CST for modulo indexing.  */
+      elt = TREE_INT_CST_LOW (arg1);
+      truncated_selector = elt % size;
+      op1 = GEN_INT (truncated_selector);
+    }
 
   tmode = TYPE_MODE (TREE_TYPE (TREE_TYPE (arg0)));
   mode0 = TYPE_MODE (TREE_TYPE (arg0));
@@ -16765,15 +16800,6 @@
     case ALTIVEC_BUILTIN_VSPLTISH:
     case ALTIVEC_BUILTIN_VSPLTISW:
       {
-	 int size;
-
-         if (fn_code == ALTIVEC_BUILTIN_VSPLTISB)
-           size = 8;
-         else if (fn_code == ALTIVEC_BUILTIN_VSPLTISH)
-           size = 16;
-         else
-           size = 32;
-
 	 arg0 = gimple_call_arg (stmt, 0);
 	 lhs = gimple_call_lhs (stmt);
 
@@ -16780,8 +16806,7 @@
 	 /* Only fold the vec_splat_*() if the lower bits of arg 0 is a
 	    5-bit signed constant in range -16 to +15.  */
 	 if (TREE_CODE (arg0) != INTEGER_CST
-	     || !IN_RANGE (sext_hwi(TREE_INT_CST_LOW (arg0), size),
-			   -16, 15))
+	     || !IN_RANGE (TREE_INT_CST_LOW (arg0), -16, 15))
 	   return false;
 	 gimple_seq stmts = NULL;
 	 location_t loc = gimple_location (stmt);
@@ -18261,6 +18286,7 @@
     {
     /* unsigned 1 argument functions.  */
     case CRYPTO_BUILTIN_VSBOX:
+    case CRYPTO_BUILTIN_VSBOX_BE:
     case P8V_BUILTIN_VGBBD:
     case MISC_BUILTIN_CDTBCD:
     case MISC_BUILTIN_CBCDTD:
@@ -18276,9 +18302,13 @@
     case ALTIVEC_BUILTIN_VMULOUH:
     case P8V_BUILTIN_VMULOUW:
     case CRYPTO_BUILTIN_VCIPHER:
+    case CRYPTO_BUILTIN_VCIPHER_BE:
     case CRYPTO_BUILTIN_VCIPHERLAST:
+    case CRYPTO_BUILTIN_VCIPHERLAST_BE:
     case CRYPTO_BUILTIN_VNCIPHER:
+    case CRYPTO_BUILTIN_VNCIPHER_BE:
     case CRYPTO_BUILTIN_VNCIPHERLAST:
+    case CRYPTO_BUILTIN_VNCIPHERLAST_BE:
     case CRYPTO_BUILTIN_VPMSUMB:
     case CRYPTO_BUILTIN_VPMSUMH:
     case CRYPTO_BUILTIN_VPMSUMW:
@@ -34192,6 +34222,10 @@
 			   rs6000_xcoff_output_readwrite_section_asm_op,
 			   &xcoff_private_data_section_name);
 
+  read_only_private_data_section
+    = get_unnamed_section (0, rs6000_xcoff_output_readonly_section_asm_op,
+			   &xcoff_private_rodata_section_name);
+
   tls_data_section
     = get_unnamed_section (SECTION_TLS,
 			   rs6000_xcoff_output_tls_section_asm_op,
@@ -34202,10 +34236,6 @@
 			   rs6000_xcoff_output_tls_section_asm_op,
 			   &xcoff_private_data_section_name);
 
-  read_only_private_data_section
-    = get_unnamed_section (0, rs6000_xcoff_output_readonly_section_asm_op,
-			   &xcoff_private_data_section_name);
-
   toc_section
     = get_unnamed_section (0, rs6000_xcoff_output_toc_section_asm_op, NULL);
 
@@ -34386,6 +34416,8 @@
 			   main_input_filename, ".bss_");
   rs6000_gen_section_name (&xcoff_private_data_section_name,
 			   main_input_filename, ".rw_");
+  rs6000_gen_section_name (&xcoff_private_rodata_section_name,
+			   main_input_filename, ".rop_");
   rs6000_gen_section_name (&xcoff_read_only_section_name,
 			   main_input_filename, ".ro_");
   rs6000_gen_section_name (&xcoff_tls_data_section_name,
@@ -36605,11 +36637,21 @@
 unsigned int
 rs6000_dbx_register_number (unsigned int regno, unsigned int format)
 {
-  /* Except for the above, we use the internal number for non-DWARF
-     debug information, and also for .eh_frame.  */
+  /* We use the GCC 7 (and before) internal number for non-DWARF debug
+     information, and also for .eh_frame.  */
   if ((format == 0 && write_symbols != DWARF2_DEBUG) || format == 2)
-    return regno;
+    {
+      /* Translate the regnos to their numbers in GCC 7 (and before).  */
+      if (regno == TFHAR_REGNO)
+	regno = 114;
+      else if (regno == TFIAR_REGNO)
+	regno = 115;
+      else if (regno == TEXASR_REGNO)
+	regno = 116;
 
+      return regno;
+    }
+
   /* On some platforms, we use the standard DWARF register
      numbering for .debug_info and .debug_frame.  */
 #ifdef RS6000_USE_DWARF_NUMBERING
@@ -36635,6 +36677,12 @@
     return 356;
   if (regno == VSCR_REGNO)
     return 67;
+  if (regno == TFHAR_REGNO)
+    return 228;
+  if (regno == TFIAR_REGNO)
+    return 229;
+  if (regno == TEXASR_REGNO)
+    return 230;
 #endif
   return regno;
 }
@@ -37840,6 +37888,7 @@
 
   /* Build result decl and add to function_decl.  */
   tree t = build_decl (UNKNOWN_LOCATION, RESULT_DECL, NULL_TREE, ptr_type_node);
+  DECL_CONTEXT (t) = decl;
   DECL_ARTIFICIAL (t) = 1;
   DECL_IGNORED_P (t) = 1;
   DECL_RESULT (decl) = t;
Index: gcc/config/rs6000/vsx.md
===================================================================
--- a/src/gcc/config/rs6000/vsx.md	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/rs6000/vsx.md	(.../branches/gcc-8-branch)
@@ -3756,9 +3756,9 @@
   DONE;
 })
 
-(define_insn_and_split "*vsx_extract_<VSX_EXTRACT_I:mode>_<SDI:mode>_var"
-  [(set (match_operand:SDI 0 "gpc_reg_operand" "=r,r,r")
-	(zero_extend:SDI
+(define_insn_and_split "*vsx_extract_<mode>_<VS_scalar>mode_var"
+  [(set (match_operand:<VS_scalar> 0 "gpc_reg_operand" "=r,r,r")
+	(zero_extend:<VS_scalar>
 	 (unspec:<VSX_EXTRACT_I:VS_scalar>
 	  [(match_operand:VSX_EXTRACT_I 1 "input_operand" "wK,v,m")
 	   (match_operand:DI 2 "gpc_reg_operand" "r,r,r")]
@@ -3770,7 +3770,7 @@
   "&& reload_completed"
   [(const_int 0)]
 {
-  machine_mode smode = <VSX_EXTRACT_I:MODE>mode;
+  machine_mode smode = <VS_scalar>mode;
   rs6000_split_vec_extract_var (gen_rtx_REG (smode, REGNO (operands[0])),
 				operands[1], operands[2],
 				operands[3], operands[4]);
Index: gcc/config/rs6000/crypto.md
===================================================================
--- a/src/gcc/config/rs6000/crypto.md	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/rs6000/crypto.md	(.../branches/gcc-8-branch)
@@ -48,6 +48,9 @@
 ;; Iterator for VSHASIGMAD/VSHASIGMAW
 (define_mode_iterator CR_hash [V4SI V2DI])
 
+;; Iterator for VSBOX/VCIPHER/VNCIPHER/VCIPHERLAST/VNCIPHERLAST
+(define_mode_iterator CR_vqdi [V16QI V2DI])
+
 ;; Iterator for the other crypto functions
 (define_int_iterator CR_code   [UNSPEC_VCIPHER
 				UNSPEC_VNCIPHER
@@ -60,10 +63,10 @@
 			  (UNSPEC_VNCIPHERLAST "vncipherlast")])
 
 ;; 2 operand crypto instructions
-(define_insn "crypto_<CR_insn>"
-  [(set (match_operand:V2DI 0 "register_operand" "=v")
-	(unspec:V2DI [(match_operand:V2DI 1 "register_operand" "v")
-		      (match_operand:V2DI 2 "register_operand" "v")]
+(define_insn "crypto_<CR_insn>_<mode>"
+  [(set (match_operand:CR_vqdi 0 "register_operand" "=v")
+	(unspec:CR_vqdi [(match_operand:CR_vqdi 1 "register_operand" "v")
+		      (match_operand:CR_vqdi 2 "register_operand" "v")]
 		     CR_code))]
   "TARGET_CRYPTO"
   "<CR_insn> %0,%1,%2"
@@ -90,9 +93,9 @@
   [(set_attr "type" "vecperm")])
 
 ;; 1 operand crypto instruction
-(define_insn "crypto_vsbox"
-  [(set (match_operand:V2DI 0 "register_operand" "=v")
-	(unspec:V2DI [(match_operand:V2DI 1 "register_operand" "v")]
+(define_insn "crypto_vsbox_<mode>"
+  [(set (match_operand:CR_vqdi 0 "register_operand" "=v")
+	(unspec:CR_vqdi [(match_operand:CR_vqdi 1 "register_operand" "v")]
 		     UNSPEC_VSBOX))]
   "TARGET_CRYPTO"
   "vsbox %0,%1"
Index: gcc/config/rs6000/rs6000.md
===================================================================
--- a/src/gcc/config/rs6000/rs6000.md	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/rs6000/rs6000.md	(.../branches/gcc-8-branch)
@@ -12594,15 +12594,18 @@
   [(unspec [(const_int 0)] UNSPEC_GRP_END_NOP)]
   ""
 {
-  if (rs6000_tune == PROCESSOR_POWER6)
-    return "ori 1,1,0";
-  return "ori 2,2,0";
+  operands[0] = gen_rtx_REG (Pmode,
+			     rs6000_tune == PROCESSOR_POWER6 ? 1 : 2);
+  return "ori %0,%0,0";
 })
 
 (define_insn "rs6000_speculation_barrier"
   [(unspec_volatile:BLK [(const_int 0)] UNSPECV_SPEC_BARRIER)]
   ""
-  "ori 31,31,0")
+{
+  operands[0] = gen_rtx_REG (Pmode, 31);
+  return "ori %0,%0,0";
+})
 
 ;; Define the subtract-one-and-jump insns, starting with the template
 ;; so loop.c knows what to generate.
@@ -12699,7 +12702,7 @@
 				const0_rtx);
   emit_insn (gen_rtx_SET (operands[3],
 			  gen_rtx_COMPARE (CCmode, operands[1], const1_rtx)));
-  if (gpc_reg_operand (operands[0], <MODE>mode))
+  if (int_reg_operand (operands[0], <MODE>mode))
     emit_insn (gen_add<mode>3 (operands[0], operands[1], constm1_rtx));
   else
     {
@@ -12768,7 +12771,7 @@
 		       (const_int 0)]))
 	  (match_operand 4)
 	  (match_operand 5)))
-   (set (match_operand:P 6 "int_reg_operand")
+   (set (match_operand:P 6 "nonimmediate_operand")
 	(plus:P (match_dup 0)
 		(const_int -1)))
    (clobber (match_scratch:P 7))
@@ -12801,7 +12804,7 @@
   else
      emit_insn (gen_cceq_ior_compare_complement (operands[9], andexpr, ctrcmpcc,
 						 operands[8], cccmp, ccin));
-  if (gpc_reg_operand (operands[0], <MODE>mode))
+  if (int_reg_operand (ctrout, <MODE>mode))
      emit_insn (gen_add<mode>3 (ctrout, ctr, constm1_rtx));
   else
     {
Index: gcc/config/rs6000/altivec.h
===================================================================
--- a/src/gcc/config/rs6000/altivec.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/rs6000/altivec.h	(.../branches/gcc-8-branch)
@@ -418,6 +418,11 @@
 #define vec_vupkhsw __builtin_vec_vupkhsw
 #define vec_vupklsw __builtin_vec_vupklsw
 #define vec_revb __builtin_vec_revb
+#define vec_sbox_be __builtin_crypto_vsbox_be
+#define vec_cipher_be __builtin_crypto_vcipher_be
+#define vec_cipherlast_be __builtin_crypto_vcipherlast_be
+#define vec_ncipher_be __builtin_crypto_vncipher_be
+#define vec_ncipherlast_be __builtin_crypto_vncipherlast_be
 #endif
 
 #ifdef __POWER9_VECTOR__
Index: gcc/config/darwin.h
===================================================================
--- a/src/gcc/config/darwin.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/darwin.h	(.../branches/gcc-8-branch)
@@ -178,7 +178,7 @@
     %(linker)" \
     LINK_PLUGIN_SPEC \
     "%{flto*:%<fcompare-debug*} \
-    %{flto*} \
+     %{flto} %{fno-lto} %{flto=*} \
     %l " LINK_COMPRESS_DEBUG_SPEC \
    "%X %{s} %{t} %{Z} %{u*} \
     %{e*} %{r} \
Index: gcc/config/arm/arm.c
===================================================================
--- a/src/gcc/config/arm/arm.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/arm/arm.c	(.../branches/gcc-8-branch)
@@ -8879,11 +8879,16 @@
 arm_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)
 {
   rtx base, offset;
+  split_const (x, &base, &offset);
 
-  if (ARM_OFFSETS_MUST_BE_WITHIN_SECTIONS_P)
+  if (SYMBOL_REF_P (base))
     {
-      split_const (x, &base, &offset);
-      if (GET_CODE (base) == SYMBOL_REF
+      /* Function symbols cannot have an offset due to the Thumb bit.  */
+      if ((SYMBOL_REF_FLAGS (base) & SYMBOL_FLAG_FUNCTION)
+	  && INTVAL (offset) != 0)
+	return true;
+
+      if (ARM_OFFSETS_MUST_BE_WITHIN_SECTIONS_P
 	  && !offset_within_block_p (base, INTVAL (offset)))
 	return true;
     }
@@ -11930,8 +11935,7 @@
   else
     {
       n_elts = 1;
-      if (mode == VOIDmode)
-	mode = DImode;
+      gcc_assert (mode != VOIDmode);
     }
 
   innersize = GET_MODE_UNIT_SIZE (mode);
@@ -13095,6 +13099,9 @@
   if (load && (REGNO (reg) == SP_REGNUM) && (REGNO (addr) != SP_REGNUM))
     return false;
 
+  if (regno == REGNO (addr))
+    addr_reg_in_reglist = true;
+
   for (; i < count; i++)
     {
       elt = XVECEXP (op, 0, i);
@@ -13289,7 +13296,6 @@
   int unsorted_regs[MAX_LDM_STM_OPS];
   HOST_WIDE_INT unsorted_offsets[MAX_LDM_STM_OPS];
   int order[MAX_LDM_STM_OPS];
-  rtx base_reg_rtx = NULL;
   int base_reg = -1;
   int i, ldm_case;
 
@@ -13334,7 +13340,6 @@
 	  if (i == 0)
 	    {
 	      base_reg = REGNO (reg);
-	      base_reg_rtx = reg;
 	      if (TARGET_THUMB1 && base_reg > LAST_LO_REGNUM)
 		return 0;
 	    }
@@ -13393,10 +13398,6 @@
       *load_offset = unsorted_offsets[order[0]];
     }
 
-  if (TARGET_THUMB1
-      && !peep2_reg_dead_p (nops, base_reg_rtx))
-    return 0;
-
   if (unsorted_offsets[order[0]] == 0)
     ldm_case = 1; /* ldmia */
   else if (TARGET_ARM && unsorted_offsets[order[0]] == 4)
@@ -13772,9 +13773,17 @@
 
   if (TARGET_THUMB1)
     {
-      gcc_assert (peep2_reg_dead_p (nops, base_reg_rtx));
       gcc_assert (ldm_case == 1 || ldm_case == 5);
-      write_back = TRUE;
+
+      /* Thumb-1 ldm uses writeback except if the base is loaded.  */
+      write_back = true;
+      for (i = 0; i < nops; i++)
+	if (base_reg == regs[i])
+	  write_back = false;
+
+      /* Ensure the base is dead if it is updated.  */
+      if (write_back && !peep2_reg_dead_p (nops, base_reg_rtx))
+	return false;
     }
 
   if (ldm_case == 5)
@@ -13782,8 +13791,7 @@
       rtx newbase = TARGET_THUMB1 ? base_reg_rtx : gen_rtx_REG (SImode, regs[0]);
       emit_insn (gen_addsi3 (newbase, base_reg_rtx, GEN_INT (offset)));
       offset = 0;
-      if (!TARGET_THUMB1)
-	base_reg_rtx = newbase;
+      base_reg_rtx = newbase;
     }
 
   for (i = 0; i < nops; i++)
Index: gcc/config/arm/arm.h
===================================================================
--- a/src/gcc/config/arm/arm.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/arm/arm.h	(.../branches/gcc-8-branch)
@@ -191,7 +191,7 @@
 /* FPU supports converting between HFmode and DFmode in a single hardware
    step.  */
 #define TARGET_FP16_TO_DOUBLE						\
-  (TARGET_HARD_FLOAT && (TARGET_FP16 && TARGET_VFP5))
+  (TARGET_HARD_FLOAT && TARGET_FP16 && TARGET_VFP5 && TARGET_VFP_DOUBLE)
 
 /* FPU supports fused-multiply-add operations.  */
 #define TARGET_FMA (bitmap_bit_p (arm_active_target.isa, isa_bit_vfpv4))
Index: gcc/config/arm/neon.md
===================================================================
--- a/src/gcc/config/arm/neon.md	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/arm/neon.md	(.../branches/gcc-8-branch)
@@ -25,14 +25,14 @@
 
 (define_insn "*neon_mov<mode>"
   [(set (match_operand:VDX 0 "nonimmediate_operand"
-	  "=w,Un,w, w,  ?r,?w,?r,?r, ?Us")
+	  "=w,Un,w, w, w,  ?r,?w,?r,?r, ?Us")
 	(match_operand:VDX 1 "general_operand"
-	  " w,w, Dn,Uni, w, r, r, Usi,r"))]
+	  " w,w, Dm,Dn,Uni, w, r, r, Usi,r"))]
   "TARGET_NEON
    && (register_operand (operands[0], <MODE>mode)
        || register_operand (operands[1], <MODE>mode))"
 {
-  if (which_alternative == 2)
+  if (which_alternative == 2 || which_alternative == 3)
     {
       int width, is_valid;
       static char templ[40];
@@ -53,31 +53,32 @@
   switch (which_alternative)
     {
     case 0: return "vmov\t%P0, %P1  @ <mode>";
-    case 1: case 3: return output_move_neon (operands);
-    case 2: gcc_unreachable ();
-    case 4: return "vmov\t%Q0, %R0, %P1  @ <mode>";
-    case 5: return "vmov\t%P0, %Q1, %R1  @ <mode>";
+    case 1: case 4: return output_move_neon (operands);
+    case 2: case 3: gcc_unreachable ();
+    case 5: return "vmov\t%Q0, %R0, %P1  @ <mode>";
+    case 6: return "vmov\t%P0, %Q1, %R1  @ <mode>";
     default: return output_move_double (operands, true, NULL);
     }
 }
  [(set_attr "type" "neon_move<q>,neon_store1_1reg,neon_move<q>,\
-                    neon_load1_1reg, neon_to_gp<q>,neon_from_gp<q>,mov_reg,\
-                    neon_load1_2reg, neon_store1_2reg")
-  (set_attr "length" "4,4,4,4,4,4,8,8,8")
-  (set_attr "arm_pool_range"     "*,*,*,1020,*,*,*,1020,*")
-  (set_attr "thumb2_pool_range"     "*,*,*,1018,*,*,*,1018,*")
-  (set_attr "neg_pool_range" "*,*,*,1004,*,*,*,1004,*")])
+                    neon_move<q>,neon_load1_1reg, neon_to_gp<q>,\
+		    neon_from_gp<q>,mov_reg,neon_load1_2reg,\
+		    neon_store1_2reg")
+  (set_attr "length" "4,4,4,4,4,4,4,8,8,8")
+  (set_attr "arm_pool_range"     "*,*,*,*,1020,*,*,*,1020,*")
+  (set_attr "thumb2_pool_range"     "*,*,*,*,1018,*,*,*,1018,*")
+  (set_attr "neg_pool_range" "*,*,*,*,1004,*,*,*,1004,*")])
 
 (define_insn "*neon_mov<mode>"
   [(set (match_operand:VQXMOV 0 "nonimmediate_operand"
-  	  "=w,Un,w, w,  ?r,?w,?r,?r,  ?Us")
+	  "=w,Un,w, w, w,  ?r,?w,?r,?r,  ?Us")
 	(match_operand:VQXMOV 1 "general_operand"
-	  " w,w, Dn,Uni, w, r, r, Usi, r"))]
+	  " w,w, Dm,DN,Uni, w, r, r, Usi, r"))]
   "TARGET_NEON
    && (register_operand (operands[0], <MODE>mode)
        || register_operand (operands[1], <MODE>mode))"
 {
-  if (which_alternative == 2)
+  if (which_alternative == 2 || which_alternative == 3)
     {
       int width, is_valid;
       static char templ[40];
@@ -98,20 +99,20 @@
   switch (which_alternative)
     {
     case 0: return "vmov\t%q0, %q1  @ <mode>";
-    case 1: case 3: return output_move_neon (operands);
-    case 2: gcc_unreachable ();
-    case 4: return "vmov\t%Q0, %R0, %e1  @ <mode>\;vmov\t%J0, %K0, %f1";
-    case 5: return "vmov\t%e0, %Q1, %R1  @ <mode>\;vmov\t%f0, %J1, %K1";
+    case 1: case 4: return output_move_neon (operands);
+    case 2: case 3: gcc_unreachable ();
+    case 5: return "vmov\t%Q0, %R0, %e1  @ <mode>\;vmov\t%J0, %K0, %f1";
+    case 6: return "vmov\t%e0, %Q1, %R1  @ <mode>\;vmov\t%f0, %J1, %K1";
     default: return output_move_quad (operands);
     }
 }
   [(set_attr "type" "neon_move_q,neon_store2_2reg_q,neon_move_q,\
-                     neon_load2_2reg_q,neon_to_gp_q,neon_from_gp_q,\
-                     mov_reg,neon_load1_4reg,neon_store1_4reg")
-   (set_attr "length" "4,8,4,8,8,8,16,8,16")
-   (set_attr "arm_pool_range" "*,*,*,1020,*,*,*,1020,*")
-   (set_attr "thumb2_pool_range" "*,*,*,1018,*,*,*,1018,*")
-   (set_attr "neg_pool_range" "*,*,*,996,*,*,*,996,*")])
+                     neon_move_q,neon_load2_2reg_q,neon_to_gp_q,\
+                     neon_from_gp_q,mov_reg,neon_load1_4reg,neon_store1_4reg")
+   (set_attr "length" "4,8,4,4,8,8,8,16,8,16")
+   (set_attr "arm_pool_range" "*,*,*,*,1020,*,*,*,1020,*")
+   (set_attr "thumb2_pool_range" "*,*,*,*,1018,*,*,*,1018,*")
+   (set_attr "neg_pool_range" "*,*,*,*,996,*,*,*,996,*")])
 
 /* We define these mov expanders to match the standard mov$a optab to prevent
    the mid-end from trying to do a subreg for these modes which is the most
@@ -1033,7 +1034,7 @@
 (define_insn "vashl<mode>3"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w,w")
 	(ashift:VDQIW (match_operand:VDQIW 1 "s_register_operand" "w,w")
-		      (match_operand:VDQIW 2 "imm_lshift_or_reg_neon" "w,Dn")))]
+		      (match_operand:VDQIW 2 "imm_lshift_or_reg_neon" "w,Dm")))]
   "TARGET_NEON"
   {
     switch (which_alternative)
@@ -1052,7 +1053,7 @@
 (define_insn "vashr<mode>3_imm"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
 	(ashiftrt:VDQIW (match_operand:VDQIW 1 "s_register_operand" "w")
-			(match_operand:VDQIW 2 "imm_for_neon_rshift_operand" "Dn")))]
+			(match_operand:VDQIW 2 "imm_for_neon_rshift_operand" "Dm")))]
   "TARGET_NEON"
   {
     return neon_output_shift_immediate ("vshr", 's', &operands[2],
@@ -1065,7 +1066,7 @@
 (define_insn "vlshr<mode>3_imm"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
 	(lshiftrt:VDQIW (match_operand:VDQIW 1 "s_register_operand" "w")
-			(match_operand:VDQIW 2 "imm_for_neon_rshift_operand" "Dn")))]
+			(match_operand:VDQIW 2 "imm_for_neon_rshift_operand" "Dm")))]
   "TARGET_NEON"
   {
     return neon_output_shift_immediate ("vshr", 'u', &operands[2],
Index: gcc/config/arm/constraints.md
===================================================================
--- a/src/gcc/config/arm/constraints.md	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/arm/constraints.md	(.../branches/gcc-8-branch)
@@ -31,7 +31,8 @@
 ;; 'H' was previously used for FPA.
 
 ;; The following multi-letter normal constraints have been used:
-;; in ARM/Thumb-2 state: Da, Db, Dc, Dd, Dn, Dl, DL, Do, Dv, Dy, Di, Dt, Dp, Dz
+;; in ARM/Thumb-2 state: Da, Db, Dc, Dd, Dn, DN, Dm, Dl, DL, Do, Dv, Dy, Di,
+;;			 Dt, Dp, Dz
 ;; in Thumb-1 state: Pa, Pb, Pc, Pd, Pe
 ;; in Thumb-2 state: Pj, PJ, Ps, Pt, Pu, Pv, Pw, Px, Py
 ;; in all states: Pf
@@ -294,14 +295,28 @@
  (and (match_code "const_double,const_int")
       (match_test "TARGET_32BIT && arm_const_double_by_immediates (op)")))
 
-(define_constraint "Dn"
+(define_constraint "Dm"
  "@internal
-  In ARM/Thumb-2 state a const_vector or const_int which can be loaded with a
-  Neon vmov immediate instruction."
- (and (match_code "const_vector,const_int")
+  In ARM/Thumb-2 state a const_vector which can be loaded with a Neon vmov
+  immediate instruction."
+ (and (match_code "const_vector")
       (match_test "TARGET_32BIT
 		   && imm_for_neon_mov_operand (op, GET_MODE (op))")))
 
+(define_constraint "Dn"
+ "@internal
+  In ARM/Thumb-2 state a DImode const_int which can be loaded with a Neon vmov
+  immediate instruction."
+ (and (match_code "const_int")
+      (match_test "TARGET_32BIT && imm_for_neon_mov_operand (op, DImode)")))
+
+(define_constraint "DN"
+ "@internal
+  In ARM/Thumb-2 state a TImode const_int which can be loaded with a Neon vmov
+  immediate instruction."
+ (and (match_code "const_int")
+      (match_test "TARGET_32BIT && imm_for_neon_mov_operand (op, TImode)")))
+
 (define_constraint "Dl"
  "@internal
   In ARM/Thumb-2 state a const_vector which can be used with a Neon vorr or
Index: gcc/config/arm/t-rtems
===================================================================
--- a/src/gcc/config/arm/t-rtems	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/arm/t-rtems	(.../branches/gcc-8-branch)
@@ -17,8 +17,8 @@
 MULTILIB_OPTIONS	+= mthumb
 MULTILIB_DIRNAMES	+= thumb
 
-MULTILIB_OPTIONS	+= march=armv5te+fp/march=armv6-m/march=armv7-a/march=armv7-a+simd/march=armv7-r/march=armv7-r+fp/march=armv7-m/march=armv7e-m+fp/march=armv7e-m+fp.dp
-MULTILIB_DIRNAMES	+= armv5te+fp       armv6-m       armv7-a       armv7-a+simd       armv7-r       armv7-r+fp       armv7-m       armv7e-m+fp        armv7e-m+fp.dp
+MULTILIB_OPTIONS	+= march=armv5te+fp/march=armv6-m/march=armv7-a/march=armv7-a+simd/march=armv7-r/march=armv7-r+fp/mcpu=cortex-m3/mcpu=cortex-m4/mcpu=cortex-m4+nofp/mcpu=cortex-m7
+MULTILIB_DIRNAMES	+= armv5te+fp       armv6-m       armv7-a       armv7-a+simd       armv7-r       armv7-r+fp       cortex-m3      cortex-m4      cortex-m4+nofp      cortex-m7
 
 MULTILIB_OPTIONS	+= mfloat-abi=hard
 MULTILIB_DIRNAMES	+= hard
@@ -31,7 +31,8 @@
 MULTILIB_REQUIRED	+= mthumb/march=armv7-a
 MULTILIB_REQUIRED	+= mthumb/march=armv7-r+fp/mfloat-abi=hard
 MULTILIB_REQUIRED	+= mthumb/march=armv7-r
-MULTILIB_REQUIRED	+= mthumb/march=armv7e-m+fp/mfloat-abi=hard
-MULTILIB_REQUIRED	+= mthumb/march=armv7e-m+fp.dp/mfloat-abi=hard
-MULTILIB_REQUIRED	+= mthumb/march=armv7-m
+MULTILIB_REQUIRED	+= mthumb/mcpu=cortex-m3
+MULTILIB_REQUIRED	+= mthumb/mcpu=cortex-m4/mfloat-abi=hard
+MULTILIB_REQUIRED	+= mthumb/mcpu=cortex-m4+nofp
+MULTILIB_REQUIRED	+= mthumb/mcpu=cortex-m7/mfloat-abi=hard
 MULTILIB_REQUIRED	+= mthumb
Index: gcc/config/arm/arm.md
===================================================================
--- a/src/gcc/config/arm/arm.md	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/arm/arm.md	(.../branches/gcc-8-branch)
@@ -5976,52 +5976,29 @@
         }
     }
 
-  if (ARM_OFFSETS_MUST_BE_WITHIN_SECTIONS_P)
+  split_const (operands[1], &base, &offset);
+  if (INTVAL (offset) != 0
+      && targetm.cannot_force_const_mem (SImode, operands[1]))
     {
-      split_const (operands[1], &base, &offset);
-      if (GET_CODE (base) == SYMBOL_REF
-	  && !offset_within_block_p (base, INTVAL (offset)))
-	{
-	  tmp = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];
-	  emit_move_insn (tmp, base);
-	  emit_insn (gen_addsi3 (operands[0], tmp, offset));
-	  DONE;
-	}
+      tmp = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];
+      emit_move_insn (tmp, base);
+      emit_insn (gen_addsi3 (operands[0], tmp, offset));
+      DONE;
     }
 
+  tmp = can_create_pseudo_p () ? NULL_RTX : operands[0];
+
   /* Recognize the case where operand[1] is a reference to thread-local
-     data and load its address to a register.  */
+     data and load its address to a register.  Offsets have been split off
+     already.  */
   if (arm_tls_referenced_p (operands[1]))
-    {
-      rtx tmp = operands[1];
-      rtx addend = NULL;
-
-      if (GET_CODE (tmp) == CONST && GET_CODE (XEXP (tmp, 0)) == PLUS)
-        {
-          addend = XEXP (XEXP (tmp, 0), 1);
-          tmp = XEXP (XEXP (tmp, 0), 0);
-        }
-
-      gcc_assert (GET_CODE (tmp) == SYMBOL_REF);
-      gcc_assert (SYMBOL_REF_TLS_MODEL (tmp) != 0);
-
-      tmp = legitimize_tls_address (tmp,
-				    !can_create_pseudo_p () ? operands[0] : 0);
-      if (addend)
-        {
-          tmp = gen_rtx_PLUS (SImode, tmp, addend);
-          tmp = force_operand (tmp, operands[0]);
-        }
-      operands[1] = tmp;
-    }
+    operands[1] = legitimize_tls_address (operands[1], tmp);
   else if (flag_pic
 	   && (CONSTANT_P (operands[1])
 	       || symbol_mentioned_p (operands[1])
 	       || label_mentioned_p (operands[1])))
-      operands[1] = legitimize_pic_address (operands[1], SImode,
-					    (!can_create_pseudo_p ()
-					     ? operands[0]
-					     : 0));
+    operands[1] =
+      legitimize_pic_address (operands[1], SImode, tmp);
   }
   "
 )
Index: gcc/config/pa/pa.md
===================================================================
--- a/src/gcc/config/pa/pa.md	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/pa/pa.md	(.../branches/gcc-8-branch)
@@ -5319,8 +5319,8 @@
 
 (define_insn "umulsidi3"
   [(set (match_operand:DI 0 "register_operand" "=f")
-	(mult:DI (zero_extend:DI (match_operand:SI 1 "nonimmediate_operand" "f"))
-		 (zero_extend:DI (match_operand:SI 2 "nonimmediate_operand" "f"))))]
+	(mult:DI (zero_extend:DI (match_operand:SI 1 "register_operand" "f"))
+		 (zero_extend:DI (match_operand:SI 2 "register_operand" "f"))))]
   "TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT"
   "xmpyu %1,%2,%0"
   [(set_attr "type" "fpmuldbl")
@@ -5328,7 +5328,7 @@
 
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=f")
-	(mult:DI (zero_extend:DI (match_operand:SI 1 "nonimmediate_operand" "f"))
+	(mult:DI (zero_extend:DI (match_operand:SI 1 "register_operand" "f"))
 		 (match_operand:DI 2 "uint32_operand" "f")))]
   "TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT && !TARGET_64BIT"
   "xmpyu %1,%R2,%0"
@@ -5337,7 +5337,7 @@
 
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=f")
-	(mult:DI (zero_extend:DI (match_operand:SI 1 "nonimmediate_operand" "f"))
+	(mult:DI (zero_extend:DI (match_operand:SI 1 "register_operand" "f"))
 		 (match_operand:DI 2 "uint32_operand" "f")))]
   "TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT && TARGET_64BIT"
   "xmpyu %1,%2R,%0"
@@ -6904,21 +6904,24 @@
   rtx stack = operands[2];
   rtx fp = operands[3];
 
-  lab = copy_to_reg (lab);
-
   emit_clobber (gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode)));
   emit_clobber (gen_rtx_MEM (BLKmode, hard_frame_pointer_rtx));
 
-  /* Restore the frame pointer.  The virtual_stack_vars_rtx is saved
-     instead of the hard_frame_pointer_rtx in the save area.  As a
-     result, an extra instruction is needed to adjust for the offset
+  lab = copy_to_reg (lab);
+
+  /* Restore the stack and frame pointers.  The virtual_stack_vars_rtx
+     is saved instead of the hard_frame_pointer_rtx in the save area.
+     As a result, an extra instruction is needed to adjust for the offset
      of the virtual stack variables and the hard frame pointer.  */
-  if (GET_CODE (fp) != REG)
-    fp = force_reg (Pmode, fp);
+  fp = copy_to_reg (fp);
+  emit_stack_restore (SAVE_NONLOCAL, stack);
+
+  /* Ensure the frame pointer move is not optimized.  */
+  emit_insn (gen_blockage ());
+  emit_clobber (hard_frame_pointer_rtx);
+  emit_clobber (frame_pointer_rtx);
   emit_move_insn (hard_frame_pointer_rtx, plus_constant (Pmode, fp, -8));
 
-  emit_stack_restore (SAVE_NONLOCAL, stack);
-
   emit_use (hard_frame_pointer_rtx);
   emit_use (stack_pointer_rtx);
 
@@ -8695,23 +8698,26 @@
   emit_clobber (gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode)));
   emit_clobber (gen_rtx_MEM (BLKmode, hard_frame_pointer_rtx));
 
-  /* Restore the frame pointer.  The virtual_stack_vars_rtx is saved
-     instead of the hard_frame_pointer_rtx in the save area.  We need
-     to adjust for the offset between these two values.  */
-  if (GET_CODE (fp) != REG)
-    fp = force_reg (Pmode, fp);
+  /* Load the label we are jumping through into r1 so that we know
+     where to look for it when we get back to setjmp's function for
+     restoring the gp.  */
+  emit_move_insn (pv, lab);
+
+  /* Restore the stack and frame pointers.  The virtual_stack_vars_rtx
+     is saved instead of the hard_frame_pointer_rtx in the save area.
+     We need to adjust for the offset between these two values.  */
+  fp = copy_to_reg (fp);
+  emit_stack_restore (SAVE_NONLOCAL, stack);
+
+  /* Ensure the frame pointer move is not optimized.  */
+  emit_insn (gen_blockage ());
+  emit_clobber (hard_frame_pointer_rtx);
+  emit_clobber (frame_pointer_rtx);
   emit_move_insn (hard_frame_pointer_rtx, plus_constant (Pmode, fp, -8));
 
-  /* This bit is the same as expand_builtin_longjmp.  */
-  emit_stack_restore (SAVE_NONLOCAL, stack);
   emit_use (hard_frame_pointer_rtx);
   emit_use (stack_pointer_rtx);
 
-  /* Load the label we are jumping through into r1 so that we know
-     where to look for it when we get back to setjmp's function for
-     restoring the gp.  */
-  emit_move_insn (pv, lab);
-
   /* Prevent the insns above from being scheduled into the delay slot
      of the interspace jump because the space register could change.  */
   emit_insn (gen_blockage ());
Index: gcc/config/pa/pa-protos.h
===================================================================
--- a/src/gcc/config/pa/pa-protos.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/pa/pa-protos.h	(.../branches/gcc-8-branch)
@@ -108,5 +108,6 @@
 extern void pa_hpux_asm_output_external (FILE *, tree, const char *);
 extern HOST_WIDE_INT pa_initial_elimination_offset (int, int);
 extern HOST_WIDE_INT pa_function_arg_size (machine_mode, const_tree);
+extern void pa_output_function_label (FILE *);
 
 extern const int pa_magic_milli[];
Index: gcc/config/pa/pa.c
===================================================================
--- a/src/gcc/config/pa/pa.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/pa/pa.c	(.../branches/gcc-8-branch)
@@ -118,7 +118,8 @@
 static rtx pa_function_value (const_tree, const_tree, bool);
 static rtx pa_libcall_value (machine_mode, const_rtx);
 static bool pa_function_value_regno_p (const unsigned int);
-static void pa_output_function_prologue (FILE *);
+static void pa_output_function_prologue (FILE *) ATTRIBUTE_UNUSED;
+static void pa_linux_output_function_prologue (FILE *) ATTRIBUTE_UNUSED;
 static void update_total_code_bytes (unsigned int);
 static void pa_output_function_epilogue (FILE *);
 static int pa_adjust_cost (rtx_insn *, int, rtx_insn *, int, unsigned int);
@@ -263,8 +264,6 @@
 #undef TARGET_ASM_INTEGER
 #define TARGET_ASM_INTEGER pa_assemble_integer
 
-#undef TARGET_ASM_FUNCTION_PROLOGUE
-#define TARGET_ASM_FUNCTION_PROLOGUE pa_output_function_prologue
 #undef TARGET_ASM_FUNCTION_EPILOGUE
 #define TARGET_ASM_FUNCTION_EPILOGUE pa_output_function_epilogue
 
@@ -3842,16 +3841,10 @@
 	  & ~(PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT - 1));
 }
 
-/* On HP-PA, move-double insns between fpu and cpu need an 8-byte block
-   of memory.  If any fpu reg is used in the function, we allocate
-   such a block here, at the bottom of the frame, just in case it's needed.
+/* Output function label, and associated .PROC and .CALLINFO statements.  */
 
-   If this function is a leaf procedure, then we may choose not
-   to do a "save" insn.  The decision about whether or not
-   to do this is made in regclass.c.  */
-
-static void
-pa_output_function_prologue (FILE *file)
+void
+pa_output_function_label (FILE *file)
 {
   /* The function's label and associated .PROC must never be
      separated and must be output *after* any profiling declarations
@@ -3897,10 +3890,25 @@
     fprintf (file, ",ENTRY_FR=%d", fr_saved + 11);
 
   fputs ("\n\t.ENTRY\n", file);
+}
 
+/* Output function prologue.  */
+
+static void
+pa_output_function_prologue (FILE *file)
+{
+  pa_output_function_label (file);
   remove_useless_addtr_insns (0);
 }
 
+/* The label is output by ASM_DECLARE_FUNCTION_NAME on linux.  */
+
+static void
+pa_linux_output_function_prologue (FILE *file ATTRIBUTE_UNUSED)
+{
+  remove_useless_addtr_insns (0);
+}
+
 void
 pa_expand_prologue (void)
 {
@@ -4569,10 +4577,6 @@
 void
 hppa_profile_hook (int label_no)
 {
-  /* We use SImode for the address of the function in both 32 and
-     64-bit code to avoid having to provide DImode versions of the
-     lcla2 and load_offset_label_address insn patterns.  */
-  rtx reg = gen_reg_rtx (SImode);
   rtx_code_label *label_rtx = gen_label_rtx ();
   int reg_parm_stack_space = REG_PARM_STACK_SPACE (NULL_TREE);
   rtx arg_bytes, begin_label_rtx, mcount, sym;
@@ -4604,18 +4608,13 @@
   if (!use_mcount_pcrel_call)
     {
       /* The address of the function is loaded into %r25 with an instruction-
-	 relative sequence that avoids the use of relocations.  The sequence
-	 is split so that the load_offset_label_address instruction can
-	 occupy the delay slot of the call to _mcount.  */
+	 relative sequence that avoids the use of relocations.  We use SImode
+	 for the address of the function in both 32 and 64-bit code to avoid
+	 having to provide DImode versions of the lcla2 pattern.  */
       if (TARGET_PA_20)
-	emit_insn (gen_lcla2 (reg, label_rtx));
+	emit_insn (gen_lcla2 (gen_rtx_REG (SImode, 25), label_rtx));
       else
-	emit_insn (gen_lcla1 (reg, label_rtx));
-
-      emit_insn (gen_load_offset_label_address (gen_rtx_REG (SImode, 25), 
-						reg,
-						begin_label_rtx,
-						label_rtx));
+	emit_insn (gen_lcla1 (gen_rtx_REG (SImode, 25), label_rtx));
     }
 
   if (!NO_DEFERRED_PROFILE_COUNTERS)
@@ -10039,10 +10038,11 @@
   /* There is no way to load QImode or HImode values directly from memory
      to a FP register.  SImode loads to the FP registers are not zero
      extended.  On the 64-bit target, this conflicts with the definition
-     of LOAD_EXTEND_OP.  Thus, we can't allow changing between modes with
-     different sizes in the floating-point registers.  */
+     of LOAD_EXTEND_OP.  Thus, we reject all mode changes in the FP registers
+     except for DImode to SImode on the 64-bit target.  It is handled by
+     register renaming in pa_print_operand.  */
   if (MAYBE_FP_REG_CLASS_P (rclass))
-    return false;
+    return TARGET_64BIT && from == DImode && to == SImode;
 
   /* TARGET_HARD_REGNO_MODE_OK places modes with sizes larger than a word
      in specific sets of registers.  Thus, we cannot allow changing
Index: gcc/config/pa/pa-linux.h
===================================================================
--- a/src/gcc/config/pa/pa-linux.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/pa/pa-linux.h	(.../branches/gcc-8-branch)
@@ -101,7 +101,7 @@
 
 /* FIXME: Hacked from the <elfos.h> one so that we avoid multiple
    labels in a function declaration (since pa.c seems determined to do
-   it differently)  */
+   it differently).  */
 
 #undef ASM_DECLARE_FUNCTION_NAME
 #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)		\
@@ -109,9 +109,14 @@
     {								\
       ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, "function");	\
       ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));		\
+      pa_output_function_label (FILE);				\
     }								\
   while (0)
 
+/* Output function prologue for linux.  */
+#undef TARGET_ASM_FUNCTION_PROLOGUE
+#define TARGET_ASM_FUNCTION_PROLOGUE pa_linux_output_function_prologue
+
 /* As well as globalizing the label, we need to encode the label
    to ensure a plabel is generated in an indirect call.  */
 
Index: gcc/config/pa/pa.h
===================================================================
--- a/src/gcc/config/pa/pa.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/pa/pa.h	(.../branches/gcc-8-branch)
@@ -1302,3 +1302,6 @@
   (flag_pic ? (TARGET_HPUX ? 198164 : 221312) : 240000)
 
 #define NEED_INDICATE_EXEC_STACK 0
+
+/* Output default function prologue for hpux.  */
+#define TARGET_ASM_FUNCTION_PROLOGUE pa_output_function_prologue
Index: gcc/config/mips/mips.c
===================================================================
--- a/src/gcc/config/mips/mips.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/config/mips/mips.c	(.../branches/gcc-8-branch)
@@ -9532,7 +9532,7 @@
 {
   machine_mode mode = default_dwarf_frame_reg_mode (regno);
 
-  if (FP_REG_P (regno) && mips_abi == ABI_32 && TARGET_FLOAT64)
+  if (FP_REG_P (regno) && mips_abi == ABI_32 && !TARGET_FLOAT32)
     mode = SImode;
 
   return mode;
@@ -16788,6 +16788,19 @@
       std::swap (ops[1], ops[2]);
       break;
 
+    case CODE_FOR_msa_maddv_b:
+    case CODE_FOR_msa_maddv_h:
+    case CODE_FOR_msa_maddv_w:
+    case CODE_FOR_msa_maddv_d:
+    case CODE_FOR_msa_fmadd_w:
+    case CODE_FOR_msa_fmadd_d:
+    case CODE_FOR_msa_fmsub_w:
+    case CODE_FOR_msa_fmsub_d:
+      /* fma(a, b, c) results into (a * b + c), however builtin_msa_fmadd expects
+	 it to be (a + b * c).  Swap the 1st and 3rd operands.  */
+      std::swap (ops[1], ops[3]);
+      break;
+
     case CODE_FOR_msa_slli_b:
     case CODE_FOR_msa_slli_h:
     case CODE_FOR_msa_slli_w:
Index: gcc/dce.c
===================================================================
--- a/src/gcc/dce.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/dce.c	(.../branches/gcc-8-branch)
@@ -35,6 +35,7 @@
 #include "valtrack.h"
 #include "tree-pass.h"
 #include "dbgcnt.h"
+#include "rtl-iter.h"
 
 
 /* -------------------------------------------------------------------------
@@ -86,7 +87,33 @@
     }
 }
 
+/* Don't delete calls that may throw if we cannot do so.  */
 
+static bool
+can_delete_call (rtx_insn *insn)
+{
+  if (cfun->can_delete_dead_exceptions && can_alter_cfg)
+    return true;
+  if (!insn_nothrow_p (insn))
+    return false;
+  if (can_alter_cfg)
+    return true;
+  /* If we can't alter cfg, even when the call can't throw exceptions, it
+     might have EDGE_ABNORMAL_CALL edges and so we shouldn't delete such
+     calls.  */
+  gcc_assert (CALL_P (insn));
+  if (BLOCK_FOR_INSN (insn) && BB_END (BLOCK_FOR_INSN (insn)) == insn)
+    {
+      edge e;
+      edge_iterator ei;
+
+      FOR_EACH_EDGE (e, ei, BLOCK_FOR_INSN (insn)->succs)
+	if ((e->flags & EDGE_ABNORMAL_CALL) != 0)
+	  return false;
+    }
+  return true;
+}
+
 /* Return true if INSN is a normal instruction that can be deleted by
    the DCE pass.  */
 
@@ -110,8 +137,7 @@
       && (RTL_CONST_OR_PURE_CALL_P (insn)
 	  && !RTL_LOOPING_CONST_OR_PURE_CALL_P (insn))
       /* Don't delete calls that may throw if we cannot do so.  */
-      && ((cfun->can_delete_dead_exceptions && can_alter_cfg)
-	  || insn_nothrow_p (insn)))
+      && can_delete_call (insn))
     return find_call_stack_args (as_a <rtx_call_insn *> (insn), false,
 				 fast, arg_stores);
 
@@ -204,8 +230,7 @@
 	  && !SIBLING_CALL_P (insn)
 	  && (RTL_CONST_OR_PURE_CALL_P (insn)
 	      && !RTL_LOOPING_CONST_OR_PURE_CALL_P (insn))
-	  && ((cfun->can_delete_dead_exceptions && can_alter_cfg)
-	      || insn_nothrow_p (insn)))
+	  && can_delete_call (insn))
 	find_call_stack_args (as_a <rtx_call_insn *> (insn), true, fast, NULL);
     }
 }
@@ -265,7 +290,101 @@
   return true;
 }
 
+/* If MEM has sp address, return 0, if it has sp + const address,
+   return that const, if it has reg address where reg is set to sp + const
+   and FAST is false, return const, otherwise return
+   INTTYPE_MINUMUM (HOST_WIDE_INT).  */
 
+static HOST_WIDE_INT
+sp_based_mem_offset (rtx_call_insn *call_insn, const_rtx mem, bool fast)
+{
+  HOST_WIDE_INT off = 0;
+  rtx addr = XEXP (mem, 0);
+  if (GET_CODE (addr) == PLUS
+      && REG_P (XEXP (addr, 0))
+      && CONST_INT_P (XEXP (addr, 1)))
+    {
+      off = INTVAL (XEXP (addr, 1));
+      addr = XEXP (addr, 0);
+    }
+  if (addr == stack_pointer_rtx)
+    return off;
+
+  if (!REG_P (addr) || fast)
+    return INTTYPE_MINIMUM (HOST_WIDE_INT);
+
+  /* If not fast, use chains to see if addr wasn't set to sp + offset.  */
+  df_ref use;
+  FOR_EACH_INSN_USE (use, call_insn)
+  if (rtx_equal_p (addr, DF_REF_REG (use)))
+    break;
+
+  if (use == NULL)
+    return INTTYPE_MINIMUM (HOST_WIDE_INT);
+
+  struct df_link *defs;
+  for (defs = DF_REF_CHAIN (use); defs; defs = defs->next)
+    if (! DF_REF_IS_ARTIFICIAL (defs->ref))
+      break;
+
+  if (defs == NULL)
+    return INTTYPE_MINIMUM (HOST_WIDE_INT);
+
+  rtx set = single_set (DF_REF_INSN (defs->ref));
+  if (!set)
+    return INTTYPE_MINIMUM (HOST_WIDE_INT);
+
+  if (GET_CODE (SET_SRC (set)) != PLUS
+      || XEXP (SET_SRC (set), 0) != stack_pointer_rtx
+      || !CONST_INT_P (XEXP (SET_SRC (set), 1)))
+    return INTTYPE_MINIMUM (HOST_WIDE_INT);
+
+  off += INTVAL (XEXP (SET_SRC (set), 1));
+  return off;
+}
+
+/* Data for check_argument_load called via note_uses.  */
+struct check_argument_load_data {
+  bitmap sp_bytes;
+  HOST_WIDE_INT min_sp_off, max_sp_off;
+  rtx_call_insn *call_insn;
+  bool fast;
+  bool load_found;
+};
+
+/* Helper function for find_call_stack_args.  Check if there are
+   any loads from the argument slots in between the const/pure call
+   and store to the argument slot, set LOAD_FOUND if any is found.  */
+
+static void
+check_argument_load (rtx *loc, void *data)
+{
+  struct check_argument_load_data *d
+    = (struct check_argument_load_data *) data;
+  subrtx_iterator::array_type array;
+  FOR_EACH_SUBRTX (iter, array, *loc, NONCONST)
+    {
+      const_rtx mem = *iter;
+      HOST_WIDE_INT size;
+      if (MEM_P (mem)
+	  && MEM_SIZE_KNOWN_P (mem)
+	  && MEM_SIZE (mem).is_constant (&size))
+	{
+	  HOST_WIDE_INT off = sp_based_mem_offset (d->call_insn, mem, d->fast);
+	  if (off != INTTYPE_MINIMUM (HOST_WIDE_INT)
+	      && off < d->max_sp_off
+	      && off + size > d->min_sp_off)
+	    for (HOST_WIDE_INT byte = MAX (off, d->min_sp_off);
+		 byte < MIN (off + size, d->max_sp_off); byte++)
+	      if (bitmap_bit_p (d->sp_bytes, byte - d->min_sp_off))
+		{
+		  d->load_found = true;
+		  return;
+		}
+	}
+    }
+}
+
 /* Try to find all stack stores of CALL_INSN arguments if
    ACCUMULATE_OUTGOING_ARGS.  If all stack stores have been found
    and it is therefore safe to eliminate the call, return true,
@@ -302,58 +421,13 @@
     if (GET_CODE (XEXP (p, 0)) == USE
 	&& MEM_P (XEXP (XEXP (p, 0), 0)))
       {
-	rtx mem = XEXP (XEXP (p, 0), 0), addr;
-	HOST_WIDE_INT off = 0, size;
+	rtx mem = XEXP (XEXP (p, 0), 0);
+	HOST_WIDE_INT size;
 	if (!MEM_SIZE_KNOWN_P (mem) || !MEM_SIZE (mem).is_constant (&size))
 	  return false;
-	addr = XEXP (mem, 0);
-	if (GET_CODE (addr) == PLUS
-	    && REG_P (XEXP (addr, 0))
-	    && CONST_INT_P (XEXP (addr, 1)))
-	  {
-	    off = INTVAL (XEXP (addr, 1));
-	    addr = XEXP (addr, 0);
-	  }
-	if (addr != stack_pointer_rtx)
-	  {
-	    if (!REG_P (addr))
-	      return false;
-	    /* If not fast, use chains to see if addr wasn't set to
-	       sp + offset.  */
-	    if (!fast)
-	      {
-		df_ref use;
-		struct df_link *defs;
-		rtx set;
-
-		FOR_EACH_INSN_USE (use, call_insn)
-		  if (rtx_equal_p (addr, DF_REF_REG (use)))
-		    break;
-
-		if (use == NULL)
-		  return false;
-
-		for (defs = DF_REF_CHAIN (use); defs; defs = defs->next)
-		  if (! DF_REF_IS_ARTIFICIAL (defs->ref))
-		    break;
-
-		if (defs == NULL)
-		  return false;
-
-		set = single_set (DF_REF_INSN (defs->ref));
-		if (!set)
-		  return false;
-
-		if (GET_CODE (SET_SRC (set)) != PLUS
-		    || XEXP (SET_SRC (set), 0) != stack_pointer_rtx
-		    || !CONST_INT_P (XEXP (SET_SRC (set), 1)))
-		  return false;
-
-		off += INTVAL (XEXP (SET_SRC (set), 1));
-	      }
-	    else
-	      return false;
-	  }
+	HOST_WIDE_INT off = sp_based_mem_offset (call_insn, mem, fast);
+	if (off == INTTYPE_MINIMUM (HOST_WIDE_INT))
+	  return false;
 	min_sp_off = MIN (min_sp_off, off);
 	max_sp_off = MAX (max_sp_off, off + size);
       }
@@ -369,51 +443,24 @@
     if (GET_CODE (XEXP (p, 0)) == USE
 	&& MEM_P (XEXP (XEXP (p, 0), 0)))
       {
-	rtx mem = XEXP (XEXP (p, 0), 0), addr;
-	HOST_WIDE_INT off = 0, byte, size;
+	rtx mem = XEXP (XEXP (p, 0), 0);
 	/* Checked in the previous iteration.  */
-	size = MEM_SIZE (mem).to_constant ();
-	addr = XEXP (mem, 0);
-	if (GET_CODE (addr) == PLUS
-	    && REG_P (XEXP (addr, 0))
-	    && CONST_INT_P (XEXP (addr, 1)))
-	  {
-	    off = INTVAL (XEXP (addr, 1));
-	    addr = XEXP (addr, 0);
-	  }
-	if (addr != stack_pointer_rtx)
-	  {
-	    df_ref use;
-	    struct df_link *defs;
-	    rtx set;
-
-	    FOR_EACH_INSN_USE (use, call_insn)
-	      if (rtx_equal_p (addr, DF_REF_REG (use)))
-		break;
-
-	    for (defs = DF_REF_CHAIN (use); defs; defs = defs->next)
-	      if (! DF_REF_IS_ARTIFICIAL (defs->ref))
-		break;
-
-	    set = single_set (DF_REF_INSN (defs->ref));
-	    off += INTVAL (XEXP (SET_SRC (set), 1));
-	  }
-	for (byte = off; byte < off + size; byte++)
-	  {
-	    if (!bitmap_set_bit (sp_bytes, byte - min_sp_off))
-	      gcc_unreachable ();
-	  }
+	HOST_WIDE_INT size = MEM_SIZE (mem).to_constant ();
+	HOST_WIDE_INT off = sp_based_mem_offset (call_insn, mem, fast);
+	gcc_checking_assert (off != INTTYPE_MINIMUM (HOST_WIDE_INT));
+	for (HOST_WIDE_INT byte = off; byte < off + size; byte++)
+	  if (!bitmap_set_bit (sp_bytes, byte - min_sp_off))
+	    gcc_unreachable ();
       }
 
   /* Walk backwards, looking for argument stores.  The search stops
-     when seeing another call, sp adjustment or memory store other than
-     argument store.  */
+     when seeing another call, sp adjustment, memory store other than
+     argument store or a read from an argument stack slot.  */
+  struct check_argument_load_data data
+    = { sp_bytes, min_sp_off, max_sp_off, call_insn, fast, false };
   ret = false;
   for (insn = PREV_INSN (call_insn); insn; insn = prev_insn)
     {
-      rtx set, mem, addr;
-      HOST_WIDE_INT off;
-
       if (insn == BB_HEAD (BLOCK_FOR_INSN (call_insn)))
 	prev_insn = NULL;
       else
@@ -425,62 +472,22 @@
       if (!NONDEBUG_INSN_P (insn))
 	continue;
 
-      set = single_set (insn);
+      rtx set = single_set (insn);
       if (!set || SET_DEST (set) == stack_pointer_rtx)
 	break;
 
+      note_uses (&PATTERN (insn), check_argument_load, &data);
+      if (data.load_found)
+	break;
+
       if (!MEM_P (SET_DEST (set)))
 	continue;
 
-      mem = SET_DEST (set);
-      addr = XEXP (mem, 0);
-      off = 0;
-      if (GET_CODE (addr) == PLUS
-	  && REG_P (XEXP (addr, 0))
-	  && CONST_INT_P (XEXP (addr, 1)))
-	{
-	  off = INTVAL (XEXP (addr, 1));
-	  addr = XEXP (addr, 0);
-	}
-      if (addr != stack_pointer_rtx)
-	{
-	  if (!REG_P (addr))
-	    break;
-	  if (!fast)
-	    {
-	      df_ref use;
-	      struct df_link *defs;
-	      rtx set;
+      rtx mem = SET_DEST (set);
+      HOST_WIDE_INT off = sp_based_mem_offset (call_insn, mem, fast);
+      if (off == INTTYPE_MINIMUM (HOST_WIDE_INT))
+	break;
 
-	      FOR_EACH_INSN_USE (use, insn)
-		if (rtx_equal_p (addr, DF_REF_REG (use)))
-		  break;
-
-	      if (use == NULL)
-		break;
-
-	      for (defs = DF_REF_CHAIN (use); defs; defs = defs->next)
-		if (! DF_REF_IS_ARTIFICIAL (defs->ref))
-		  break;
-
-	      if (defs == NULL)
-		break;
-
-	      set = single_set (DF_REF_INSN (defs->ref));
-	      if (!set)
-		break;
-
-	      if (GET_CODE (SET_SRC (set)) != PLUS
-		  || XEXP (SET_SRC (set), 0) != stack_pointer_rtx
-		  || !CONST_INT_P (XEXP (SET_SRC (set), 1)))
-		break;
-
-	      off += INTVAL (XEXP (SET_SRC (set), 1));
-	    }
-	  else
-	    break;
-	}
-
       HOST_WIDE_INT size;
       if (!MEM_SIZE_KNOWN_P (mem)
 	  || !MEM_SIZE (mem).is_constant (&size)
Index: gcc/params.def
===================================================================
--- a/src/gcc/params.def	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/params.def	(.../branches/gcc-8-branch)
@@ -1331,6 +1331,11 @@
 	 "Maximum number of bits for which we avoid creating FMAs.",
 	 0, 0, 512)
 
+DEFPARAM(PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT,
+	 "logical-op-non-short-circuit",
+	 "True if a non-short-circuit operation is optimal.",
+	 -1, -1, 1)
+
 /*
 
 Local variables:
Index: gcc/tree-ssanames.c
===================================================================
--- a/src/gcc/tree-ssanames.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/tree-ssanames.c	(.../branches/gcc-8-branch)
@@ -788,7 +788,12 @@
     {
       /* points-to info is not flow-sensitive.  */
       if (SSA_NAME_PTR_INFO (name))
-	mark_ptr_info_alignment_unknown (SSA_NAME_PTR_INFO (name));
+	{
+	  /* [E]VRP can derive context sensitive alignment info and
+	     non-nullness properties.  We must reset both.  */
+	  mark_ptr_info_alignment_unknown (SSA_NAME_PTR_INFO (name));
+	  SSA_NAME_PTR_INFO (name)->pt.null = 1;
+	}
     }
   else
     SSA_NAME_RANGE_INFO (name) = NULL;
Index: gcc/convert.c
===================================================================
--- a/src/gcc/convert.c	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/convert.c	(.../branches/gcc-8-branch)
@@ -193,12 +193,15 @@
 	  CASE_MATHFN (FABS)
 	  CASE_MATHFN (LOGB)
 #undef CASE_MATHFN
+	    if (call_expr_nargs (expr) != 1
+		|| !SCALAR_FLOAT_TYPE_P (TREE_TYPE (CALL_EXPR_ARG (expr, 0))))
+	      break;
 	    {
 	      tree arg0 = strip_float_extensions (CALL_EXPR_ARG (expr, 0));
 	      tree newtype = type;
 
-	      /* We have (outertype)sqrt((innertype)x).  Choose the wider mode from
-		 the both as the safe type for operation.  */
+	      /* We have (outertype)sqrt((innertype)x).  Choose the wider mode
+		 from the both as the safe type for operation.  */
 	      if (TYPE_PRECISION (TREE_TYPE (arg0)) > TYPE_PRECISION (type))
 		newtype = TREE_TYPE (arg0);
 
@@ -592,7 +595,8 @@
 	CASE_FLT_FN (BUILT_IN_ROUND):
 	CASE_FLT_FN_FLOATN_NX (BUILT_IN_ROUND):
 	  /* Only convert in ISO C99 mode and with -fno-math-errno.  */
-	  if (!targetm.libc_has_function (function_c99_misc) || flag_errno_math)
+	  if (!targetm.libc_has_function (function_c99_misc)
+	      || flag_errno_math)
 	    break;
 	  if (outprec < TYPE_PRECISION (integer_type_node)
 	      || (outprec == TYPE_PRECISION (integer_type_node)
@@ -615,7 +619,8 @@
 	CASE_FLT_FN (BUILT_IN_RINT):
 	CASE_FLT_FN_FLOATN_NX (BUILT_IN_RINT):
 	  /* Only convert in ISO C99 mode and with -fno-math-errno.  */
-	  if (!targetm.libc_has_function (function_c99_misc) || flag_errno_math)
+	  if (!targetm.libc_has_function (function_c99_misc)
+	      || flag_errno_math)
 	    break;
 	  if (outprec < TYPE_PRECISION (integer_type_node)
 	      || (outprec == TYPE_PRECISION (integer_type_node)
@@ -631,14 +636,20 @@
 
 	CASE_FLT_FN (BUILT_IN_TRUNC):
 	CASE_FLT_FN_FLOATN_NX (BUILT_IN_TRUNC):
-	  return convert_to_integer_1 (type, CALL_EXPR_ARG (s_expr, 0), dofold);
+	  if (call_expr_nargs (s_expr) != 1
+	      || !SCALAR_FLOAT_TYPE_P (TREE_TYPE (CALL_EXPR_ARG (s_expr, 0))))
+	    break;
+	  return convert_to_integer_1 (type, CALL_EXPR_ARG (s_expr, 0),
+				       dofold);
 
 	default:
 	  break;
 	}
 
-      if (fn)
-        {
+      if (fn
+	  && call_expr_nargs (s_expr) == 1
+	  && SCALAR_FLOAT_TYPE_P (TREE_TYPE (CALL_EXPR_ARG (s_expr, 0))))
+	{
 	  tree newexpr = build_call_expr (fn, 1, CALL_EXPR_ARG (s_expr, 0));
 	  return convert_to_integer_1 (type, newexpr, dofold);
 	}
@@ -668,7 +679,9 @@
 	  break;
 	}
 
-      if (fn)
+      if (fn
+	  && call_expr_nargs (s_expr) == 1
+	  && SCALAR_FLOAT_TYPE_P (TREE_TYPE (CALL_EXPR_ARG (s_expr, 0))))
         {
 	  tree newexpr = build_call_expr (fn, 1, CALL_EXPR_ARG (s_expr, 0));
 	  return convert_to_integer_1 (type, newexpr, dofold);
Index: gcc/lto-streamer.h
===================================================================
--- a/src/gcc/lto-streamer.h	(.../tags/gcc_8_3_0_release)
+++ b/src/gcc/lto-streamer.h	(.../branches/gcc-8-branch)
@@ -121,7 +121,7 @@
      form followed by the data for the string.  */
 
 #define LTO_major_version 7
-#define LTO_minor_version 1
+#define LTO_minor_version 2
 
 typedef unsigned char	lto_decl_flags_t;
 
Index: libgfortran/intrinsics/random.c
===================================================================
--- a/src/libgfortran/intrinsics/random.c	(.../tags/gcc_8_3_0_release)
+++ b/src/libgfortran/intrinsics/random.c	(.../branches/gcc-8-branch)
@@ -272,31 +272,20 @@
 }
 
 
-/* Super-simple LCG generator used in getosrandom () if /dev/urandom
-   doesn't exist.  */
+/* Splitmix64 recommended by xorshift author for initializing.  After
+   getting one uint64_t value from the OS, this is used to fill in the
+   rest of the state.  */
 
-#define M 2147483647 /* 2^31 - 1 (A large prime number) */
-#define A 16807      /* Prime root of M, passes statistical tests and produces a full cycle */
-#define Q 127773 /* M / A (To avoid overflow on A * seed) */
-#define R 2836   /* M % A (To avoid overflow on A * seed) */
-
-__attribute__((unused)) static uint32_t
-lcg_parkmiller(uint32_t seed)
+static uint64_t
+splitmix64 (uint64_t x)
 {
-    uint32_t hi = seed / Q;
-    uint32_t lo = seed % Q;
-    int32_t test = A * lo - R * hi;
-    if (test <= 0)
-        test += M;
-    return test;
+  uint64_t z = (x += 0x9e3779b97f4a7c15);
+  z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;
+  z = (z ^ (z >> 27)) * 0x94d049bb133111eb;
+  return z ^ (z >> 31);
 }
 
-#undef M
-#undef A
-#undef Q
-#undef R
 
-
 /* Get some random bytes from the operating system in order to seed
    the PRNG.  */
 
@@ -326,7 +315,7 @@
       close (fd);
       return res;
     }
-  uint32_t seed = 1234567890;
+  uint64_t seed = 0x047f7684e9fc949dULL;
   time_t secs;
   long usecs;
   if (gf_gettime (&secs, &usecs) == 0)
@@ -338,13 +327,9 @@
   pid_t pid = getpid();
   seed ^= pid;
 #endif
-  uint32_t* ub = buf;
-  for (size_t i = 0; i < buflen / sizeof (uint32_t); i++)
-    {
-      ub[i] = seed;
-      seed = lcg_parkmiller (seed);
-    }
-  return buflen;
+  size_t size = buflen < sizeof (uint64_t) ? buflen : sizeof (uint64_t);
+  memcpy (buf, &seed, size);
+  return size;
 #endif /* __MINGW64_VERSION_MAJOR  */
 }
 
@@ -359,7 +344,13 @@
     __gthread_mutex_lock (&random_lock);
   if (!master_init)
     {
-      getosrandom (master_state, sizeof (master_state));
+      uint64_t os_seed;
+      getosrandom (&os_seed, sizeof (os_seed));
+      for (uint64_t i = 0; i < sizeof (master_state) / sizeof (uint64_t); i++)
+	{
+	  os_seed = splitmix64 (os_seed);
+	  master_state[i] = os_seed;
+	}
       njumps = 0;
       master_init = true;
     }
Index: libgfortran/ChangeLog
===================================================================
--- a/src/libgfortran/ChangeLog	(.../tags/gcc_8_3_0_release)
+++ b/src/libgfortran/ChangeLog	(.../branches/gcc-8-branch)
@@ -1,3 +1,28 @@
+2019-08-13  Janne Blomqvist  <jb@gcc.gnu.org>
+
+	Partial backport from trunk
+	PR fortran/91414
+	* intrinsics/random.c (lcg_parkmiller): Replace with splitmix64.
+	(splitmix64): New function.
+	(getosrandom): Simplify.
+	(init_rand_state): Use getosrandom only to get 8 bytes, splitmix64
+	to fill rest of state.
+
+2019-04-16  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-03-25  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR libgfortran/79540
+	* io/write_float.def (build_float_string): Don't copy digits when
+	ndigits is negative.
+
+2019-03-02  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/89020
+	* io/close.c (st_close): Generate error if calls to 'remove' return
+	an error.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: libgfortran/io/close.c
===================================================================
--- a/src/libgfortran/io/close.c	(.../tags/gcc_8_3_0_release)
+++ b/src/libgfortran/io/close.c	(.../branches/gcc-8-branch)
@@ -90,7 +90,10 @@
 	      else
 		{
 #if HAVE_UNLINK_OPEN_FILE
-		  remove (u->filename);
+
+		  if (remove (u->filename))
+		    generate_error (&clp->common, LIBERROR_OS,
+				    "File cannot be deleted");
 #else
 		  path = strdup (u->filename);
 #endif
@@ -103,7 +106,9 @@
 #if !HAVE_UNLINK_OPEN_FILE
       if (path != NULL)
 	{
-	  remove (path);
+	  if (remove (path))
+	    generate_error (&clp->common, LIBERROR_OS,
+			    "File cannot be deleted");
 	  free (path);
 	}
 #endif
Index: libgfortran/io/write_float.def
===================================================================
--- a/src/libgfortran/io/write_float.def	(.../tags/gcc_8_3_0_release)
+++ b/src/libgfortran/io/write_float.def	(.../branches/gcc-8-branch)
@@ -620,7 +620,7 @@
     }
 
   /* Set digits after the decimal point, padding with zeros.  */
-  if (nafter > 0)
+  if (ndigits >= 0 && nafter > 0)
     {
       if (nafter > ndigits)
 	i = ndigits;
@@ -627,7 +627,8 @@
       else
 	i = nafter;
 
-      memcpy (put, digits, i);
+      if (i > 0)
+	memcpy (put, digits, i);
       while (i < nafter)
 	put[i++] = '0';
 
Index: libcpp/line-map.c
===================================================================
--- a/src/libcpp/line-map.c	(.../tags/gcc_8_3_0_release)
+++ b/src/libcpp/line-map.c	(.../branches/gcc-8-branch)
@@ -755,6 +755,11 @@
       if (line_delta < 0
 	  || last_line != ORDINARY_MAP_STARTING_LINE_NUMBER (map)
 	  || SOURCE_COLUMN (map, highest) >= (1U << (column_bits - range_bits))
+	  || ( /* We can't reuse the map if the line offset is sufficiently
+		  large to cause overflow when computing location_t values.  */
+	      (to_line - ORDINARY_MAP_STARTING_LINE_NUMBER (map))
+	      >= (((uint64_t) 1)
+		  << (CHAR_BIT * sizeof (linenum_type) - column_bits)))
 	  || range_bits < map->m_range_bits)
 	map = linemap_check_ordinary
 	        (const_cast <line_map *>
Index: libcpp/ChangeLog
===================================================================
--- a/src/libcpp/ChangeLog	(.../tags/gcc_8_3_0_release)
+++ b/src/libcpp/ChangeLog	(.../branches/gcc-8-branch)
@@ -1,3 +1,22 @@
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-18  Martin Liska  <mliska@suse.cz>
+
+	PR c++/89383
+	* line-map.c (linemap_line_start): Use 1UL in order
+	to not overflow.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-11  Martin Liska  <mliska@suse.cz>
+
+	PR lto/88147
+	* line-map.c (linemap_line_start): Don't reuse the existing line
+	map if the line offset is sufficiently large to cause overflow
+	when computing location_t values.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: fixincludes/ChangeLog
===================================================================
--- a/src/fixincludes/ChangeLog	(.../tags/gcc_8_3_0_release)
+++ b/src/fixincludes/ChangeLog	(.../branches/gcc-8-branch)
@@ -1,3 +1,23 @@
+2019-06-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-11  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR bootstrap/89864
+	* inclhack.def (darwin_ucred__Atomic): Do not supply test_text
+	for wrap fixes.
+	* fixincl.x: Regenerated.
+
+	Backport from mainline.
+	2019-04-18  Erik Schnetter  <schnetter@gmail.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+		    Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR bootstrap/89864
+	* inclhack.def (darwin_ucred__Atomic): New, work around _Atomic keyword
+	use in headers included by C++.
+	* fixincl.x: Regenerated.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: fixincludes/fixincl.x
===================================================================
--- a/src/fixincludes/fixincl.x	(.../tags/gcc_8_3_0_release)
+++ b/src/fixincludes/fixincl.x	(.../branches/gcc-8-branch)
@@ -2,11 +2,11 @@
  *
  * DO NOT EDIT THIS FILE   (fixincl.x)
  *
- * It has been AutoGen-ed  February 22, 2018 at 03:46:51 PM by AutoGen 5.18
+ * It has been AutoGen-ed  May 30, 2019 at 01:23:39 AM by AutoGen 5.17.4
  * From the definitions    inclhack.def
  * and the template file   fixincl
  */
-/* DO NOT SVN-MERGE THIS FILE, EITHER Thu Feb 22 15:46:51 UTC 2018
+/* DO NOT SVN-MERGE THIS FILE, EITHER Thu May 30 01:23:39 BST 2019
  *
  * You must regenerate it.  Use the ./genfixes script.
  *
@@ -15,7 +15,7 @@
  * certain ANSI-incompatible system header files which are fixed to work
  * correctly with ANSI C and placed in a directory that GNU C will search.
  *
- * This file contains 249 fixup descriptions.
+ * This file contains 250 fixup descriptions.
  *
  * See README for more information.
  *
@@ -3222,6 +3222,48 @@
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
+ *  Description of Darwin_Ucred__Atomic fix
+ */
+tSCC zDarwin_Ucred__AtomicName[] =
+     "darwin_ucred__Atomic";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zDarwin_Ucred__AtomicList[] =
+  "sys/ucred.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzDarwin_Ucred__AtomicMachs[] = {
+        "*-*-darwin*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zDarwin_Ucred__AtomicSelect0[] =
+       "_Atomic";
+
+#define    DARWIN_UCRED__ATOMIC_TEST_CT  1
+static tTestDesc aDarwin_Ucred__AtomicTests[] = {
+  { TT_EGREP,    zDarwin_Ucred__AtomicSelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Darwin_Ucred__Atomic
+ */
+static const char* apzDarwin_Ucred__AtomicPatch[] = {
+    "wrap",
+    "#if (__STDC_VERSION__ < 201112L) || defined(__cplusplus)\n\
+# define _Atomic volatile\n\
+#endif\n",
+    "#if (__STDC_VERSION__ < 201112L) || defined(__cplusplus)\n\
+# undef _Atomic\n\
+#endif\n",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
  *  Description of Dec_Intern_Asm fix
  */
 tSCC zDec_Intern_AsmName[] =
@@ -10099,9 +10141,9 @@
  *
  *  List of all fixes
  */
-#define REGEX_COUNT          287
+#define REGEX_COUNT          288
 #define MACH_LIST_SIZE_LIMIT 187
-#define FIX_COUNT            249
+#define FIX_COUNT            250
 
 /*
  *  Enumerate the fixes
@@ -10183,6 +10225,7 @@
     DARWIN_STDINT_5_FIXIDX,
     DARWIN_STDINT_6_FIXIDX,
     DARWIN_STDINT_7_FIXIDX,
+    DARWIN_UCRED__ATOMIC_FIXIDX,
     DEC_INTERN_ASM_FIXIDX,
     DJGPP_WCHAR_H_FIXIDX,
     ECD_CURSOR_FIXIDX,
@@ -10739,6 +10782,11 @@
      DARWIN_STDINT_7_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
      aDarwin_Stdint_7Tests,   apzDarwin_Stdint_7Patch, 0 },
 
+  {  zDarwin_Ucred__AtomicName,    zDarwin_Ucred__AtomicList,
+     apzDarwin_Ucred__AtomicMachs,
+     DARWIN_UCRED__ATOMIC_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aDarwin_Ucred__AtomicTests,   apzDarwin_Ucred__AtomicPatch, 0 },
+
   {  zDec_Intern_AsmName,    zDec_Intern_AsmList,
      apzDec_Intern_AsmMachs,
      DEC_INTERN_ASM_TEST_CT, FD_MACH_ONLY,
Index: fixincludes/inclhack.def
===================================================================
--- a/src/fixincludes/inclhack.def	(.../tags/gcc_8_3_0_release)
+++ b/src/fixincludes/inclhack.def	(.../branches/gcc-8-branch)
@@ -1592,6 +1592,25 @@
 		"#define UINTMAX_C(v) (v ## ULL)";
 };
 
+/*  The SDK included with XCode 10.2 has the file <sys/ucred.h> that uses the
+    C11 _Atomic keyword (exposing it to C++ code).  The work-around here follows
+    the header in declaring the entity volatile when _Atomic is not available.
+*/
+fix = {
+    hackname  = darwin_ucred__Atomic;
+    mach      = "*-*-darwin*";
+    files     = sys/ucred.h;
+    select    = "_Atomic";
+    c_fix     = wrap;
+    c_fix_arg = "#if (__STDC_VERSION__ < 201112L) || defined(__cplusplus)\n"
+		"# define _Atomic volatile\n"
+		"#endif\n";
+    c_fix_arg = "#if (__STDC_VERSION__ < 201112L) || defined(__cplusplus)\n"
+		"# undef _Atomic\n"
+		"#endif\n";
+    test_text = ""; /* Don't provide this for wrap fixes.  */
+};
+
 /*
  *  Fix <c_asm.h> on Digital UNIX V4.0:
  *  It contains a prototype for a DEC C internal asm() function,
Index: .
===================================================================
--- a/src/.	(.../tags/gcc_8_3_0_release)
+++ b/src/.	(.../branches/gcc-8-branch)

Property changes on: .
___________________________________________________________________
Modified: svn:mergeinfo
## -0,0 +0,1 ##
   Merged /trunk:r260603
