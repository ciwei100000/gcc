# DP: updates from the 9 branch upto 20190820 (r274746).

last_update()
{
	cat > ${dir}LAST_UPDATED <EOF
Tue Aug 20 14:40:24 CEST 2019
Tue Aug 20 12:40:24 UTC 2019 (revision 274746)
EOF
}

LANG=C svn diff svn://gcc.gnu.org/svn/gcc/tags/gcc_9_2_0_release svn://gcc.gnu.org/svn/gcc/branches/gcc-9-branch \
	| sed -r 's,^--- (\S+)\t(\S+)(.*)$,--- a/src/\1\t\2,;s,^\+\+\+ (\S+)\t(\S+)(.*)$,+++ b/src/\1\t\2,' \
	| awk '/^Index:.*\.(class|texi)/ {skip=1; next} /^Index:/ { skip=0 } skip==0'

Index: libgomp/ChangeLog
===================================================================
--- a/src/libgomp/ChangeLog	(.../tags/gcc_9_2_0_release)
+++ b/src/libgomp/ChangeLog	(.../branches/gcc-9-branch)
@@ -1,3 +1,10 @@
+2019-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91422
+	* testsuite/libgomp.oacc-fortran/routine-7.f90: Correct array
+	dimension.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
Index: libgomp/testsuite/libgomp.oacc-fortran/routine-7.f90
===================================================================
--- a/src/libgomp/testsuite/libgomp.oacc-fortran/routine-7.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/libgomp/testsuite/libgomp.oacc-fortran/routine-7.f90	(.../branches/gcc-9-branch)
@@ -109,7 +109,7 @@
 
 subroutine seq (a)
   !$acc routine seq
-  integer, intent (inout) :: a(M)
+  integer, intent (inout) :: a(N)
   integer :: i
 
   do i = 1, N
Index: libsanitizer/asan/Makefile.in
===================================================================
--- a/src/libsanitizer/asan/Makefile.in	(.../tags/gcc_9_2_0_release)
+++ b/src/libsanitizer/asan/Makefile.in	(.../branches/gcc-9-branch)
@@ -90,7 +90,7 @@
 build_triplet = @build@
 host_triplet = @host@
 target_triplet = @target@
-@USING_MAC_INTERPOSE_TRUE@am__append_1 = -DMAC_INTERPOSE_FUNCTIONS -DMISSING_BLOCKS_SUPPORT
+@USING_MAC_INTERPOSE_TRUE@am__append_1 = -DMAC_INTERPOSE_FUNCTIONS -DMISSING_BLOCKS_SUPPORT -DASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION=0
 @USING_MAC_INTERPOSE_FALSE@am__append_2 = $(top_builddir)/interception/libinterception.la
 @LIBBACKTRACE_SUPPORTED_TRUE@am__append_3 = $(top_builddir)/libbacktrace/libsanitizer_libbacktrace.la
 subdir = asan
Index: libsanitizer/asan/asan_interceptors.h
===================================================================
--- a/src/libsanitizer/asan/asan_interceptors.h	(.../tags/gcc_9_2_0_release)
+++ b/src/libsanitizer/asan/asan_interceptors.h	(.../branches/gcc-9-branch)
@@ -79,7 +79,12 @@
 #if ASAN_HAS_EXCEPTIONS && !SANITIZER_WINDOWS && !SANITIZER_SOLARIS && \
     !SANITIZER_NETBSD
 # define ASAN_INTERCEPT___CXA_THROW 1
-# define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1
+# if ! defined(ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION) \
+     || ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION
+#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1
+# else
+#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 0
+# endif
 # if defined(_GLIBCXX_SJLJ_EXCEPTIONS) || (SANITIZER_IOS && defined(__arm__))
 #  define ASAN_INTERCEPT__UNWIND_SJLJ_RAISEEXCEPTION 1
 # else
Index: libsanitizer/asan/Makefile.am
===================================================================
--- a/src/libsanitizer/asan/Makefile.am	(.../tags/gcc_9_2_0_release)
+++ b/src/libsanitizer/asan/Makefile.am	(.../branches/gcc-9-branch)
@@ -5,7 +5,7 @@
 
 DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -DASAN_HAS_EXCEPTIONS=1 -DASAN_NEEDS_SEGV=1 -DCAN_SANITIZE_UB=0
 if USING_MAC_INTERPOSE
-DEFS += -DMAC_INTERPOSE_FUNCTIONS -DMISSING_BLOCKS_SUPPORT
+DEFS += -DMAC_INTERPOSE_FUNCTIONS -DMISSING_BLOCKS_SUPPORT -DASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION=0
 endif
 AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic -Wno-long-long  -fPIC -fno-builtin -fno-exceptions -fno-rtti -fomit-frame-pointer -funwind-tables -fvisibility=hidden -Wno-variadic-macros -fno-ipa-icf
 AM_CXXFLAGS += $(LIBSTDCXX_RAW_CXX_CXXFLAGS)
Index: libsanitizer/ChangeLog
===================================================================
--- a/src/libsanitizer/ChangeLog	(.../tags/gcc_9_2_0_release)
+++ b/src/libsanitizer/ChangeLog	(.../branches/gcc-9-branch)
@@ -1,3 +1,15 @@
+2019-08-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR libsanitizer/87880
+	* asan/asan_interceptors.h:
+	(ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION): New.
+	* asan/Makefile.am (DEFS): Add (for Darwin only)
+	ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION, defined to 0.
+	* asan/Makefile.in: Regenerated.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
Index: libstdc++-v3/src/c++17/string-inst.cc
===================================================================
--- a/src/libstdc++-v3/src/c++17/string-inst.cc	(.../tags/gcc_9_2_0_release)
+++ b/src/libstdc++-v3/src/c++17/string-inst.cc	(.../branches/gcc-9-branch)
@@ -26,6 +26,12 @@
 // ISO C++ 14882:2017 24  Strings library
 //
 
+#ifndef _GLIBCXX_USE_CXX11_ABI
+// Instantiations in this file use the new SSO std::string ABI unless included
+// by another file which defines _GLIBCXX_USE_CXX11_ABI=0.
+# define _GLIBCXX_USE_CXX11_ABI 1
+#endif
+
 #include <string>
 
 namespace std _GLIBCXX_VISIBILITY(default)
Index: libstdc++-v3/ChangeLog
===================================================================
--- a/src/libstdc++-v3/ChangeLog	(.../tags/gcc_9_2_0_release)
+++ b/src/libstdc++-v3/ChangeLog	(.../branches/gcc-9-branch)
@@ -1,3 +1,11 @@
+2019-08-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-08-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90361
+	* src/c++17/string-inst.cc: Use _GLIBCXX_USE_CXX11_ABI=1 by default.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
Index: contrib/ChangeLog
===================================================================
--- a/src/contrib/ChangeLog	(.../tags/gcc_9_2_0_release)
+++ b/src/contrib/ChangeLog	(.../branches/gcc-9-branch)
@@ -1,3 +1,7 @@
+2019-08-16  Uros Bizjak  <ubizjak@gmail.com>
+
+	* test_summary: Do not escape "=".
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
Index: contrib/test_summary
===================================================================
--- a/src/contrib/test_summary	(.../tags/gcc_9_2_0_release)
+++ b/src/contrib/test_summary	(.../branches/gcc-9-branch)
@@ -127,7 +127,7 @@
   if (lang == "") lang = " "$2" "; else lang = " ";
 }
 $2 == "version" { save = $0; $1 = ""; $2 = ""; version = $0; gsub(/^ */, "", version); gsub(/\r$/, "", version); $0 = save; }
-/\===.*Summary/ { print ""; print; blanks=1; }
+/===.*Summary/ { print ""; print; blanks=1; }
 /tests ===/ || /^(Target|Host|Native)/ || $2 == "version" { print; blanks=1; }
 /^(XPASS|FAIL|UNRESOLVED|WARNING|ERROR|# of )/ { sub ("\r", ""); print; }
 /^using:/ { print ""; print; print ""; }
Index: gcc/lra-int.h
===================================================================
--- a/src/gcc/lra-int.h	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/lra-int.h	(.../branches/gcc-9-branch)
@@ -401,6 +401,7 @@
 
 /* lra-spills.c:  */
 
+extern bool lra_need_for_scratch_reg_p (void);
 extern bool lra_need_for_spills_p (void);
 extern void lra_spill (void);
 extern void lra_final_code_change (void);
Index: gcc/DATESTAMP
===================================================================
--- a/src/gcc/DATESTAMP	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/DATESTAMP	(.../branches/gcc-9-branch)
@@ -1 +1 @@
-20190812
+20190820
Index: gcc/lra.c
===================================================================
--- a/src/gcc/lra.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/lra.c	(.../branches/gcc-9-branch)
@@ -2587,7 +2587,11 @@
 	  lra_create_live_ranges (lra_reg_spill_p, true);
 	  live_p = true;
 	  if (! lra_need_for_spills_p ())
-	    break;
+	    {
+	      if (lra_need_for_scratch_reg_p ())
+		continue;
+	      break;
+	    }
 	}
       lra_spill ();
       /* Assignment of stack slots changes elimination offsets for
Index: gcc/tree.c
===================================================================
--- a/src/gcc/tree.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/tree.c	(.../branches/gcc-9-branch)
@@ -5514,8 +5514,7 @@
 	  free_lang_data_in_binfo (TYPE_BINFO (type));
 	  /* We need to preserve link to bases and virtual table for all
 	     polymorphic types to make devirtualization machinery working.  */
-	  if (!BINFO_VTABLE (TYPE_BINFO (type))
-	      || !flag_devirtualize)
+	  if (!BINFO_VTABLE (TYPE_BINFO (type)))
 	    TYPE_BINFO (type) = NULL;
 	}
     }
@@ -11357,6 +11356,73 @@
     }
 }
 
+/* Given an initializer INIT for a TYPE, return true if INIT is zero
+   so that it can be replaced by value initialization.  This function
+   distinguishes betwen empty strings as initializers for arrays and
+   for pointers (which make it return false).  */
+
+bool
+type_initializer_zero_p (tree type, tree init)
+{
+  if (type  == error_mark_node || init == error_mark_node)
+    return false;
+
+  STRIP_NOPS (init);
+
+  if (POINTER_TYPE_P (type))
+    return TREE_CODE (init) != STRING_CST && initializer_zerop (init);
+
+  if (TREE_CODE (init) != CONSTRUCTOR)
+    return initializer_zerop (init);
+
+  if (TREE_CODE (type) == ARRAY_TYPE)
+    {
+      tree elt_type = TREE_TYPE (type);
+      elt_type = TYPE_MAIN_VARIANT (elt_type);
+      if (elt_type == char_type_node)
+	return initializer_zerop (init);
+
+      tree elt_init;
+      unsigned HOST_WIDE_INT i;
+      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), i, elt_init)
+	if (!type_initializer_zero_p (elt_type, elt_init))
+	  return false;
+      return true;
+    }
+
+  if (TREE_CODE (type) != RECORD_TYPE)
+    return initializer_zerop (init);
+
+  tree fld = TYPE_FIELDS (type);
+
+  tree fld_init;
+  unsigned HOST_WIDE_INT i;
+  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), i, fld_init)
+    {
+      /* Advance to the next member, skipping over everything that
+	 canot be initialized (including unnamed bit-fields).  */
+      while (TREE_CODE (fld) != FIELD_DECL
+	     || DECL_ARTIFICIAL (fld)
+	     || (DECL_BIT_FIELD (fld) && !DECL_NAME (fld)))
+	{
+	  fld = DECL_CHAIN (fld);
+	  if (!fld)
+	    return true;
+	  continue;
+	}
+
+      tree fldtype = TREE_TYPE (fld);
+      if (!type_initializer_zero_p (fldtype, fld_init))
+	return false;
+
+      fld = DECL_CHAIN (fld);
+      if (!fld)
+	break;
+    }
+
+  return true;
+}
+
 /* Check if vector VEC consists of all the equal elements and
    that the number of elements corresponds to the type of VEC.
    The function returns first element of the vector
Index: gcc/tree.h
===================================================================
--- a/src/gcc/tree.h	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/tree.h	(.../branches/gcc-9-branch)
@@ -4525,6 +4525,12 @@
 extern bool initializer_zerop (const_tree, bool * = NULL);
 extern bool initializer_each_zero_or_onep (const_tree);
 
+/* Analogous to initializer_zerop but also examines the type for
+   which the initializer is being used.  Unlike initializer_zerop,
+   considers empty strings to be zero initializers for arrays and
+   non-zero for pointers.  */
+extern bool type_initializer_zero_p (tree, tree);
+
 extern wide_int vector_cst_int_elt (const_tree, unsigned int);
 extern tree vector_cst_elt (const_tree, unsigned int);
 
Index: gcc/lra-spills.c
===================================================================
--- a/src/gcc/lra-spills.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/lra-spills.c	(.../branches/gcc-9-branch)
@@ -548,6 +548,19 @@
     }
 }
 
+/* Return true if we need scratch reg assignments.  */
+bool
+lra_need_for_scratch_reg_p (void)
+{
+  int i; max_regno = max_reg_num ();
+
+  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)
+    if (lra_reg_info[i].nrefs != 0 && lra_get_regno_hard_regno (i) < 0
+	&& lra_former_scratch_p (i))
+      return true;
+  return false;
+}
+
 /* Return true if we need to change some pseudos into memory.  */
 bool
 lra_need_for_spills_p (void)
Index: gcc/tree-ssa-sccvn.c
===================================================================
--- a/src/gcc/tree-ssa-sccvn.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/tree-ssa-sccvn.c	(.../branches/gcc-9-branch)
@@ -132,8 +132,6 @@
 /* There's no BB_EXECUTABLE but we can use BB_VISITED.  */
 #define BB_EXECUTABLE BB_VISITED
 
-static tree *last_vuse_ptr;
-static vn_lookup_kind vn_walk_kind;
 static vn_lookup_kind default_vn_walk_kind;
 
 /* vn_nary_op hashtable helpers.  */
@@ -1678,18 +1676,33 @@
   return NULL_TREE;
 }
 
+struct vn_walk_cb_data
+{
+  vn_walk_cb_data (vn_reference_t vr_, tree *last_vuse_ptr_,
+                   vn_lookup_kind vn_walk_kind_, bool tbaa_p_)
+    : vr (vr_), last_vuse_ptr (last_vuse_ptr_), vn_walk_kind (vn_walk_kind_),
+      tbaa_p (tbaa_p_)
+    {}
+
+  vn_reference_t vr;
+  tree *last_vuse_ptr;
+  vn_lookup_kind vn_walk_kind;
+  bool tbaa_p;
+};
+
 /* Callback for walk_non_aliased_vuses.  Adjusts the vn_reference_t VR_
    with the current VUSE and performs the expression lookup.  */
 
 static void *
-vn_reference_lookup_2 (ao_ref *op ATTRIBUTE_UNUSED, tree vuse, void *vr_)
+vn_reference_lookup_2 (ao_ref *op ATTRIBUTE_UNUSED, tree vuse, void *data_)
 {
-  vn_reference_t vr = (vn_reference_t)vr_;
+  vn_walk_cb_data *data = (vn_walk_cb_data *)data_;
+  vn_reference_t vr = data->vr;
   vn_reference_s **slot;
   hashval_t hash;
 
-  if (last_vuse_ptr)
-    *last_vuse_ptr = vuse;
+  if (data->last_vuse_ptr)
+    *data->last_vuse_ptr = vuse;
 
   /* Fixup vuse and hash.  */
   if (vr->vuse)
@@ -1959,10 +1972,11 @@
    *DISAMBIGUATE_ONLY is set to true.  */
 
 static void *
-vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,
+vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *data_,
 		       bool *disambiguate_only)
 {
-  vn_reference_t vr = (vn_reference_t)vr_;
+  vn_walk_cb_data *data = (vn_walk_cb_data *)data_;
+  vn_reference_t vr = data->vr;
   gimple *def_stmt = SSA_NAME_DEF_STMT (vuse);
   tree base = ao_ref_base (ref);
   HOST_WIDE_INT offseti, maxsizei;
@@ -1989,7 +2003,7 @@
 						      get_alias_set (lhs),
 						      TREE_TYPE (lhs), lhs_ops);
 	  if (lhs_ref_ok
-	      && !refs_may_alias_p_1 (ref, &lhs_ref, true))
+	      && !refs_may_alias_p_1 (ref, &lhs_ref, data->tbaa_p))
 	    {
 	      *disambiguate_only = true;
 	      return NULL;
@@ -2005,21 +2019,21 @@
          we find a VN result with exactly the same value as the
 	 possible clobber.  In this case we can ignore the clobber
 	 and return the found value.  */
-      if (vn_walk_kind == VN_WALKREWRITE
+      if (data->vn_walk_kind == VN_WALKREWRITE
 	  && is_gimple_reg_type (TREE_TYPE (lhs))
 	  && types_compatible_p (TREE_TYPE (lhs), vr->type)
 	  && ref->ref)
 	{
-	  tree *saved_last_vuse_ptr = last_vuse_ptr;
+	  tree *saved_last_vuse_ptr = data->last_vuse_ptr;
 	  /* Do not update last_vuse_ptr in vn_reference_lookup_2.  */
-	  last_vuse_ptr = NULL;
+	  data->last_vuse_ptr = NULL;
 	  tree saved_vuse = vr->vuse;
 	  hashval_t saved_hashcode = vr->hashcode;
-	  void *res = vn_reference_lookup_2 (ref, gimple_vuse (def_stmt), vr);
+	  void *res = vn_reference_lookup_2 (ref, gimple_vuse (def_stmt), data);
 	  /* Need to restore vr->vuse and vr->hashcode.  */
 	  vr->vuse = saved_vuse;
 	  vr->hashcode = saved_hashcode;
-	  last_vuse_ptr = saved_last_vuse_ptr;
+	  data->last_vuse_ptr = saved_last_vuse_ptr;
 	  if (res && res != (void *)-1)
 	    {
 	      vn_reference_t vnresult = (vn_reference_t) res;
@@ -2072,7 +2086,9 @@
 	}
     }
 
-  if (*disambiguate_only)
+  /* If we are looking for redundant stores do not create new hashtable
+     entries from aliasing defs with made up alias-sets.  */
+  if (*disambiguate_only || !data->tbaa_p)
     return (void *)-1;
 
   /* If we cannot constrain the size of the reference we cannot
@@ -2342,7 +2358,7 @@
 
   /* 5) For aggregate copies translate the reference through them if
      the copy kills ref.  */
-  else if (vn_walk_kind == VN_WALKREWRITE
+  else if (data->vn_walk_kind == VN_WALKREWRITE
 	   && gimple_assign_single_p (def_stmt)
 	   && (DECL_P (gimple_assign_rhs1 (def_stmt))
 	       || TREE_CODE (gimple_assign_rhs1 (def_stmt)) == MEM_REF
@@ -2462,7 +2478,7 @@
       *ref = r;
 
       /* Do not update last seen VUSE after translating.  */
-      last_vuse_ptr = NULL;
+      data->last_vuse_ptr = NULL;
 
       /* Keep looking for the adjusted *REF / VR pair.  */
       return NULL;
@@ -2470,7 +2486,7 @@
 
   /* 6) For memcpy copies translate the reference through them if
      the copy kills ref.  */
-  else if (vn_walk_kind == VN_WALKREWRITE
+  else if (data->vn_walk_kind == VN_WALKREWRITE
 	   && is_gimple_reg_type (vr->type)
 	   /* ???  Handle BCOPY as well.  */
 	   && (gimple_call_builtin_p (def_stmt, BUILT_IN_MEMCPY)
@@ -2620,7 +2636,7 @@
       *ref = r;
 
       /* Do not update last seen VUSE after translating.  */
-      last_vuse_ptr = NULL;
+      data->last_vuse_ptr = NULL;
 
       /* Keep looking for the adjusted *REF / VR pair.  */
       return NULL;
@@ -2681,13 +2697,13 @@
     {
       ao_ref r;
       unsigned limit = PARAM_VALUE (PARAM_SCCVN_MAX_ALIAS_QUERIES_PER_ACCESS);
-      vn_walk_kind = kind;
+      vn_walk_cb_data data (&vr1, NULL, kind, true);
       if (ao_ref_init_from_vn_reference (&r, set, type, vr1.operands))
 	*vnresult =
-	  (vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse,
+	  (vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse, true,
 						  vn_reference_lookup_2,
 						  vn_reference_lookup_3,
-						  vuse_valueize, limit, &vr1);
+						  vuse_valueize, limit, &data);
       gcc_checking_assert (vr1.operands == shared_lookup_references);
     }
 
@@ -2702,11 +2718,12 @@
    not exist in the hash table or if the result field of the structure
    was NULL..  VNRESULT will be filled in with the vn_reference_t
    stored in the hashtable if one exists.  When TBAA_P is false assume
-   we are looking up a store and treat it as having alias-set zero.  */
+   we are looking up a store and treat it as having alias-set zero.
+   *LAST_VUSE_PTR will be updated with the VUSE the value lookup succeeded.  */
 
 tree
 vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,
-		     vn_reference_t *vnresult, bool tbaa_p)
+		     vn_reference_t *vnresult, bool tbaa_p, tree *last_vuse_ptr)
 {
   vec<vn_reference_op_s> operands;
   struct vn_reference_s vr1;
@@ -2720,7 +2737,7 @@
   vr1.operands = operands
     = valueize_shared_reference_ops_from_ref (op, &valuezied_anything);
   vr1.type = TREE_TYPE (op);
-  vr1.set = tbaa_p ? get_alias_set (op) : 0;
+  vr1.set = get_alias_set (op);
   vr1.hashcode = vn_reference_compute_hash (&vr1);
   if ((cst = fully_constant_vn_reference_p (&vr1)))
     return cst;
@@ -2737,14 +2754,12 @@
 	  || !ao_ref_init_from_vn_reference (&r, vr1.set, vr1.type,
 					     vr1.operands))
 	ao_ref_init (&r, op);
-      if (! tbaa_p)
-	r.ref_alias_set = r.base_alias_set = 0;
-      vn_walk_kind = kind;
+      vn_walk_cb_data data (&vr1, last_vuse_ptr, kind, tbaa_p);
       wvnresult =
-	(vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse,
+	(vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse, tbaa_p,
 						vn_reference_lookup_2,
 						vn_reference_lookup_3,
-						vuse_valueize, limit, &vr1);
+						vuse_valueize, limit, &data);
       gcc_checking_assert (vr1.operands == shared_lookup_references);
       if (wvnresult)
 	{
@@ -4099,10 +4114,8 @@
   tree result;
 
   last_vuse = gimple_vuse (stmt);
-  last_vuse_ptr = &last_vuse;
   result = vn_reference_lookup (op, gimple_vuse (stmt),
-				default_vn_walk_kind, NULL, true);
-  last_vuse_ptr = NULL;
+				default_vn_walk_kind, NULL, true, &last_vuse);
 
   /* We handle type-punning through unions by value-numbering based
      on offset and size of the access.  Be prepared to handle a
Index: gcc/tree-ssa-sccvn.h
===================================================================
--- a/src/gcc/tree-ssa-sccvn.h	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/tree-ssa-sccvn.h	(.../branches/gcc-9-branch)
@@ -234,7 +234,8 @@
 tree vn_reference_lookup_pieces (tree, alias_set_type, tree,
 				 vec<vn_reference_op_s> ,
 				 vn_reference_t *, vn_lookup_kind);
-tree vn_reference_lookup (tree, tree, vn_lookup_kind, vn_reference_t *, bool);
+tree vn_reference_lookup (tree, tree, vn_lookup_kind, vn_reference_t *, bool,
+			  tree * = NULL);
 void vn_reference_lookup_call (gcall *, vn_reference_t *, vn_reference_t);
 vn_reference_t vn_reference_insert_pieces (tree, alias_set_type, tree,
 					   vec<vn_reference_op_s> ,
Index: gcc/ChangeLog
===================================================================
--- a/src/gcc/ChangeLog	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/ChangeLog	(.../branches/gcc-9-branch)
@@ -1,3 +1,123 @@
+2019-08-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/91347
+	* dse.c (scan_insn): Call add_wild_read for non-const/memset tail calls
+	before reload if HARD_FRAME_POINTER_IS_ARG_POINTER.
+
+2019-08-19  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backport from mainline
+	2019-09-09  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/91386
+	* config/aarch64/aarch64.c (aarch64_gen_adjusted_ldpstp): Use copy_rtx
+	to preserve the contents of the original insns.
+
+2019-08-16  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	Backport from mainline
+	2019-08-16  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	PR tree-optimization/91109
+	* lra-int.h (lra_need_for_scratch_reg_p): Declare.
+	* lra.c (lra): Use lra_need_for_scratch_reg_p.
+	* lra-spills.c (lra_need_for_scratch_reg_p): New function.
+
+	2019-08-07  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	PR tree-optimization/91109
+	* lra-remat.c (update_scratch_ops): Remove assignment of the
+	hard register.
+
+2019-08-15  Steve Ellcey  <sellcey@marvell.com>
+
+	Backport from mainline
+	2019-08-02  Steve Ellcey  <sellcey@marvell.com>
+
+	* omp-simd-clone.c (simd_clone_adjust_return_type): Remove call to
+	build_distinct_type_copy.
+	(simd_clone_adjust_argument_types): Ditto.
+	(simd_clone_adjust): Call build_distinct_type_copy here.
+	(expand_simd_clones): Ditto.
+
+2019-08-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91445
+	Backport from mainline
+	2019-07-05  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91091
+	* tree-ssa-alias.h (get_continuation_for_phi): Add tbaa_p parameter.
+	(walk_non_aliased_vuses): Likewise.
+	* tree-ssa-alias.c (maybe_skip_until): Pass down tbaa_p.
+	(get_continuation_for_phi): New tbaa_p parameter and pass
+	it down.
+	(walk_non_aliased_vuses): Likewise.
+	* tree-ssa-pre.c (translate_vuse_through_block): Likewise.
+	* tree-ssa-scopedtables.c (avail_exprs_stack::lookup_avail_expr):
+	Likewise.
+	* tree-ssa-sccvn.c (struct vn_walk_cb_data): Add tbaa_p flag.
+	(vn_reference_lookup_3): Handle and pass down tbaa_p flag.
+	(vn_reference_lookup_pieces): Adjust.
+	(vn_reference_lookup): Remove alias-set altering, instead pass
+	down false as tbaa_p.
+
+	2019-07-04  Richard Biener  <rguenther@suse.de>
+
+	* tree-ssa-sccvn.h (vn_reference_lookup): Add last_vuse_ptr
+	argument.
+	* tree-ssa-sccvn.c (last_vuse_ptr, vn_walk_kind): Move
+	globals into...
+	(struct vn_walk_cb_data): New callback data struct.
+	(vn_reference_lookup_2): Adjust.
+	(vn_reference_lookup_3): Likewise.
+	(vn_reference_lookup_pieces): Likewise.
+	(vn_reference_lookup): Likewise, get last_vuse_ptr argument.
+	(visit_reference_op_load): Adjust.
+
+2019-08-14  Martin Sebor  <msebor@redhat.com>
+
+	Backport from mainline
+
+	2019-08-01  Martin Sebor  <msebor@redhat.com>
+
+	PR c++/90947
+	* tree.c (type_initializer_zero_p): Define.
+	* tree.h (type_initializer_zero_p): New function.
+
+	2019-08-05  Martin Sebor  <msebor@redhat.com>
+
+	* doc/extend.texi (Common Variable Attributes): Document alias
+	attribute.
+
+2019-08-12  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-08-12  Richard Biener  <rguenther@suse.de>
+
+	PR lto/91375
+	* tree.c (free_lang_data_in_type): Do not free TYPE_BINFO dependent on
+	flag_devirtualize.
+
+	2019-08-12  Richard Biener  <rguenther@suse.de>
+
+	PR driver/91130
+	* lto-wrapper.c (get_options_from_collect_gcc_options): Remove
+	lang_mask option, always use CL_DRIVER.
+	(find_and_merge_options): Adjust.
+	(run_gcc): Likewise.
+
+	2019-08-07  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR driver/91130
+	* lto-wrapper.c (find_and_merge_options): Use CL_DRIVER when
+	processing COLLECT_GCC_OPTIONS.
+	(run_gcc): Likewise.
+
+2019-08-12  Jakub Jelinek  <jakub@redhat.com>
+
+	* BASE-VER: Set to 9.2.1.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
Index: gcc/testsuite/gfortran.dg/do_subscript_3.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/do_subscript_3.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/do_subscript_3.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,22 @@
+! { dg-do compile }
+! PR fortran/91424
+! Check that only one warning is issued inside blocks, and that
+! warnings are also issued for contained subroutines.
+
+program main
+  real :: a(5)
+  block
+    integer :: j
+    do j=0, 5  ! { dg-warning "out of bounds" }
+       a(j) = 2. ! { dg-warning "out of bounds" }
+    end do
+  end block
+  call x
+contains
+  subroutine x
+    integer :: i
+    do i=1,6 ! { dg-warning "out of bounds" }
+       a(i) = 2.  ! { dg-warning "out of bounds" }
+    end do
+  end subroutine x
+end program main
Index: gcc/testsuite/gfortran.dg/pr91359_2.f
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr91359_2.f	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr91359_2.f	(.../branches/gcc-9-branch)
@@ -0,0 +1,17 @@
+! { dg-do run }
+! PR fortran/91359
+! Orginal code contributed by Brian T. Carcich <briantcarcich at gmail dot com>
+!
+      logical function zero() result(a)
+         goto 2
+1        return
+2        a = .false.
+         if (.not.a) goto 1
+         return
+      end
+
+      program test_zero
+         logical zero
+         if (zero()) stop 'FAIL:  zero() returned .TRUE.'
+         stop 'OKAY:  zero() returned .FALSE.'
+      end
Index: gcc/testsuite/gfortran.dg/unlimited_polymorphic_28.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/unlimited_polymorphic_28.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/unlimited_polymorphic_28.f90	(.../branches/gcc-9-branch)
@@ -21,7 +21,7 @@
 
   type,abstract,extends(c_base) :: c_derived
   contains
-    procedure :: f_base => f_derived ! { dg-error "Type mismatch in function result \\(CLASS\\(\\*\\)/CLASS\\(c_base\\)\\)" }
+    procedure :: f_base => f_derived ! { dg-error "Type mismatch in function result" }
   end type c_derived
 
 contains
Index: gcc/testsuite/gfortran.dg/deferred_character_34.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/deferred_character_34.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/deferred_character_34.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,10 @@
+! { dg-do run }
+! PR fortran/90561
+! This used to ICE.
+! Original test case by Gerhard Steinmetz.
+program p
+   character(:), allocatable :: z(:)
+   z = [character(2):: 'ab', 'xy']
+   z = z(2)
+   if (any(z /= 'xy')) stop 1
+end
Index: gcc/testsuite/gfortran.dg/pr70754.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr70754.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr70754.f90	(.../branches/gcc-9-branch)
@@ -18,12 +18,13 @@
     integer (ii4), dimension(40,40) :: c
     integer  i, j
 
-    do i=1,20
-      b(i,j) = 123 * a(i,j) + 34 * a(i,j+1) &
-             + 34 * a(i,j-1) + a(i+1,j+1) &
-             + a(i+1,j-1) + a(i-1,j+1) &
-             + a(i-1,j-1)
-      c(i,j) = 123
+    j = 10
+    do i=11,30
+       b(i,j) = 123 * a(i,j) + 34 * a(i,j+1) &
+            + 34 * a(i,j-1) + a(i+1,j+1) &
+            + a(i+1,j-1) + a(i-1,j+1) &
+            + a(i-1,j-1)
+       c(i,j) = 123
     end do
 
     where ((xyz(:,:,2) /= 0) .and. (c /= 0))
Index: gcc/testsuite/gfortran.dg/pr78719_3.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr78719_3.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr78719_3.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,32 @@
+! { dg-do compile }
+! PR fortran/78719
+! Code contributed by Gerhard Steinmetz 
+program p
+
+   type t
+      integer :: n
+   end type
+
+   class(t) :: g     ! { dg-error "must be dummy, allocatable or pointer" }
+
+   abstract interface
+      subroutine h
+      end
+   end interface
+
+   procedure(h), pointer :: s
+
+   s => f
+   call s
+   s => g            ! { dg-error "Invalid procedure pointer" }
+   call s
+
+   contains
+
+      subroutine f
+      end
+
+      subroutine g   ! { dg-error "has an explicit interface" }
+      end
+
+end program p        ! { dg-error "Syntax error" }
Index: gcc/testsuite/gfortran.dg/use_rename_8.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/use_rename_8.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/use_rename_8.f90	(.../branches/gcc-9-branch)
@@ -19,8 +19,8 @@
     USE MOO, ONLY: X => B
 END SUBROUTINE T
 
-SUBROUTINE C
-    USE MOO, ONLY: C  ! { dg-error "is also the name of the current program unit" }
+SUBROUTINE C          ! { dg-error "\(1\)" }
+    USE MOO, ONLY: C  ! { dg-error "conflicts with the" }
 END SUBROUTINE C
 
 SUBROUTINE D
@@ -36,15 +36,15 @@
     USE MOO, ONLY: X => F
 END SUBROUTINE F
 
-SUBROUTINE X
-    USE MOO, ONLY: X => G ! { dg-error "is also the name of the current program unit" }
+SUBROUTINE X              ! { dg-error "\(1\)" }
+    USE MOO, ONLY: X => G ! { dg-error "conflicts with the rename" }
 END SUBROUTINE X
 
-SUBROUTINE Y
-    USE MOO, ONLY: Y => H ! { dg-error "is also the name of the current program unit" }
+SUBROUTINE Y              ! { dg-error "\(1\)" }
+    USE MOO, ONLY: Y => H ! { dg-error "conflicts with the rename" }
 END SUBROUTINE Y
 
-SUBROUTINE Z
-    USE MOO, ONLY: Z => I, Z => I ! { dg-error "is also the name of the current program unit" }
+SUBROUTINE Z                        ! { dg-error "\(1\)" }
+    USE MOO, ONLY: Z => I, Z => I   ! { dg-error "conflicts with the rename" }
 END SUBROUTINE Z
 
Index: gcc/testsuite/gfortran.dg/pr87993.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr87993.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr87993.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,8 @@
+! { dg-do run }
+! Code contributed by Gerhard Steinmetz <gscfq at t-online dot de>
+program p
+   integer, parameter :: a(2) = 1
+   integer, parameter :: b = a%kind
+   if (any(a /= 1)) stop 1
+   if (b /= kind(a)) stop 2
+end
Index: gcc/testsuite/gfortran.dg/pr91471.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr91471.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr91471.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,14 @@
+! { dg-do compile }
+! PR fortran/91471
+! Code contributed by Sameeran Joshi <SameeranJayant dot Joshi at amd dot com>
+!
+! This invalid code (x(1) is referenced, but never set) caused an ICE due
+! to hitting a gfc_internal_error() in primary.c (gfc_variable_attr).  The
+! fix is to remove that gfc_internal_error().
+! 
+program dynamic
+   implicit none
+   integer, dimension(:), allocatable :: x
+   allocate(x(1))
+   stop x(1)
+end program dynamic
Index: gcc/testsuite/gfortran.dg/pr78719_2.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr78719_2.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr78719_2.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,32 @@
+! { dg-do compile }
+! PR fortran/78719
+! Code contributed by Gerhard Steinmetz 
+program p
+
+   type t
+      integer :: n
+   end type
+
+   real :: g
+
+   abstract interface
+      subroutine h
+      end
+   end interface
+
+   procedure(h), pointer :: s
+
+   s => f
+   call s
+   s => g            ! { dg-error "Invalid procedure pointer" }
+   call s
+
+   contains
+
+      subroutine f
+      end
+
+      subroutine g   ! { dg-error "has an explicit interface" }
+      end
+
+end program p        ! { dg-error "Syntax error" }
Index: gcc/testsuite/gfortran.dg/use_15.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/use_15.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/use_15.f90	(.../branches/gcc-9-branch)
@@ -28,8 +28,8 @@
 end subroutine
 
 
-subroutine my_sub3 (a)
-  use test_mod2, my_sub3 => my_sub2  ! { dg-error "is also the name of the current program unit" }
+subroutine my_sub3 (a)              ! { dg-error "\(1\)" }
+  use test_mod2, my_sub3 => my_sub2 ! { dg-error "conflicts with the rename" }
   real a
   print *, a
 end subroutine
Index: gcc/testsuite/gfortran.dg/pr71649.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr71649.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr71649.f90	(.../branches/gcc-9-branch)
@@ -1,13 +1,13 @@
 ! { dg-do compile }
 ! PR71649 Internal Compiler Error
-SUBROUTINE Compiler_Options ( Options, Version, WriteOpt )
-   USE ISO_FORTRAN_ENV, ONLY : Compiler_Version, Compiler_Options ! { dg-error "already declared" }
+SUBROUTINE Compiler_Options ( Options, Version, WriteOpt )        ! { dg-error "\(1\)" }
+   USE ISO_FORTRAN_ENV, ONLY : Compiler_Version, Compiler_Options ! { dg-error "conflicts with the" }
    IMPLICIT NONE
    CHARACTER (LEN=*), INTENT(OUT) :: Options
    CHARACTER (LEN=*), INTENT(OUT) :: Version
    LOGICAL, INTENT(IN), OPTIONAL  :: WriteOpt
-   Version = Compiler_Version()
-   Options = Compiler_Options() ! { dg-error "Unexpected use of subroutine name" }
+   Version = Compiler_Version()  ! { dg-error "has no IMPLICIT type" }
+   Options = Compiler_Options()  ! { dg-error "Unexpected use of subroutine name" }
    RETURN
 END SUBROUTINE Compiler_Options
 
Index: gcc/testsuite/gfortran.dg/pr88072.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88072.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88072.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,30 @@
+! { dg-do compile }
+! PR fortran/88072
+! Original code contributed by Andrew Wood <andrew at fluidgravity dot co.uk>
+module m1
+
+   implicit none
+
+   type, abstract, public :: t1
+      integer, dimension(:), allocatable :: i
+      contains
+         procedure(f1), deferred :: f
+   end type t1
+
+   type, extends(t1), public :: t2 ! { dg-error "must be ABSTRACT because" }
+      contains
+         procedure :: f => f2    ! { dg-error "mismatch for the overriding" }
+   end type t2
+
+   abstract interface
+      function f1(this)          ! { dg-error "must be dummy, allocatable or" }
+         import
+         class(t1) :: this
+         class(t1) :: f1
+      end function f1
+   end interface
+   contains
+      type(t2) function f2(this)
+         class(t2) :: this
+      end function f2
+end module m1
Index: gcc/testsuite/gfortran.dg/do_subscript_5.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/do_subscript_5.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/do_subscript_5.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,20 @@
+! { dg-do compile }
+! { dg-additional-options "-Wdo-subscript" }
+! PR 90563 - this used to be rejected, wrongly
+! Original test case by Tobias Neumann
+program test
+      implicit none
+      integer, parameter :: swap(4) = [2,1,3,4]
+      real :: p(20)
+      integer :: j
+
+      p = 0.0
+
+      ! The following warnings are actually bogus, but we are not yet
+      ! clever enough to suppress them.
+      do j=1,6 ! { dg-warning "out of bounds" }
+          if (j<5) then
+              p(j) = p(swap(j)) ! { dg-warning "out of bounds" }
+          endif
+      enddo
+end program
Index: gcc/testsuite/gfortran.dg/pr78719_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr78719_1.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr78719_1.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,29 @@
+! { dg-do run }
+! PR fortran/78719
+! Code contributed by Gerhard Steinmetz 
+program p
+
+   type t
+      integer :: n
+   end type
+
+   abstract interface
+      subroutine h
+      end
+   end interface
+
+   procedure(h), pointer :: s
+
+   s => f
+   call s
+   s => g
+   call s
+
+   contains
+
+      subroutine f
+      end
+
+      subroutine g
+      end
+end program p
Index: gcc/testsuite/gfortran.dg/pr78739.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr78739.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr78739.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! { dg-options "-w" }
+! PR fortran/78739
+! Code contributed Gerhard Steinmetz
+function f(n)
+   f() = n    ! { dg-error "conflicts with function name" }
+end
+
+function g()
+   g(x) = x   ! { dg-error "conflicts with function name" }
+end
+
+function a()  ! This should cause an error, but cannot be easily detected!
+   a() = x
+end
Index: gcc/testsuite/gfortran.dg/pr89647.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr89647.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr89647.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,33 @@
+! { dg-do compile }
+! Code contributed by Ian Harvey  <ian_harvey at bigpond dot com>
+  MODULE m1
+    IMPLICIT NONE
+    PUBLIC :: False
+    PUBLIC :: True
+  CONTAINS
+    FUNCTION False() RESULT(b)
+      LOGICAL :: b
+      b = .FALSE.
+    END FUNCTION False
+    
+    FUNCTION True() RESULT(b)
+      LOGICAL :: b
+      b = .TRUE.
+    END FUNCTION True
+  END MODULE m1
+
+  MODULE m2
+    USE m1
+    IMPLICIT NONE
+    TYPE, ABSTRACT :: t_parent
+    CONTAINS
+      PROCEDURE(False), DEFERRED, NOPASS :: Binding
+    END TYPE t_parent
+  CONTAINS
+    SUBROUTINE s
+      TYPE, EXTENDS(t_parent) :: t_extension
+      CONTAINS
+        PROCEDURE, NOPASS :: Binding => True
+      END TYPE t_extension
+    END SUBROUTINE s
+  END MODULE m2
Index: gcc/testsuite/gfortran.dg/pr91485.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr91485.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr91485.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,24 @@
+! { dg-do compile }
+module foo
+   implicit none
+   interface operator(.x.)
+      module procedure product
+   end interface operator(.x.)
+   contains
+      function product(x, y)
+         real, intent(in) :: x, y
+         real :: product
+         product = x * y
+      end function product
+end module foo
+
+module gfcbug155
+   implicit none
+   contains
+      subroutine print_prod (x, y)
+         use foo, only : operator(.x.)
+         implicit none
+         real :: x, y
+         print *, x .x. y
+      end subroutine print_prod
+end module gfcbug155
Index: gcc/testsuite/gfortran.dg/allocated_2.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/allocated_2.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/allocated_2.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,16 @@
+! { dg-do compile }
+program foo
+
+   implicit none
+
+   integer, allocatable :: x
+   integer, allocatable :: a(:)
+
+   logical a1, a2
+
+   a1 = allocated(scalar=a)   ! { dg-error "Scalar entity required" }
+   a2 = allocated(array=x)    ! { dg-error "Array entity required" }
+   a1 = allocated(scalar=x, array=a)   ! { dg-error "Too many arguments" }
+   a1 = allocated(array=a, scalar=x)   ! { dg-error "Too many arguments" }
+
+end program foo
Index: gcc/testsuite/gfortran.dg/pr87991.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr87991.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr87991.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! { dg-options "-w" }
+! PR fortran/87991
+program p
+   type t
+      character(:), pointer :: c
+   end type
+   type(t) :: x
+   allocate (character(3) :: x%c)
+   data x%c /'abc'/   ! { dg-error "has the pointer attribute" }
+end
Index: gcc/testsuite/gfortran.dg/do_subscript_4.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/do_subscript_4.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/do_subscript_4.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR 91424 - this used to warn although the DO loop is zero trip.
+program main
+  implicit none
+  integer :: i
+  real :: a(2)
+  do i=1,3,-1
+     a(i) = 2.
+  end do
+  print *,a
+end program main
Index: gcc/testsuite/gfortran.dg/pr91359_1.f
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr91359_1.f	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr91359_1.f	(.../branches/gcc-9-branch)
@@ -0,0 +1,17 @@
+! { dg-do run }
+! PR fortran/91359
+! Orginal code contributed by Brian T. Carcich <briantcarcich at gmail dot com>
+!
+      logical function zero()
+         goto 2
+1        return
+2        zero = .false.
+         if (.not.zero) goto 1
+         return
+      end
+
+      program test_zero
+         logical zero
+         if (zero()) stop 'FAIL:  zero() returned .TRUE.'
+         stop 'OKAY:  zero() returned .FALSE.'
+      end
Index: gcc/testsuite/gfortran.dg/allocated_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/allocated_1.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/allocated_1.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,24 @@
+! { dg-do run }
+program foo
+
+   implicit none
+
+   integer, allocatable :: x
+   integer, allocatable :: a(:)
+
+   logical a1, a2
+
+   a1 = allocated(scalar=x)
+   if (a1 .neqv. .false.) stop 1
+   a2 = allocated(array=a)
+   if (a2 .neqv. .false.) stop 2
+
+   allocate(x)
+   allocate(a(2))
+
+   a1 = allocated(scalar=x)
+   if (a1 .neqv. .true.) stop 3
+   a2 = allocated(array=a)
+   if (a2 .neqv. .true.) stop 4
+
+end program foo
Index: gcc/testsuite/gcc.c-torture/execute/20190820-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/20190820-1.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/20190820-1.c	(.../branches/gcc-9-branch)
@@ -0,0 +1,111 @@
+/* PR rtl-optimization/91347 */
+/* Reported by John David Anglin <danglin@gcc.gnu.org> */
+
+typedef unsigned short __u16;
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+typedef __signed__ long long __s64;
+typedef unsigned long long __u64;
+typedef __u16 u16;
+typedef __s32 s32;
+typedef __u32 u32;
+typedef __u64 u64;
+typedef _Bool bool;
+typedef s32 int32_t;
+typedef u32 uint32_t;
+typedef u64 uint64_t;
+
+char hex_asc_upper[16];
+u16 decpair[100];
+
+static __attribute__ ((noipa)) void
+put_dec_full4 (char *buf, unsigned r)
+{
+ unsigned q;
+ q = (r * 0x147b) >> 19;
+ *((u16 *)buf) = decpair[r - 100*q];
+ buf += 2;
+ *((u16 *)buf) = decpair[q];
+}
+
+static __attribute__ ((noipa)) unsigned
+put_dec_helper4 (char *buf, unsigned x)
+{
+  uint32_t q = (x * (uint64_t)0x346DC5D7) >> 43;
+  put_dec_full4(buf, x - q * 10000);
+  return q;
+}
+
+static __attribute__ ((noipa)) char *
+put_dec (char *buf, unsigned long long n)
+{
+ uint32_t d3, d2, d1, q, h;
+ d1 = ((uint32_t)n >> 16);
+ h = (n >> 32);
+ d2 = (h ) & 0xffff;
+ d3 = (h >> 16);
+ q = 656 * d3 + 7296 * d2 + 5536 * d1 + ((uint32_t)n & 0xffff);
+ q = put_dec_helper4(buf, q);
+ q += 7671 * d3 + 9496 * d2 + 6 * d1;
+ q = put_dec_helper4(buf+4, q);
+ q += 4749 * d3 + 42 * d2;
+ q = put_dec_helper4(buf+8, q);
+ return buf;
+}
+
+struct printf_spec {
+ unsigned int type:8;
+ signed int field_width:24;
+ unsigned int flags:8;
+ unsigned int base:8;
+ signed int precision:16;
+} __attribute__((__packed__));
+
+static __attribute__ ((noipa)) char *
+number (char *buf, char *end, unsigned long long num, struct printf_spec spec)
+{
+
+ char tmp[3 * sizeof(num)] __attribute__((__aligned__(2)));
+ char sign;
+ char locase;
+ int need_pfx = ((spec.flags & 64) && spec.base != 10);
+ int i;
+ bool is_zero = num == 0LL;
+ int field_width = spec.field_width;
+ int precision = spec.precision;
+
+ i = 0;
+ if (num < spec.base)
+  tmp[i++] = hex_asc_upper[num] | locase;
+ else if (spec.base != 10) {
+  int mask = spec.base - 1;
+  int shift = 3;
+  if (spec.base == 16)
+   shift = 4;
+  else
+    __builtin_abort ();
+  do {
+   tmp[i++] = (hex_asc_upper[((unsigned char)num) & mask] | locase);
+   num >>= shift;
+  } while (num);
+ } else {
+  i = put_dec(tmp, num) - tmp;
+ }
+ return buf;
+}
+
+static __attribute__ ((noipa)) char *
+pointer_string (char *buf, char *end, const void *ptr, struct printf_spec spec)
+{
+ spec.base = 16;
+ spec.flags = 0;
+ return number(buf, end, 100, spec);
+}
+
+int
+main (void)
+{
+  struct printf_spec spec;
+  char *s = pointer_string (0, 0, 0, spec);
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr91445.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr91445.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr91445.c	(.../branches/gcc-9-branch)
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+
+struct S { _Bool x; };
+
+void
+foo (struct S *s)
+{
+  __builtin_memset (s, 0x11, sizeof (struct S));
+  s->x = 1;
+}
+
+int
+main ()
+{
+  struct S s;
+  foo (&s);
+  char c;
+  __builtin_memcpy (&c, &s.x, 1);
+  if (c != 1)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/tree-ssa/pr91091-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/tree-ssa/pr91091-2.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gcc.dg/tree-ssa/pr91091-2.c	(.../branches/gcc-9-branch)
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-fre1" } */
+
+struct s { int x; };
+struct t { int x; };
+
+void swap(struct s* p, struct t* q)
+{
+  p->x = q->x;
+  q->x = p->x;
+}
+
+/* The second statement is redundant.  */
+/* { dg-final { scan-tree-dump-times "x = " 1 "fre1" } } */
+/* { dg-final { scan-tree-dump-times " = \[^;\]*x;" 1 "fre1" } } */
Index: gcc/testsuite/ChangeLog
===================================================================
--- a/src/gcc/testsuite/ChangeLog	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/ChangeLog	(.../branches/gcc-9-branch)
@@ -1,3 +1,130 @@
+2019-08-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20190820-1.c: New test.
+
+2019-08-18  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91485
+	* gfortran.dg/pr91485.f90: New test.
+
+2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91471
+	* gfortran.dg/pr91471.f90: New test.
+
+2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78739
+	* fortran.dg/pr78739.f90: New test.
+
+2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78719
+	* gfortran.dg/pr78719_1.f90: New test.
+	* gfortran.dg/pr78719_2.f90: Ditto.
+	* gfortran.dg/pr78719_3.f90: Ditto.
+
+2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/82992
+	* gfortran.dg/pr71649.f90: Adjust error messages.
+	* gfortran.dg/use_15.f90: Ditto.
+	* gfortran.dg/use_rename_8.f90: Ditto.
+
+2019-08-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91445
+	* gcc.dg/torture/pr91445.c: New testcase.
+
+	Backport from mainline
+	2019-07-05  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91091
+	* gcc.dg/tree-ssa/pr91091-2.c: New testcase.
+
+2019-08-14  Martin Sebor  <msebor@redhat.com>
+
+	Backport from mainline
+
+	2019-08-01  Martin Sebor  <msebor@redhat.com>
+
+	PR c++/90947
+	* c-c++-common/array-1.c: New test.
+	* g++.dg/abi/mangle73.C: New test.
+	* g++.dg/cpp2a/nontype-class23.C: New test.
+	* g++.dg/init/array53.C: New test.
+
+2019-08-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/91436
+	* g++.dg/lookup/missing-std-include-5.C: Limit test to C++14 and up.
+	* g++.dg/lookup/missing-std-include-6.C: Don't check make_unique in
+	test that runs for C++11.
+	* g++.dg/lookup/missing-std-include-8.C: Check make_unique here.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/87991
+	* gfortran.dg/pr87991.f90: New test.
+
+2013-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90563
+	* gfortran.dg/do_subsript_5.f90: New test.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88072
+	* gfortran.dg/pr88072.f90: New test.
+	* gfortran.dg/unlimited_polymorphic_28.f90: Fix error message.
+
+2019-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90561
+	* gfortran.dg/deferred_character_34.f90: New test.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/89647
+	* gfortran.dg/pr89647.f90: New test.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/87993
+	* gfortran.dg/pr87993.f90: New test.
+
+2019-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91424
+	* gfortran.dg/do_subscript_3.f90: New test.
+	* gfortran.dg/do_subscript_4.f90: New test.
+	* gfortran.dg/pr70754.f90: Use indices that to not overflow.
+
+2019-08-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91359
+	* gfortran.dg/pr91359_1.f: New test.
+	* gfortran.dg/pr91359_2.f: Ditto.
+
+2019-08-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/42546
+	* gfortran.dg/allocated_1.f90: New test.
+	* gfortran.dg/allocated_2.f90: Ditto.
+
+2019-08-02  Tom Honermann  <tom@honermann.net>
+
+	PR c++/88095
+	* g++.dg/cpp2a/udlit-class-nttp-ctad.C: New test.
+	* g++.dg/cpp2a/udlit-class-nttp-ctad-neg.C: New test.
+	* g++.dg/cpp2a/udlit-class-nttp-ctad-neg2.C: New test.
+	* g++.dg/cpp2a/udlit-class-nttp.C: New test.
+	* g++.dg/cpp2a/udlit-class-nttp-neg.C: New test.
+	* g++.dg/cpp2a/udlit-class-nttp-neg2.C: New test.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
Index: gcc/testsuite/g++.dg/lookup/missing-std-include-8.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/lookup/missing-std-include-8.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/lookup/missing-std-include-8.C	(.../branches/gcc-9-branch)
@@ -13,6 +13,15 @@
   // { dg-error "expected primary-expression before '\\)' token" "" { target *-*-* } .-3 }
 }
 
+template<class T>
+void test_make_unique ()
+{
+  std::make_unique<T>(); // { dg-error "'make_unique' is not a member of 'std'" }
+  // { dg-message "'std::make_unique' is only available from C\\+\\+14 onwards" "" { target *-*-* } .-1 }
+  // { dg-error "expected primary-expression before '>' token" "" { target *-*-* } .-2 }
+  // { dg-error "expected primary-expression before '\\)' token" "" { target *-*-* } .-3 }
+}
+
 void test_array ()
 {
   std::array a; // { dg-error "'array' is not a member of 'std'" }
Index: gcc/testsuite/g++.dg/lookup/missing-std-include-5.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/lookup/missing-std-include-5.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/lookup/missing-std-include-5.C	(.../branches/gcc-9-branch)
@@ -1,2 +1,3 @@
+// { dg-do compile { target c++14 } }
 using namespace std::complex_literals; // { dg-error "" }
 // { dg-message "#include <complex>" "" { target *-*-* } .-1 }
Index: gcc/testsuite/g++.dg/lookup/missing-std-include-6.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/lookup/missing-std-include-6.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/lookup/missing-std-include-6.C	(.../branches/gcc-9-branch)
@@ -11,15 +11,6 @@
   // { dg-error "expected primary-expression before '\\)' token" "" { target *-*-* } .-3 }
 }
 
-template<class T>
-void test_make_unique ()
-{
-  auto p = std::make_unique<T>(); // { dg-error "'make_unique' is not a member of 'std'" }
-  // { dg-message "'#include <memory>'" "" { target *-*-* } .-1 }
-  // { dg-error "expected primary-expression before '>' token" "" { target *-*-* } .-2 }
-  // { dg-error "expected primary-expression before '\\)' token" "" { target *-*-* } .-3 }
-}
-
 std::shared_ptr<int> test_shared_ptr; // { dg-error "'shared_ptr' in namespace 'std' does not name a template type" }
 // { dg-message "'#include <memory>'" "" { target *-*-* } .-1 }
 
Index: gcc/testsuite/g++.dg/warn/Wsign-conversion-5.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/warn/Wsign-conversion-5.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/warn/Wsign-conversion-5.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,18 @@
+// PR c++/87519 - bogus warning with -Wsign-conversion.
+// { dg-options "-Wsign-conversion" }
+
+typedef unsigned long int uint64_t;
+
+void f(unsigned long int a, int q)
+{
+  a += a + q; // { dg-warning "may change the sign" }
+
+  // Explicit cast should disable the warning.
+  a = a + static_cast<uint64_t>(q);
+  a = a + (uint64_t) q;
+  a = a + uint64_t(q);
+  a = a + static_cast<const uint64_t>(q);
+  a = a + (const uint64_t) q;
+  a = a + static_cast<unsigned long int>(q);
+  a = a + static_cast<const unsigned long int>(q);
+}
Index: gcc/testsuite/g++.dg/warn/ctor-dtor-privacy-4.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/warn/ctor-dtor-privacy-4.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/warn/ctor-dtor-privacy-4.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,5 @@
+// PR c++/90884
+// { dg-options "-Wctor-dtor-privacy" }
+// { dg-prune-output "In file included from" }
+
+#include "ctor-dtor-privacy-4.h"  // { dg-bogus "is public" }
Index: gcc/testsuite/g++.dg/warn/ctor-dtor-privacy-4.h
===================================================================
--- a/src/gcc/testsuite/g++.dg/warn/ctor-dtor-privacy-4.h	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/warn/ctor-dtor-privacy-4.h	(.../branches/gcc-9-branch)
@@ -0,0 +1,7 @@
+#pragma GCC system_header
+
+namespace std {
+struct __nonesuch {
+  __nonesuch(__nonesuch const &);
+};
+} // namespace std
Index: gcc/testsuite/g++.dg/cpp0x/lambda/lambda-variadic9.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-variadic9.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-variadic9.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,16 @@
+// PR c++/90538
+// { dg-do compile { target c++11 } }
+
+template <class... Ts>
+void f(Ts... ts)
+{
+  [=]{
+    f(ts...);
+    f(ts...);
+  }();
+}
+
+void g()
+{
+  f(1);
+}
Index: gcc/testsuite/g++.dg/cpp0x/gen-attrs-68.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/gen-attrs-68.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/gen-attrs-68.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,40 @@
+// PR c++/81429 - wrong parsing of constructor with C++11 attribute.
+// { dg-do compile { target c++11 } }
+// { dg-additional-options "-Wunused-parameter -Wno-pedantic" }
+
+void fn1([[maybe_unused]] int a) { }
+void fn2(int a [[maybe_unused]]) { }
+void fn3(__attribute__((unused)) int a) { }
+void fn4(int a __attribute__((unused))) { }
+
+struct S1 {
+  S1([[maybe_unused]] int a) { }
+};
+
+struct S2 {
+  S2([[maybe_unused]] int f, [[maybe_unused]] int a) { }
+};
+
+struct S3 {
+  S3(int a [[maybe_unused]]) { }
+};
+
+struct S4 {
+  S4(int f [[maybe_unused]], int a [[maybe_unused]]) { }
+};
+
+struct S5 {
+  S5(__attribute__((unused)) int a) { }
+};
+
+struct S6 {
+  S6(__attribute__((unused)) int f, __attribute__((unused)) int a) { }
+};
+
+struct S7 {
+  S7(int a __attribute__((unused))) { }
+};
+
+struct S8 {
+  S8(int f __attribute__((unused)), int a __attribute__((unused))) { }
+};
Index: gcc/testsuite/g++.dg/cpp0x/gen-attrs-69.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/gen-attrs-69.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/gen-attrs-69.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,40 @@
+// PR c++/81429 - wrong parsing of constructor with C++11 attribute.
+// { dg-do compile { target c++11 } }
+// { dg-additional-options "-Wno-pedantic" }
+
+void fn1([[maybe_unused]] int);
+void fn2(int a [[maybe_unused]]);
+void fn3(__attribute__((unused)) int);
+void fn4(int __attribute__((unused)));
+
+struct S1 {
+  S1([[maybe_unused]] int);
+};
+
+struct S2 {
+  S2([[maybe_unused]] int, [[maybe_unused]] int);
+};
+
+struct S3 {
+  S3(int a [[maybe_unused]]);
+};
+
+struct S4 {
+  S4(int a [[maybe_unused]], int b [[maybe_unused]]);
+};
+
+struct S5 {
+  S5(__attribute__((unused)) int);
+};
+
+struct S6 {
+  S6(__attribute__((unused)) int, __attribute__((unused)) int);
+};
+
+struct S7 {
+  S7(int __attribute__((unused)));
+};
+
+struct S8 {
+  S8(int __attribute__((unused)), int __attribute__((unused)));
+};
Index: gcc/testsuite/g++.dg/cpp0x/nullptr42.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/nullptr42.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/nullptr42.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,18 @@
+// PR c++/90473 - wrong code with nullptr in default argument.
+// { dg-do run { target c++11 } }
+
+int g;
+void f() { g++; }
+
+void fn1 (void* p = (f(), nullptr)) { }
+void fn2 (int p = (f(), 0)) { }
+
+int main()
+{
+  fn1 ();
+  if (g != 1)
+    __builtin_abort ();
+  fn2 ();
+  if (g != 2)
+    __builtin_abort ();
+}
Index: gcc/testsuite/g++.dg/cpp0x/range-for19.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/range-for19.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/range-for19.C	(.../branches/gcc-9-branch)
@@ -5,6 +5,6 @@
 int main()
 {
   auto a;        // { dg-error "no initializer" }
-  for(auto i: a) // { dg-error "deduce" }
+  for(auto i: a)
     ;
 }
Index: gcc/testsuite/g++.dg/cpp1y/dr1560.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/dr1560.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/dr1560.C	(.../branches/gcc-9-branch)
@@ -1,14 +0,0 @@
-// Core 1560
-// { dg-do compile { target c++14 } }
-
-struct A
-{
-  A();
-  A(const A&) = delete;
-};
-
-void f(bool b)
-{
-  A a;
-  b ? a : throw 42;
-}
Index: gcc/testsuite/g++.dg/cpp1y/lambda-init16.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/lambda-init16.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/lambda-init16.C	(.../branches/gcc-9-branch)
@@ -3,7 +3,7 @@
 
 template < class T = int > void f (T)
 {
-  auto g = [&a = f] () {};  // { dg-error "invalid initialization" }
+  auto g = [&a = f] () {};  // { dg-error "auto" }
 }
 
 int main ()
Index: gcc/testsuite/g++.dg/cpp1y/auto-fn56.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/auto-fn56.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/auto-fn56.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,19 @@
+// PR c++/91378
+// { dg-do compile { target c++14 } }
+
+struct B
+{
+  int i;
+};
+
+struct C
+{
+  template <class T> static auto
+  g(B b) noexcept(noexcept(b.i)) { }
+};
+
+template <class T>
+void h(T t)
+{
+  C::g<int>({});
+}
Index: gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-neg2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-neg2.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-neg2.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,13 @@
+// PR c++/88095
+// Test class non-type template parameters for literal operator templates.
+// Validate that non-literal class types are rejected.
+// { dg-do compile { target c++2a } }
+
+struct non_literal_class {
+  constexpr non_literal_class(...) { }
+  ~non_literal_class() {}
+  // auto operator<=> (const non_literal_fixed_string&) = default;
+};
+
+template <non_literal_class> // { dg-error "11:is not a valid type for a template non-type parameter because it is not literal" }
+int operator"" _udl();       // { dg-error "literal operator template .int operator\"\"_udl\\(\\). has invalid parameter list" }
Index: gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,24 @@
+// PR c++/88095
+// Test class non-type template parameters for literal operator templates.
+// Validate support for class template argument deduction.
+// { dg-do compile { target c++2a } }
+
+namespace std {
+using size_t = decltype(sizeof(int));
+}
+
+template <typename CharT, std::size_t N>
+struct fixed_string {
+  constexpr static std::size_t length = N;
+  constexpr fixed_string(...) { }
+  // auto operator<=> (const fixed_string&) = default;
+};
+template <typename CharT, std::size_t N>
+fixed_string(const CharT (&str)[N]) -> fixed_string<CharT, N>;
+
+template <fixed_string fs>
+constexpr std::size_t operator"" _udl() {
+  return decltype(fs)::length;
+}
+
+static_assert("test"_udl == 5);
Index: gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,16 @@
+// PR c++/88095
+// Test class non-type template parameters for literal operator templates.
+// Validate basic support.
+// { dg-do compile { target c++2a } }
+
+struct literal_class {
+  constexpr literal_class(...) { }
+  // auto operator<=> (const fixed_string&) = default;
+};
+
+template <literal_class>
+constexpr int operator"" _udl() {
+  return 1;
+}
+
+static_assert("test"_udl == 1);
Index: gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad-neg2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad-neg2.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad-neg2.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,20 @@
+// PR c++/88095
+// Test class non-type template parameters for literal operator templates.
+// Validate rejection of class template parameter packs.
+// { dg-do compile { target c++2a } }
+
+namespace std {
+using size_t = decltype(sizeof(int));
+}
+
+template <typename CharT, std::size_t N>
+struct fixed_string {
+  constexpr static std::size_t length = N;
+  constexpr fixed_string(...) { }
+  // auto operator<=> (const fixed_string&) = default;
+};
+template <typename CharT, std::size_t N>
+fixed_string(const CharT (&str)[N]) -> fixed_string<CharT, N>;
+
+template <fixed_string...>
+int operator"" _udl();     // { dg-error "literal operator template .int operator\"\"_udl\\(\\). has invalid parameter list" }
Index: gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-neg.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-neg.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-neg.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,12 @@
+// PR c++/88095
+// Test class non-type template parameters for literal operator templates.
+// Validate that parameter packs are rejected.
+// { dg-do compile { target c++2a } }
+
+struct literal_class {
+  constexpr literal_class(...) { }
+  // auto operator<=> (const fixed_string&) = default;
+};
+
+template <literal_class...>
+int operator"" _udl();      // { dg-error "literal operator template .int operator\"\"_udl\\(\\). has invalid parameter list" }
Index: gcc/testsuite/g++.dg/cpp2a/nontype-class23.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp2a/nontype-class23.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp2a/nontype-class23.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,102 @@
+// PR c++/90947 - Simple lookup table of array of strings is miscompiled
+// Test to verify that the same specializations on non-type template
+// parameters of class types are in fact treated as the same.  Unlike
+// nontype-class15.C which involves only one-dimensional arrays this
+// test involves arrays of arrays and arrays of structs.
+// { dg-do compile { target c++2a } }
+
+struct AA3
+{
+  const char a[2][2][2];
+};
+
+template <AA3> struct BAA3 { };
+
+// Redeclare the same variable using different initialization forms
+// of the same constant to verify that they are in fact all recognized
+// as the same.
+extern BAA3<AA3{{{ "", "" }, { "", "" }}}>       baa3;
+extern BAA3<AA3{{{ "", "" }, { "", { 0, 0 } }}}> baa3;
+extern BAA3<AA3{{{ "", "" }, { "", { 0 } }}}>    baa3;
+extern BAA3<AA3{{{ "", "" }, { "", {} }}}>       baa3;
+extern BAA3<AA3{{{ "", "" }, { "" }}}>           baa3;
+extern BAA3<AA3{{{ "", "" }, { { 0, 0 } }}}>     baa3;
+extern BAA3<AA3{{{ "", "" }, { { 0 } }}}>        baa3;
+extern BAA3<AA3{{{ "", "" }, { {} }}}>           baa3;
+extern BAA3<AA3{{{ "", "" }, { }}}>              baa3;
+extern BAA3<AA3{{{ "", "" }}}>                   baa3;
+extern BAA3<AA3{{{ "", { 0, 0 } }}}>             baa3;
+extern BAA3<AA3{{{ "", { 0 } }}}>                baa3;
+extern BAA3<AA3{{{ "", {} }}}>                   baa3;
+extern BAA3<AA3{{{ "" }}}>                       baa3;
+extern BAA3<AA3{{{ { 0, 0 } }}}>                 baa3;
+extern BAA3<AA3{{{ { 0 } }}}>                    baa3;
+extern BAA3<AA3{{{ {} }}}>                       baa3;
+extern BAA3<AA3{{{ }}}>                          baa3;
+extern BAA3<AA3{{ }}>                            baa3;
+extern BAA3<AA3{ }>                              baa3;
+
+extern BAA3<AA3{{{ "", "" }, { "", "1" }}}>        baa3_1;
+extern BAA3<AA3{{{ "", "" }, { "", { '1', 0 } }}}> baa3_1;
+extern BAA3<AA3{{{ "", "" }, { "", { '1' } }}}>    baa3_1;
+
+extern BAA3<AA3{{{ "", "" }, { "1", {} }}}>        baa3_2;
+extern BAA3<AA3{{{ "", "" }, { "1" }}}>            baa3_2;
+extern BAA3<AA3{{{ "", "" }, { { '1', 0 } }}}>     baa3_2;
+extern BAA3<AA3{{{ "", "" }, { { '1' } }}}>        baa3_2;
+
+extern BAA3<AA3{{{ "", "1" }}}>                    baa3_3;
+extern BAA3<AA3{{{ "", { '1', 0 } }}}>             baa3_3;
+extern BAA3<AA3{{{ "", { '1' } }}}>                baa3_3;
+
+extern BAA3<AA3{{{ "1" }}}>                        baa3_4;
+extern BAA3<AA3{{{ { '1', 0 } }}}>                 baa3_4;
+extern BAA3<AA3{{{ { '1' } }}}>                    baa3_4;
+
+struct AS2
+{
+  struct S { const char a[2], *p; } a[2];
+};
+
+template <AS2> struct BAS2 { };
+
+extern BAS2<AS2{{{ "", 0 }, { "", 0 }}}> bas2;
+extern BAS2<AS2{{{ "", 0 }, { {}, 0 }}}> bas2;
+extern BAS2<AS2{{{ "", 0 }, { "" }}}>    bas2;
+extern BAS2<AS2{{{ "", 0 }, { {} }}}>    bas2;
+extern BAS2<AS2{{{ "", 0 }, { }}}>       bas2;
+extern BAS2<AS2{{{ "", 0 }}}>            bas2;
+extern BAS2<AS2{{{ {}, 0 }}}>            bas2;
+extern BAS2<AS2{{{ "" }}}>               bas2;
+extern BAS2<AS2{{{ {} }}}>               bas2;
+extern BAS2<AS2{{{ }}}>                  bas2;
+extern BAS2<AS2{{ }}>                    bas2;
+extern BAS2<AS2{ }>                      bas2;
+
+struct AS2_2
+{
+  struct S { const char a[2], *p; } a[2][2];
+};
+
+template <AS2_2> struct BAS2_2 { };
+
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { "", 0 }, { "", 0 }}}}> b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { "", 0 }, { "" }}}}>    b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { "", 0 }, { {} }}}}>    b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { "", 0 }, { }}}}>       b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { "", 0 } }}}>           b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { "" } }}}>              b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { {} } }}}>              b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { }}}}>                  b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { }}}>                     b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 }}}}>                           b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "" }}}}>                              b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { {} }}}}>                              b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { }}}}>                                 b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }}}}>                                      b2_2;
+extern BAS2_2<AS2_2{{{{ "" }}}}>                                         b2_2;
+extern BAS2_2<AS2_2{{{{ {} }}}}>                                         b2_2;
+extern BAS2_2<AS2_2{{{{ }}}}>                                            b2_2;
+extern BAS2_2<AS2_2{{{ }}}>                                              b2_2;
+extern BAS2_2<AS2_2{{ }}>                                                b2_2;
+extern BAS2_2<AS2_2{ }>                                                  b2_2;
Index: gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad-neg.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad-neg.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad-neg.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,24 @@
+// PR c++/88095
+// Test class non-type template parameters for literal operator templates.
+// Validate handling of failed class template argument deduction.
+// { dg-do compile { target c++2a } }
+
+namespace std {
+using size_t = decltype(sizeof(int));
+}
+
+template <typename CharT, std::size_t N>
+struct fixed_string {
+  constexpr static std::size_t length = N;
+  constexpr fixed_string(...) { }
+  // auto operator<=> (const fixed_string&) = default;
+};
+// Missing deduction guide.
+
+template <fixed_string fs>
+constexpr std::size_t operator"" _udl() {
+  return decltype(fs)::length;
+}
+
+static_assert("test"_udl == 5); // { dg-error "15:no matching function for call to" }
+                                // { dg-error "15:class template argument deduction failed" "" { target *-*-* } .-1 }
Index: gcc/testsuite/g++.dg/expr/cond16.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/expr/cond16.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/expr/cond16.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,25 @@
+// PR c++/90393
+// { dg-do run }
+
+int c, d;
+
+struct string {
+  string(const char *p): s(p) { ++c; }
+  ~string() { ++d; }
+  string(const string& str): s(str.s) { ++c; }
+  const char* s;
+  bool empty() const { return !s; }
+};
+    
+string foo()
+{
+  string s("foo");
+  return s.empty() ? throw "empty" : s;
+}
+
+int main()
+{
+  foo();
+  if (c != d)
+    __builtin_abort();
+}
Index: gcc/testsuite/g++.dg/expr/cond15.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/expr/cond15.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/expr/cond15.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,13 @@
+// PR c++/90393
+
+struct S {
+  S();
+  S(const S&) {}
+};
+
+S f() {
+  const S m;
+  return true ? m : throw 0;
+}
+
+int main() {}
Index: gcc/testsuite/g++.dg/abi/mangle73.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/abi/mangle73.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/abi/mangle73.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,96 @@
+// { dg-do compile { target c++2a } }
+
+struct A
+{
+  char a[2][2];
+};
+
+template <A> struct B { };
+
+typedef B<A{ { { 0, 0 }, { 0, 0 } } }> AZZZZ;
+typedef B<A{ { { 0, 0 }, { 0 } } }>    AZZZ_;
+typedef B<A{ { { 0, 0 } } }>           AZZ__;
+typedef B<A{ { { 0 } } }>              AZ___;
+typedef B<A{ { { } } }>                A____;
+
+typedef B<A{ { { "" }, { "" } } }>     AS_S_;
+typedef B<A{ { { "" }, { 0, 0 } } }>   AS_ZZ;
+typedef B<A{ { { "" }, { 0 } } }>      AS_Z_;
+typedef B<A{ { { "" } } }>             AS___;
+
+
+// Verify that the types mangle the same.
+void a_zzzz (AZZZZ) { }
+// { dg-final { scan-assembler "_Z6a_zzzz1BIXtl1AEEE" } }
+
+void a_zzz_ (AZZZ_) { }
+// { dg-final { scan-assembler "_Z6a_zzz_1BIXtl1AEEE" } }
+
+void a_zz__ (AZZ__) { }
+// { dg-final { scan-assembler "_Z6a_zz__1BIXtl1AEEE" } }
+
+void a_z___ (AZ___) { }
+// { dg-final { scan-assembler "_Z6a_z___1BIXtl1AEEE" } }
+
+void a_____ (A____) { }
+// { dg-final { scan-assembler "_Z6a_____1BIXtl1AEEE" } }
+
+void a_s_s_ (AS_S_) { }
+// { dg-final { scan-assembler "_Z6a_s_s_1BIXtl1AEEE" } }
+
+void a_s_zz (AS_ZZ) { }
+// { dg-final { scan-assembler "_Z6a_s_zz1BIXtl1AEEE" } }
+
+void a_s_z_ (AS_Z_) { }
+// { dg-final { scan-assembler "_Z6a_s_z_1BIXtl1AEEE" } }
+
+void a_s___ (AS___) { }
+// { dg-final { scan-assembler "_Z6a_s___1BIXtl1AEEE" } }
+
+
+struct C
+{
+  struct { const char a[2][2], *p; } a[2];
+};
+
+template <C> struct D { };
+
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }, {{{ 0, 0 }, { 0, 0 }}, 0 }}}> DZZZZZZZZZZ;
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }, {{{ 0, 0 }, { 0, 0 }}}}}> DZZZZZZZZZ_;
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }, {{{ 0, 0 }, { 0 }}}}}>    DZZZZZZZZ__;
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }, {{{ 0, 0 } }}}}>          DZZZZZZZ___;
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }, {{{ 0 } }}}}>             DZZZZZZ____;
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }}}>                         DZZZZZ_____;
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}}}}>                             DZZZZ______;
+typedef D<C{{{{{ 0, 0 }, { 0 }}}}}>                                DZZZ_______;
+typedef D<C{{{{{ 0, 0 }}}}}>                                       DZZ________;
+typedef D<C{{{{{ 0 }}}}}>                                          DZ_________;
+typedef D<C{ }>                                                    D__________;
+
+typedef D<C{{{{{ "" }, { "" }}, 0 }, {{{ "" }, { "" }}, 0 }}}>     DS_S_ZS_S_Z;
+
+void d_zzzzzzzzzz (DZZZZZZZZZZ) { }
+// { dg-final { scan-assembler "_Z12d_zzzzzzzzzz1DIXtl1CEEE" } }
+void d_zzzzzzzzz_ (DZZZZZZZZZ_) { }
+// { dg-final { scan-assembler "_Z12d_zzzzzzzzz_1DIXtl1CEEE" } }
+void d_zzzzzzzz__ (DZZZZZZZZ__) { }
+// { dg-final { scan-assembler "_Z12d_zzzzzzzz__1DIXtl1CEEE" } }
+void d_zzzzzzz___ (DZZZZZZZ___) { }
+// { dg-final { scan-assembler "_Z12d_zzzzzzz___1DIXtl1CEEE" } }
+void d_zzzzzz____ (DZZZZZZ____) { }
+// { dg-final { scan-assembler "_Z12d_zzzzzz____1DIXtl1CEEE" } }
+void d_zzzzz_____ (DZZZZZ_____) { }
+// { dg-final { scan-assembler "_Z12d_zzzzz_____1DIXtl1CEEE" } }
+void d_zzzz______ (DZZZZ______) { }
+// { dg-final { scan-assembler "_Z12d_zzzz______1DIXtl1CEEE" } }
+void d_zzz_______ (DZZZ_______) { }
+// { dg-final { scan-assembler "_Z12d_zzz_______1DIXtl1CEEE" } }
+void d_zz________ (DZZ________) { }
+// { dg-final { scan-assembler "_Z12d_zz________1DIXtl1CEEE" } }
+void d_z_________ (DZ_________) { }
+// { dg-final { scan-assembler "_Z12d_z_________1DIXtl1CEEE" } }
+void d___________ (D__________) { }
+// { dg-final { scan-assembler "_Z12d___________1DIXtl1CEEE" } }
+
+void d_s_s_zs_s_z (DS_S_ZS_S_Z) { }
+// { dg-final { scan-assembler "_Z12d_s_s_zs_s_z1DIXtl1CEEE" } }
Index: gcc/testsuite/g++.dg/init/array53.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/init/array53.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/init/array53.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,33 @@
+// PR c++/90947 - Simple lookup table of array of strings is miscompiled
+// Verify that initializers for arrays of elements of a class type with
+// "unusual" data members are correctly recognized as non-zero.
+// { dg-do compile }
+// { dg-options "-O1 -fdump-tree-optimized" }
+
+struct S
+{
+  const char *p;
+  static int i;
+  enum { e };
+  typedef int X;
+  int: 1, b:1;
+  union {
+    int c;
+  };
+  const char *q;
+};
+
+void f (void)
+{
+  const struct S a[2] =
+    {
+     { /* .p = */ "", /* .b = */ 0, /* .c = */ 0, /* .q = */ "" },
+     { /* .p = */ "", /* .b = */ 0, /* .c = */ 0, /* .q = */ "" }
+    };
+
+  if (!a[0].p || *a[0].p || !a[0].q || *a[0].q
+      || !a[1].p || *a[1].p || !a[1].q || *a[1].q)
+    __builtin_abort ();
+}
+
+// { dg-final { scan-tree-dump-not "abort" "optimized" } }
Index: gcc/testsuite/c-c++-common/array-1.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/array-1.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/c-c++-common/array-1.c	(.../branches/gcc-9-branch)
@@ -0,0 +1,247 @@
+// PR c++/90947 - Simple lookup table of array of strings is miscompiled
+// { dg-do compile }
+// { dg-options "-O1 -fdump-tree-optimized" }
+
+#define assert(expr) ((expr) ? (void)0 : __builtin_abort ())
+
+void pr90947 (void)
+{
+  int vecsize = 4;
+  int index = 0;
+  static const char *a[4][4] =
+    {
+     { ".x", ".y", ".z", ".w" },
+     { ".xy", ".yz", ".zw", 0 },
+     { ".xyz", ".yzw", 0, 0 },
+     { "", 0, 0, 0 },
+    };
+
+  assert (vecsize >= 1 && vecsize <= 4);
+  assert (index >= 0 && index < 4);
+  assert (a[vecsize - 1][index]);
+}
+
+void f_a1_1 (void)
+{
+  {
+    const char* a[1][1] = { { 0 } };
+    assert (0 == a[0][0]);
+  }
+  {
+    const char* a[1][1] = { { "" } };
+    assert ('\0' == *a[0][0]);
+  }
+}
+
+void f_a2_1 (void)
+{
+  {
+    const char* a[2][1] = { { "" }, { "" } };
+    assert ('\0' == *a[0][0] && '\0' == *a[1][0]);
+  }
+  {
+    const char* a[2][1] = { { 0 }, { "" } };
+    assert (0 == a[0][0] && '\0' == *a[1][0]);
+  }
+  {
+    const char* a[2][1] = { { }, { "" } };
+    assert (0 == a[0][0] && '\0' == *a[1][0]);
+  }
+}
+
+void f_a2_2 (void)
+{
+  {
+    const char* a[2][2] = { { "", "" }, { "", "" } };
+    assert ('\0' == *a[0][0] && '\0' == *a[0][1]);
+    assert ('\0' == *a[1][0] && '\0' == *a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { "", "" }, { "", 0 } };
+    assert ('\0' == *a[0][0] && '\0' == *a[0][1]);
+    assert ('\0' == *a[1][0] && 0 == a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { "", "" }, { "" } };
+    assert ('\0' == *a[0][0] && '\0' == *a[0][1]);
+    assert ('\0' == *a[1][0] && 0 == a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { "", "" }, { 0, "" } };
+    assert ('\0' == *a[0][0] && '\0' == *a[0][1]);
+    assert (0 == a[1][0] && '\0' == *a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { "", 0 }, { 0, "" } };
+    assert ('\0' == *a[0][0] && 0 == a[0][1]);
+    assert (0 == a[1][0] && '\0' == *a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { 0, 0 }, { 0, "" } };
+    assert (0 == a[0][0] && 0 == a[0][1]);
+    assert (0 == a[1][0] && '\0' == *a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { 0 }, { 0, "" } };
+    assert (0 == a[0][0] && 0 == a[0][1]);
+    assert (0 == a[1][0] && '\0' == *a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { }, { 0, "" } };
+    assert (0 == a[0][0] && 0 == a[0][1]);
+    assert (0 == a[1][0] && '\0' == *a[1][1]);
+  }
+}
+
+void f_a2_2_2 (void)
+{
+  {
+    const char* a[2][2][2] =
+      { { { "", "" }, { "", "" } }, { { "", "" }, { "", "" } } };
+
+    assert ('\0' == *a[0][0][0] && '\0' == *a[0][0][1]);
+    assert ('\0' == *a[0][1][0] && '\0' == *a[0][1][1]);
+    assert ('\0' == *a[1][0][0] && '\0' == *a[1][0][1]);
+    assert ('\0' == *a[1][1][0] && '\0' == *a[1][1][1]);
+  }
+
+  {
+    const char* a[2][2][2] =
+      { { { "", "" }, { "", "" } }, { { "", "" }, { 0, "" } } };
+
+    assert ('\0' == *a[0][0][0] && '\0' == *a[0][0][1]);
+    assert ('\0' == *a[0][1][0] && '\0' == *a[0][1][1]);
+    assert ('\0' == *a[1][0][0] && '\0' == *a[1][0][1]);
+    assert (0 == a[1][1][0] && '\0' == *a[1][1][1]);
+  }
+
+  {
+    const char* a[2][2][2] =
+      { { { "", "" }, { "", "" } }, { { 0, 0 }, { 0, "" } } };
+
+    assert ('\0' == *a[0][0][0] && '\0' == *a[0][0][1]);
+    assert ('\0' == *a[0][1][0] && '\0' == *a[0][1][1]);
+    assert (0 == a[1][0][0] && 0 == a[1][0][1]);
+    assert (0 == a[1][1][0] && '\0' == *a[1][1][1]);
+  }
+
+  {
+    const char* a[2][2][2] =
+      { { { "", "" }, { 0, 0 } }, { { 0, 0 }, { 0, "" } } };
+
+    assert ('\0' == *a[0][0][0] && '\0' == *a[0][0][1]);
+    assert (0 == a[0][1][0] && 0 == a[0][1][1]);
+    assert (0 == a[1][0][0] && 0 == a[1][0][1]);
+    assert (0 == a[1][1][0] && '\0' == *a[1][1][1]);
+  }
+
+  {
+    const char* a[2][2][2] =
+      { { { 0, 0 }, { 0, 0 } }, { { 0, 0 }, { 0, "" } } };
+
+    assert (0 == a[0][0][0] && 0 == a[0][0][1]);
+    assert (0 == a[0][1][0] && 0 == a[0][1][1]);
+    assert (0 == a[1][0][0] && 0 == a[1][0][1]);
+    assert (0 == a[1][1][0] && '\0' == *a[1][1][1]);
+  }
+
+  {
+    const char* a[2][2][2] =
+      { { { }, { } }, { { }, { 0, "" } } };
+
+    assert (0 == a[0][0][0] && 0 == a[0][0][1]);
+    assert (0 == a[0][1][0] && 0 == a[0][1][1]);
+    assert (0 == a[1][0][0] && 0 == a[1][0][1]);
+    assert (0 == a[1][1][0] && '\0' == *a[1][1][1]);
+  }
+}
+
+void f_sa2_2_2 (void)
+{
+  struct S { const char a[2], *s, c; };
+
+  {
+    const struct S a[2][2][2] = {
+      { },
+      {
+        { { }, { "", "" } },
+        { }
+      }
+    };
+
+    assert ('\0' == *a[0][0][0].a && 0 == a[0][0][0].s && 0 == a[0][0][0].c);
+    assert ('\0' == *a[0][0][1].a && 0 == a[0][0][1].s && 0 == a[0][0][1].c);
+    assert ('\0' == *a[0][1][0].a && 0 == a[0][1][0].s && 0 == a[0][1][0].c);
+    assert ('\0' == *a[0][1][1].a && 0 == a[0][1][1].s && 0 == a[0][1][1].c);
+
+    assert ('\0' == *a[1][0][0].a && 0 == a[1][0][0].s && 0 == a[1][0][0].c);
+    assert ('\0' == *a[1][0][1].a && '\0' == *a[1][0][1].s && 0 == a[1][0][1].c);
+    assert ('\0' == *a[1][1][0].a && 0 == a[1][1][0].s && 0 == a[1][1][0].c);
+    assert ('\0' == *a[1][1][1].a && 0 == a[1][1][1].s && 0 == a[1][1][1].c);
+  }
+
+  {
+    const struct S a[2][2][2] = {
+      { },
+      {
+        { { } },
+        { { "", "" } }
+      }
+    };
+
+    assert ('\0' == *a[0][0][0].a && 0 == a[0][0][0].s);
+    assert ('\0' == *a[0][0][1].a && 0 == a[0][0][1].s);
+    assert ('\0' == *a[0][1][0].a && 0 == a[0][1][0].s);
+    assert ('\0' == *a[0][1][1].a && 0 == a[0][1][1].s);
+
+    assert ('\0' == *a[1][0][0].a && 0 == a[1][0][0].s);
+    assert ('\0' == *a[1][0][1].a && 0 == a[1][0][1].s);
+    assert ('\0' == *a[1][1][0].a && '\0' == *a[1][1][0].s);
+    assert ('\0' == *a[1][1][1].a && 0 == a[1][1][1].s);
+  }
+
+  {
+    const struct S a[2][2][2] = {
+      { },
+      {
+        { { }, { } },
+        { { }, { "", "", 0 } }
+      }
+    };
+
+    assert ('\0' == *a[0][0][0].a && 0 == a[0][0][0].s);
+    assert ('\0' == *a[0][0][1].a && 0 == a[0][0][1].s);
+    assert ('\0' == *a[0][1][0].a && 0 == a[0][1][0].s);
+    assert ('\0' == *a[0][1][1].a && 0 == a[0][1][1].s);
+
+    assert ('\0' == *a[1][0][0].a && 0 == a[1][0][0].s);
+    assert ('\0' == *a[1][0][1].a && 0 == a[1][0][1].s);
+    assert ('\0' == *a[1][1][0].a && 0 == a[1][1][0].s);
+    assert ('\0' == *a[1][1][1].a && '\0' == *a[1][1][1].s);
+  }
+
+  {
+    const struct S a[2][2][2] = {
+      {
+       { { { 0 }, 0, 0 }, { { 0 } , 0, 0 } },
+       { { { 0 }, 0, 0 }, { { 0 } , 0, 0 } },
+      },
+      {
+       { { { 0 }, 0, 0 }, { { 0 } , 0, 0 } },
+       { { }, { "", "", 0 } }
+      }
+    };
+
+    assert ('\0' == *a[0][0][0].a && 0 == a[0][0][0].s);
+    assert ('\0' == *a[0][0][1].a && 0 == a[0][0][1].s);
+    assert ('\0' == *a[0][1][0].a && 0 == a[0][1][0].s);
+    assert ('\0' == *a[0][1][1].a && 0 == a[0][1][1].s);
+
+    assert ('\0' == *a[1][0][0].a && 0 == a[1][0][0].s);
+    assert ('\0' == *a[1][0][1].a && 0 == a[1][0][1].s);
+    assert ('\0' == *a[1][1][0].a && 0 == a[1][1][0].s);
+    assert ('\0' == *a[1][1][1].a && '\0' == *a[1][1][1].s);
+  }
+}
+
+// { dg-final { scan-tree-dump-not "abort" "optimized" } }
Index: gcc/cp/typeck.c
===================================================================
--- a/src/gcc/cp/typeck.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/cp/typeck.c	(.../branches/gcc-9-branch)
@@ -5516,9 +5516,9 @@
   if (! converted)
     {
       warning_sentinel w (warn_sign_conversion, short_compare);
-      if (TREE_TYPE (op0) != result_type)
+      if (!same_type_p (TREE_TYPE (op0), result_type))
 	op0 = cp_convert_and_check (result_type, op0, complain);
-      if (TREE_TYPE (op1) != result_type)
+      if (!same_type_p (TREE_TYPE (op1), result_type))
 	op1 = cp_convert_and_check (result_type, op1, complain);
 
       if (op0 == error_mark_node || op1 == error_mark_node)
Index: gcc/cp/class.c
===================================================================
--- a/src/gcc/cp/class.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/cp/class.c	(.../branches/gcc-9-branch)
@@ -2149,10 +2149,10 @@
 
       if (!nonprivate_ctor)
 	{
-	  warning (OPT_Wctor_dtor_privacy,
-		   "%q#T only defines private constructors and has no friends",
-		   t);
-	  if (copy_or_move)
+	  bool w = warning (OPT_Wctor_dtor_privacy,
+			    "%q#T only defines private constructors and has "
+			    "no friends", t);
+	  if (w && copy_or_move)
 	    inform (DECL_SOURCE_LOCATION (copy_or_move),
 		    "%q#D is public, but requires an existing %q#T object",
 		    copy_or_move, t);
Index: gcc/cp/decl.c
===================================================================
--- a/src/gcc/cp/decl.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/cp/decl.c	(.../branches/gcc-9-branch)
@@ -5836,9 +5836,10 @@
       /* Pointers initialized to strings must be treated as non-zero
 	 even if the string is empty.  */
       tree init_type = TREE_TYPE (elt_init);
-      if ((POINTER_TYPE_P (elt_type) != POINTER_TYPE_P (init_type))
-	  || !initializer_zerop (elt_init))
+      if ((POINTER_TYPE_P (elt_type) != POINTER_TYPE_P (init_type)))
 	last_nonzero = index;
+      else if (!type_initializer_zero_p (elt_type, elt_init))
+	last_nonzero = index;
 
       /* This can happen with an invalid initializer (c++/54501).  */
       if (d->cur == old_cur && !sized_array_p)
@@ -13042,7 +13043,9 @@
   /* Avoid redundant -Wzero-as-null-pointer-constant warnings at
      the call sites.  */
   if (TYPE_PTR_OR_PTRMEM_P (decl_type)
-      && null_ptr_cst_p (arg))
+      && null_ptr_cst_p (arg)
+      /* Don't lose side-effects as in PR90473.  */
+      && !TREE_SIDE_EFFECTS (arg))
     return nullptr_node;
 
   /* [dcl.fct.default]
Index: gcc/cp/ChangeLog
===================================================================
--- a/src/gcc/cp/ChangeLog	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/cp/ChangeLog	(.../branches/gcc-9-branch)
@@ -1,3 +1,75 @@
+2019-08-16  Jason Merrill  <jason@redhat.com>
+
+	PR c++/90393 - ICE with throw in ?:
+	* call.c (build_conditional_expr_1): Revert changes from
+	PR c++/64372 and c++/86205.
+
+2019-08-15  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-08-07  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/81429 - wrong parsing of constructor with C++11 attribute.
+	* parser.c (cp_parser_constructor_declarator_p): Handle the scenario
+	when a parameter declaration begins with [[attribute]].
+
+	2019-08-08  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/87519 - bogus warning with -Wsign-conversion.
+	* typeck.c (cp_build_binary_op): Use same_type_p instead of comparing
+	the types directly.
+
+	2019-08-13  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/90473 - wrong code with nullptr in default argument.
+	* call.c (null_ptr_cst_p): Update quote from the standard.
+	* decl.c (check_default_argument): Don't return nullptr when the arg
+	has side-effects.
+
+	2019-06-14  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/90884 - stray note with -Wctor-dtor-privacy.
+	* class.c (maybe_warn_about_overly_private_class): Guard the call to
+	inform.
+
+2019-08-14  Martin Sebor  <msebor@redhat.com>
+
+	Backported from mainline
+	2019-08-01  Martin Sebor  <msebor@redhat.com>
+
+	PR c++/90947
+	* decl.c (reshape_init_array_1): Avoid truncating initializer
+	lists containing string literals.
+
+2019-08-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/91436
+	* name-lookup.c (get_std_name_hint): Fix min_dialect field for
+	complex_literals and make_unique entries.
+
+2019-08-12  Tom Honermann  <tom@honermann.net>
+
+	* parser.c (cp_parser_template_declaration_after_parameters): Enable
+	class template argument deduction for non-type template parameters
+	in literal operator templates.
+
+2019-08-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/91378 - ICE with noexcept and auto return type.
+	* pt.c (maybe_instantiate_noexcept): push_to_top_level.
+
+	PR c++/90538 - multiple expansions of capture packs
+	* cp-tree.h (DECLTYPE_FOR_INIT_CAPTURE): Remove.
+	* lambda.c (add_capture): Copy parameter packs from init.
+	(lambda_capture_field_type): Always use auto for init-capture.
+	* pt.c (uses_parameter_packs): Return tree.
+	(tsubst) [DECLTYPE_TYPE]: Remove init-capture handling.
+	(gen_elem_of_pack_expansion_instantiation): Don't push
+	local_specialization_stack.
+	(prepend_one_capture): New.
+	(tsubst_lambda_expr): Use it.  Don't touch local_specializations.
+	(do_auto_deduction): Avoid redundant error.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
@@ -16,7 +88,7 @@
 
 	Backported from mainline
 	2019-08-02  Marek Polacek  <polacek@redhat.com>
-	
+
 	PR c++/91230 - wrong error with __PRETTY_FUNCTION__ and generic lambda.
 	* pt.c (value_dependent_expression_p): Consider __PRETTY_FUNCTION__
 	inside a template function value-dependent.
Index: gcc/cp/pt.c
===================================================================
--- a/src/gcc/cp/pt.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/cp/pt.c	(.../branches/gcc-9-branch)
@@ -3875,7 +3875,7 @@
 }
 
 /* Determines if the expression or type T uses any parameter packs.  */
-bool
+tree
 uses_parameter_packs (tree t)
 {
   tree parameter_packs = NULL_TREE;
@@ -3885,7 +3885,7 @@
   ppd.type_pack_expansion_p = false;
   cp_walk_tree (&t, &find_parameter_packs_r, &ppd, ppd.visited);
   delete ppd.visited;
-  return parameter_packs != NULL_TREE;
+  return parameter_packs;
 }
 
 /* Turn ARG, which may be an expression, type, or a TREE_LIST
@@ -11757,10 +11757,6 @@
       ARGUMENT_PACK_SELECT_INDEX (aps) = index;
     }
 
-  // Any local specialization bindings arising from this substitution
-  // cannot be reused for a different INDEX.
-  local_specialization_stack lss (lss_copy);
-
   /* Substitute into the PATTERN with the (possibly altered)
      arguments.  */
   if (pattern == in_decl)
@@ -15130,24 +15126,12 @@
 				      /*function_p*/false,
 				      /*integral_constant_expression*/false);
 
-	if (DECLTYPE_FOR_INIT_CAPTURE (t))
-	  {
-	    if (type == NULL_TREE)
-	      {
-		if (complain & tf_error)
-		  error ("empty initializer in lambda init-capture");
-		type = error_mark_node;
-	      }
-	    else if (TREE_CODE (type) == TREE_LIST)
-	      type = build_x_compound_expr_from_list (type, ELK_INIT, complain);
-	  }
-
 	--cp_unevaluated_operand;
 	--c_inhibit_evaluation_warnings;
 
 	if (DECLTYPE_FOR_LAMBDA_CAPTURE (t))
 	  type = lambda_capture_field_type (type,
-					    DECLTYPE_FOR_INIT_CAPTURE (t),
+					    false /*explicit_init*/,
 					    DECLTYPE_FOR_REF_CAPTURE (t));
 	else if (DECLTYPE_FOR_LAMBDA_PROXY (t))
 	  type = lambda_proxy_type (type);
@@ -18014,6 +17998,33 @@
   return t;
 }
 
+/* Subroutine of tsubst_lambda_expr: add the FIELD/INIT capture pair to the
+   LAMBDA_EXPR_CAPTURE_LIST passed in LIST.  Do deduction for a previously
+   dependent init-capture.  */
+
+static void
+prepend_one_capture (tree field, tree init, tree &list,
+		     tsubst_flags_t complain)
+{
+  if (tree auto_node = type_uses_auto (TREE_TYPE (field)))
+    {
+      tree type = NULL_TREE;
+      if (!init)
+	{
+	  if (complain & tf_error)
+	    error ("empty initializer in lambda init-capture");
+	  init = error_mark_node;
+	}
+      else if (TREE_CODE (init) == TREE_LIST)
+	init = build_x_compound_expr_from_list (init, ELK_INIT, complain);
+      if (!type)
+	type = do_auto_deduction (TREE_TYPE (field), init, auto_node, complain);
+      TREE_TYPE (field) = type;
+      cp_apply_type_quals_to_decl (cp_type_quals (type), field);
+    }
+  list = tree_cons (field, init, list);
+}
+
 /* T is a LAMBDA_EXPR.  Generate a new LAMBDA_EXPR for the current
    instantiation context.  Instantiating a pack expansion containing a lambda
    might result in multiple lambdas all based on the same lambda in the
@@ -18025,17 +18036,8 @@
   tree oldfn = lambda_function (t);
   in_decl = oldfn;
 
-  /* If we have already specialized this lambda expr, reuse it.  See
-     PR c++/87322.  */
-  if (local_specializations)
-    if (tree r = retrieve_local_specialization (t))
-      return r;
-
   tree r = build_lambda_expr ();
 
-  if (local_specializations)
-    register_local_specialization (r, t);
-
   LAMBDA_EXPR_LOCATION (r)
     = LAMBDA_EXPR_LOCATION (t);
   LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (r)
@@ -18088,15 +18090,15 @@
 	  gcc_assert (TREE_CODE (init) == TREE_VEC
 		      && TREE_VEC_LENGTH (init) == len);
 	  for (int i = 0; i < len; ++i)
-	    LAMBDA_EXPR_CAPTURE_LIST (r)
-	      = tree_cons (TREE_VEC_ELT (field, i),
-			   TREE_VEC_ELT (init, i),
-			   LAMBDA_EXPR_CAPTURE_LIST (r));
+	    prepend_one_capture (TREE_VEC_ELT (field, i),
+				 TREE_VEC_ELT (init, i),
+				 LAMBDA_EXPR_CAPTURE_LIST (r),
+				 complain);
 	}
       else
 	{
-	  LAMBDA_EXPR_CAPTURE_LIST (r)
-	    = tree_cons (field, init, LAMBDA_EXPR_CAPTURE_LIST (r));
+	  prepend_one_capture (field, init, LAMBDA_EXPR_CAPTURE_LIST (r),
+			       complain);
 
 	  if (id_equal (DECL_NAME (field), "__this"))
 	    LAMBDA_EXPR_THIS_CAPTURE (r) = field;
@@ -24321,12 +24323,11 @@
 	}
       else if (push_tinst_level (fn))
 	{
+	  push_to_top_level ();
 	  push_access_scope (fn);
 	  push_deferring_access_checks (dk_no_deferred);
 	  input_location = DECL_SOURCE_LOCATION (fn);
 
-	  tree save_ccp = current_class_ptr;
-	  tree save_ccr = current_class_ref;
 	  /* If needed, set current_class_ptr for the benefit of
 	     tsubst_copy/PARM_DECL.  */
 	  tree tdecl = DECL_TEMPLATE_RESULT (DECL_TI_TEMPLATE (fn));
@@ -24352,9 +24353,6 @@
 					/*function_p=*/false,
 					/*i_c_e_p=*/true);
 
-	  current_class_ptr = save_ccp;
-	  current_class_ref = save_ccr;
-
 	  /* Build up the noexcept-specification.  */
 	  spec = build_noexcept_spec (noex, tf_warning_or_error);
 
@@ -24364,6 +24362,7 @@
 	  pop_deferring_access_checks ();
 	  pop_access_scope (fn);
 	  pop_tinst_level ();
+	  pop_from_top_level ();
 	}
       else
 	spec = noexcept_false_spec;
@@ -27615,6 +27614,9 @@
     }
   else
     {
+      if (error_operand_p (init))
+	return error_mark_node;
+
       tree parms = build_tree_list (NULL_TREE, type);
       tree tparms;
 
Index: gcc/cp/parser.c
===================================================================
--- a/src/gcc/cp/parser.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/cp/parser.c	(.../branches/gcc-9-branch)
@@ -27596,7 +27596,9 @@
 	  /* A parameter declaration begins with a decl-specifier,
 	     which is either the "attribute" keyword, a storage class
 	     specifier, or (usually) a type-specifier.  */
-	  && !cp_lexer_next_token_is_decl_specifier_keyword (parser->lexer))
+	  && !cp_lexer_next_token_is_decl_specifier_keyword (parser->lexer)
+	  /* A parameter declaration can also begin with [[attribute]].  */
+	  && !cp_next_tokens_can_be_std_attribute_p (parser))
 	{
 	  tree type;
 	  tree pushed_scope = NULL_TREE;
@@ -27911,7 +27913,10 @@
 	    {
 	      tree parm_list = TREE_VEC_ELT (parameter_list, 0);
 	      tree parm = INNERMOST_TEMPLATE_PARMS (parm_list);
-	      if (CLASS_TYPE_P (TREE_TYPE (parm)))
+	      if (TREE_CODE (parm) != PARM_DECL)
+		ok = false;
+	      else if (MAYBE_CLASS_TYPE_P (TREE_TYPE (parm))
+		       && !TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm)))
 		/* OK, C++20 string literal operator template.  We don't need
 		   to warn in lower dialects here because we will have already
 		   warned about the template parameter.  */;
@@ -27925,7 +27930,7 @@
 	      tree type = INNERMOST_TEMPLATE_PARMS (parm_type);
 	      tree parm_list = TREE_VEC_ELT (parameter_list, 1);
 	      tree parm = INNERMOST_TEMPLATE_PARMS (parm_list);
-	      if (parm == error_mark_node
+	      if (TREE_CODE (parm) != PARM_DECL
 		  || TREE_TYPE (parm) != TREE_TYPE (type)
 		  || !TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm)))
 		ok = false;
Index: gcc/cp/call.c
===================================================================
--- a/src/gcc/cp/call.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/cp/call.c	(.../branches/gcc-9-branch)
@@ -530,9 +530,8 @@
 
   /* [conv.ptr]
 
-     A null pointer constant is an integral constant expression
-     (_expr.const_) rvalue of integer type that evaluates to zero or
-     an rvalue of type std::nullptr_t. */
+     A null pointer constant is an integer literal ([lex.icon]) with value
+     zero or a prvalue of type std::nullptr_t.  */
   if (NULLPTR_TYPE_P (type))
     return true;
 
@@ -5186,18 +5185,15 @@
   arg3_type = unlowered_expr_type (arg3);
   if (VOID_TYPE_P (arg2_type) || VOID_TYPE_P (arg3_type))
     {
-      /* 'void' won't help in resolving an overloaded expression on the
-	 other side, so require it to resolve by itself.  */
-      if (arg2_type == unknown_type_node)
-	{
-	  arg2 = resolve_nondeduced_context_or_error (arg2, complain);
-	  arg2_type = TREE_TYPE (arg2);
-	}
-      if (arg3_type == unknown_type_node)
-	{
-	  arg3 = resolve_nondeduced_context_or_error (arg3, complain);
-	  arg3_type = TREE_TYPE (arg3);
-	}
+      /* Do the conversions.  We don't these for `void' type arguments
+	 since it can't have any effect and since decay_conversion
+	 does not handle that case gracefully.  */
+      if (!VOID_TYPE_P (arg2_type))
+	arg2 = decay_conversion (arg2, complain);
+      if (!VOID_TYPE_P (arg3_type))
+	arg3 = decay_conversion (arg3, complain);
+      arg2_type = TREE_TYPE (arg2);
+      arg3_type = TREE_TYPE (arg3);
 
       /* [expr.cond]
 
@@ -5204,28 +5200,41 @@
 	 One of the following shall hold:
 
 	 --The second or the third operand (but not both) is a
-	   throw-expression (_except.throw_); the result is of the type
-	   and value category of the other.
+	   throw-expression (_except.throw_); the result is of the
+	   type of the other and is an rvalue.
 
 	 --Both the second and the third operands have type void; the
-	   result is of type void and is a prvalue.  */
+	   result is of type void and is an rvalue.
+
+	 We must avoid calling force_rvalue for expressions of type
+	 "void" because it will complain that their value is being
+	 used.  */
       if (TREE_CODE (arg2) == THROW_EXPR
 	  && TREE_CODE (arg3) != THROW_EXPR)
 	{
+	  if (!VOID_TYPE_P (arg3_type))
+	    {
+	      arg3 = force_rvalue (arg3, complain);
+	      if (arg3 == error_mark_node)
+		return error_mark_node;
+	    }
+	  arg3_type = TREE_TYPE (arg3);
 	  result_type = arg3_type;
-	  is_glvalue = glvalue_p (arg3);
 	}
       else if (TREE_CODE (arg2) != THROW_EXPR
 	       && TREE_CODE (arg3) == THROW_EXPR)
 	{
+	  if (!VOID_TYPE_P (arg2_type))
+	    {
+	      arg2 = force_rvalue (arg2, complain);
+	      if (arg2 == error_mark_node)
+		return error_mark_node;
+	    }
+	  arg2_type = TREE_TYPE (arg2);
 	  result_type = arg2_type;
-	  is_glvalue = glvalue_p (arg2);
 	}
       else if (VOID_TYPE_P (arg2_type) && VOID_TYPE_P (arg3_type))
-	{
-	  result_type = void_type_node;
-	  is_glvalue = false;
-	}
+	result_type = void_type_node;
       else
 	{
           if (complain & tf_error)
@@ -5244,6 +5253,7 @@
 	  return error_mark_node;
 	}
 
+      is_glvalue = false;
       goto valid_operands;
     }
   /* [expr.cond]
@@ -5361,6 +5371,10 @@
       && same_type_p (arg2_type, arg3_type))
     {
       result_type = arg2_type;
+      if (processing_template_decl)
+	/* Let lvalue_kind know this was a glvalue.  */
+	result_type = cp_build_reference_type (result_type, xvalue_p (arg2));
+
       arg2 = mark_lvalue_use (arg2);
       arg3 = mark_lvalue_use (arg3);
       goto valid_operands;
@@ -5558,13 +5572,6 @@
     return error_mark_node;
 
  valid_operands:
-  if (processing_template_decl && is_glvalue)
-    {
-      /* Let lvalue_kind know this was a glvalue.  */
-      tree arg = (result_type == arg2_type ? arg2 : arg3);
-      result_type = cp_build_reference_type (result_type, xvalue_p (arg));
-    }
-
   result = build3_loc (loc, COND_EXPR, result_type, arg1, arg2, arg3);
 
   /* If the ARG2 and ARG3 are the same and don't have side-effects,
Index: gcc/cp/lambda.c
===================================================================
--- a/src/gcc/cp/lambda.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/cp/lambda.c	(.../branches/gcc-9-branch)
@@ -220,17 +220,8 @@
   tree type;
   bool is_this = is_this_parameter (tree_strip_nop_conversions (expr));
 
-  if (!is_this && type_dependent_expression_p (expr))
+  if (!is_this && explicit_init_p)
     {
-      type = cxx_make_type (DECLTYPE_TYPE);
-      DECLTYPE_TYPE_EXPR (type) = expr;
-      DECLTYPE_FOR_LAMBDA_CAPTURE (type) = true;
-      DECLTYPE_FOR_INIT_CAPTURE (type) = explicit_init_p;
-      DECLTYPE_FOR_REF_CAPTURE (type) = by_reference_p;
-      SET_TYPE_STRUCTURAL_EQUALITY (type);
-    }
-  else if (!is_this && explicit_init_p)
-    {
       tree auto_node = make_auto ();
       
       type = auto_node;
@@ -240,6 +231,14 @@
 	type = build_reference_type (type);
       type = do_auto_deduction (type, expr, auto_node);
     }
+  else if (!is_this && type_dependent_expression_p (expr))
+    {
+      type = cxx_make_type (DECLTYPE_TYPE);
+      DECLTYPE_TYPE_EXPR (type) = expr;
+      DECLTYPE_FOR_LAMBDA_CAPTURE (type) = true;
+      DECLTYPE_FOR_REF_CAPTURE (type) = by_reference_p;
+      SET_TYPE_STRUCTURAL_EQUALITY (type);
+    }
   else
     {
       type = non_reference (unlowered_expr_type (expr));
@@ -602,7 +601,16 @@
   name = get_identifier (buf);
 
   if (variadic)
-    type = make_pack_expansion (type);
+    {
+      type = make_pack_expansion (type);
+      if (explicit_init_p)
+	/* With an explicit initializer 'type' is auto, which isn't really a
+	   parameter pack in this context.  We will want as many fields as we
+	   have elements in the expansion of the initializer, so use its packs
+	   instead.  */
+	PACK_EXPANSION_PARAMETER_PACKS (type)
+	  = uses_parameter_packs (initializer);
+    }
 
   /* Make member variable.  */
   member = build_decl (input_location, FIELD_DECL, name, type);
Index: gcc/cp/cp-tree.h
===================================================================
--- a/src/gcc/cp/cp-tree.h	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/cp/cp-tree.h	(.../branches/gcc-9-branch)
@@ -423,7 +423,6 @@
       LAMBDA_EXPR_MUTABLE_P (in LAMBDA_EXPR)
       DECL_FINAL_P (in FUNCTION_DECL)
       QUALIFIED_NAME_IS_TEMPLATE (in SCOPE_REF)
-      DECLTYPE_FOR_INIT_CAPTURE (in DECLTYPE_TYPE)
       CONSTRUCTOR_IS_DEPENDENT (in CONSTRUCTOR)
       TINFO_USED_TEMPLATE_ID (in TEMPLATE_INFO)
       PACK_EXPANSION_SIZEOF_P (in *_PACK_EXPANSION)
@@ -4471,12 +4470,10 @@
   (DECLTYPE_TYPE_CHECK (NODE))->type_common.string_flag
 
 /* These flags indicate that we want different semantics from normal
-   decltype: lambda capture just drops references, init capture
-   uses auto semantics, lambda proxies look through implicit dereference.  */
+   decltype: lambda capture just drops references,
+   lambda proxies look through implicit dereference.  */
 #define DECLTYPE_FOR_LAMBDA_CAPTURE(NODE) \
   TREE_LANG_FLAG_0 (DECLTYPE_TYPE_CHECK (NODE))
-#define DECLTYPE_FOR_INIT_CAPTURE(NODE) \
-  TREE_LANG_FLAG_1 (DECLTYPE_TYPE_CHECK (NODE))
 #define DECLTYPE_FOR_LAMBDA_PROXY(NODE) \
   TREE_LANG_FLAG_2 (DECLTYPE_TYPE_CHECK (NODE))
 #define DECLTYPE_FOR_REF_CAPTURE(NODE) \
@@ -6779,7 +6776,7 @@
 extern tree instantiate_decl			(tree, bool, bool);
 extern int comp_template_parms			(const_tree, const_tree);
 extern bool builtin_pack_fn_p			(tree);
-extern bool uses_parameter_packs                (tree);
+extern tree uses_parameter_packs                (tree);
 extern bool template_parameter_pack_p           (const_tree);
 extern bool function_parameter_pack_p		(const_tree);
 extern bool function_parameter_expanded_from_pack_p (tree, tree);
Index: gcc/cp/name-lookup.c
===================================================================
--- a/src/gcc/cp/name-lookup.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/cp/name-lookup.c	(.../branches/gcc-9-branch)
@@ -5656,7 +5656,7 @@
     {"bitset", "<bitset>", cxx11},
     /* <complex>.  */
     {"complex", "<complex>", cxx98},
-    {"complex_literals", "<complex>", cxx98},
+    {"complex_literals", "<complex>", cxx14},
     /* <condition_variable>. */
     {"condition_variable", "<condition_variable>", cxx11},
     {"condition_variable_any", "<condition_variable>", cxx11},
@@ -5718,7 +5718,7 @@
     {"multimap", "<map>", cxx98},
     /* <memory>.  */
     {"make_shared", "<memory>", cxx11},
-    {"make_unique", "<memory>", cxx11},
+    {"make_unique", "<memory>", cxx14},
     {"shared_ptr", "<memory>", cxx11},
     {"unique_ptr", "<memory>", cxx11},
     {"weak_ptr", "<memory>", cxx11},
Index: gcc/tree-ssa-alias.c
===================================================================
--- a/src/gcc/tree-ssa-alias.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/tree-ssa-alias.c	(.../branches/gcc-9-branch)
@@ -2599,8 +2599,8 @@
 
 static bool
 maybe_skip_until (gimple *phi, tree &target, basic_block target_bb,
-		  ao_ref *ref, tree vuse, unsigned int &limit, bitmap *visited,
-		  bool abort_on_visited,
+		  ao_ref *ref, tree vuse, bool tbaa_p, unsigned int &limit,
+		  bitmap *visited, bool abort_on_visited,
 		  void *(*translate)(ao_ref *, tree, void *, bool *),
 		  void *data)
 {
@@ -2634,7 +2634,7 @@
 	  /* An already visited PHI node ends the walk successfully.  */
 	  if (bitmap_bit_p (*visited, SSA_NAME_VERSION (PHI_RESULT (def_stmt))))
 	    return !abort_on_visited;
-	  vuse = get_continuation_for_phi (def_stmt, ref, limit,
+	  vuse = get_continuation_for_phi (def_stmt, ref, tbaa_p, limit,
 					   visited, abort_on_visited,
 					   translate, data);
 	  if (!vuse)
@@ -2649,7 +2649,7 @@
 	  if ((int)limit <= 0)
 	    return false;
 	  --limit;
-	  if (stmt_may_clobber_ref_p_1 (def_stmt, ref))
+	  if (stmt_may_clobber_ref_p_1 (def_stmt, ref, tbaa_p))
 	    {
 	      bool disambiguate_only = true;
 	      if (translate
@@ -2681,7 +2681,7 @@
    Returns NULL_TREE if no suitable virtual operand can be found.  */
 
 tree
-get_continuation_for_phi (gimple *phi, ao_ref *ref,
+get_continuation_for_phi (gimple *phi, ao_ref *ref, bool tbaa_p,
 			  unsigned int &limit, bitmap *visited,
 			  bool abort_on_visited,
 			  void *(*translate)(ao_ref *, tree, void *, bool *),
@@ -2724,7 +2724,8 @@
       arg1 = PHI_ARG_DEF (phi, i);
       if (arg1 == arg0)
 	;
-      else if (! maybe_skip_until (phi, arg0, dom, ref, arg1, limit, visited,
+      else if (! maybe_skip_until (phi, arg0, dom, ref, arg1, tbaa_p,
+				   limit, visited,
 				   abort_on_visited,
 				   /* Do not translate when walking over
 				      backedges.  */
@@ -2768,7 +2769,7 @@
    TODO: Cache the vector of equivalent vuses per ref, vuse pair.  */
 
 void *
-walk_non_aliased_vuses (ao_ref *ref, tree vuse,
+walk_non_aliased_vuses (ao_ref *ref, tree vuse, bool tbaa_p,
 			void *(*walker)(ao_ref *, tree, void *),
 			void *(*translate)(ao_ref *, tree, void *, bool *),
 			tree (*valueize)(tree),
@@ -2809,7 +2810,7 @@
       if (gimple_nop_p (def_stmt))
 	break;
       else if (gimple_code (def_stmt) == GIMPLE_PHI)
-	vuse = get_continuation_for_phi (def_stmt, ref, limit,
+	vuse = get_continuation_for_phi (def_stmt, ref, tbaa_p, limit,
 					 &visited, translated, translate, data);
       else
 	{
@@ -2819,7 +2820,7 @@
 	      break;
 	    }
 	  --limit;
-	  if (stmt_may_clobber_ref_p_1 (def_stmt, ref))
+	  if (stmt_may_clobber_ref_p_1 (def_stmt, ref, tbaa_p))
 	    {
 	      if (!translate)
 		break;
Index: gcc/lto-wrapper.c
===================================================================
--- a/src/gcc/lto-wrapper.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/lto-wrapper.c	(.../branches/gcc-9-branch)
@@ -128,12 +128,11 @@
 #define DUMPBASE_SUFFIX ".ltrans18446744073709551615"
 
 /* Create decoded options from the COLLECT_GCC and COLLECT_GCC_OPTIONS
-   environment according to LANG_MASK.  */
+   environment.  */
 
 static void
 get_options_from_collect_gcc_options (const char *collect_gcc,
 				      const char *collect_gcc_options,
-				      unsigned int lang_mask,
 				      struct cl_decoded_option **decoded_options,
 				      unsigned int *decoded_options_count)
 {
@@ -175,8 +174,7 @@
   argc = obstack_object_size (&argv_obstack) / sizeof (void *) - 1;
   argv = XOBFINISH (&argv_obstack, const char **);
 
-  decode_cmdline_options_to_array (argc, (const char **)argv,
-				   lang_mask,
+  decode_cmdline_options_to_array (argc, (const char **)argv, CL_DRIVER,
 				   decoded_options, decoded_options_count);
   obstack_free (&argv_obstack, NULL);
 }
@@ -1008,8 +1006,7 @@
     {
       struct cl_decoded_option *f2decoded_options;
       unsigned int f2decoded_options_count;
-      get_options_from_collect_gcc_options (collect_gcc,
-					    fopts, CL_LANG_ALL,
+      get_options_from_collect_gcc_options (collect_gcc, fopts,
 					    &f2decoded_options,
 					    &f2decoded_options_count);
       if (!fdecoded_options)
@@ -1150,7 +1147,6 @@
     fatal_error (input_location,
 		 "environment variable COLLECT_GCC_OPTIONS must be set");
   get_options_from_collect_gcc_options (collect_gcc, collect_gcc_options,
-					CL_LANG_ALL,
 					&decoded_options,
 					&decoded_options_count);
 
Index: gcc/tree-ssa-alias.h
===================================================================
--- a/src/gcc/tree-ssa-alias.h	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/tree-ssa-alias.h	(.../branches/gcc-9-branch)
@@ -131,11 +131,11 @@
 extern bool call_may_clobber_ref_p_1 (gcall *, ao_ref *);
 extern bool stmt_kills_ref_p (gimple *, tree);
 extern bool stmt_kills_ref_p (gimple *, ao_ref *);
-extern tree get_continuation_for_phi (gimple *, ao_ref *,
+extern tree get_continuation_for_phi (gimple *, ao_ref *, bool,
 				      unsigned int &, bitmap *, bool,
 				      void *(*)(ao_ref *, tree, void *, bool *),
 				      void *);
-extern void *walk_non_aliased_vuses (ao_ref *, tree,
+extern void *walk_non_aliased_vuses (ao_ref *, tree, bool,
 				     void *(*)(ao_ref *, tree, void *),
 				     void *(*)(ao_ref *, tree, void *, bool *),
 				     tree (*)(tree), unsigned &, void *);
Index: gcc/dse.c
===================================================================
--- a/src/gcc/dse.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/dse.c	(.../branches/gcc-9-branch)
@@ -2535,10 +2535,13 @@
 		clear_rhs_from_active_local_stores ();
 	    }
 	}
-      else if (SIBLING_CALL_P (insn) && reload_completed)
+      else if (SIBLING_CALL_P (insn)
+	       && (reload_completed || HARD_FRAME_POINTER_IS_ARG_POINTER))
 	/* Arguments for a sibling call that are pushed to memory are passed
 	   using the incoming argument pointer of the current function.  After
-	   reload that might be (and likely is) frame pointer based.  */
+	   reload that might be (and likely is) frame pointer based.  And, if
+	   it is a frame pointer on the target, even before reload we need to
+	   kill frame pointer based stores.  */
 	add_wild_read (bb_info);
       else
 	/* Every other call, including pure functions, may read any memory
Index: gcc/lra-remat.c
===================================================================
--- a/src/gcc/lra-remat.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/lra-remat.c	(.../branches/gcc-9-branch)
@@ -1020,7 +1020,6 @@
 static void
 update_scratch_ops (rtx_insn *remat_insn)
 {
-  int hard_regno;
   lra_insn_recog_data_t id = lra_get_insn_recog_data (remat_insn);
   struct lra_static_insn_data *static_id = id->insn_static_data;
   for (int i = 0; i < static_id->n_operands; i++)
@@ -1031,17 +1030,9 @@
       int regno = REGNO (*loc);
       if (! lra_former_scratch_p (regno))
 	continue;
-      hard_regno = reg_renumber[regno];
       *loc = lra_create_new_reg (GET_MODE (*loc), *loc,
 				 lra_get_allocno_class (regno),
 				 "scratch pseudo copy");
-      if (hard_regno >= 0)
-	{
-	  reg_renumber[REGNO (*loc)] = hard_regno;
-	  if (lra_dump_file)
-	    fprintf (lra_dump_file, "	 Assigning the same %d to r%d\n",
-		     REGNO (*loc), hard_regno);
-	}
       lra_register_new_scratch_op (remat_insn, i, id->icode);
     }
   
Index: gcc/fortran/intrinsic.c
===================================================================
--- a/src/gcc/fortran/intrinsic.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/intrinsic.c	(.../branches/gcc-9-branch)
@@ -4180,6 +4180,40 @@
   if (f == NULL && a == NULL)	/* No arguments */
     return true;
 
+  /* ALLOCATED has two mutually exclusive keywords, but only one
+     can be present at time and neither is optional. */
+  if (strcmp (name, "allocated") == 0 && a->name)
+    {
+      if (strcmp (a->name, "scalar") == 0)
+	{
+          if (a->next)
+	    goto whoops;
+	  if (a->expr->rank != 0)
+	    {
+	      gfc_error ("Scalar entity required at %L", &a->expr->where);
+	      return false;
+	    }
+          return true;
+	}
+      else if (strcmp (a->name, "array") == 0)
+	{
+          if (a->next)
+	    goto whoops;
+	  if (a->expr->rank == 0)
+	    {
+	      gfc_error ("Array entity required at %L", &a->expr->where);
+	      return false;
+	    }
+          return true;
+	}
+      else
+	{
+	  gfc_error ("Invalid keyword %qs in %qs intrinsic function at %L",
+		     a->name, name, &a->expr->where);
+	  return false;
+	}
+    }
+
   for (;;)
     {		/* Put the nonkeyword arguments in a 1:1 correspondence */
       if (f == NULL)
@@ -4199,6 +4233,7 @@
   if (a == NULL)
     goto do_sort;
 
+whoops:
   gfc_error ("Too many arguments in call to %qs at %L", name, where);
   return false;
 
Index: gcc/fortran/trans-expr.c
===================================================================
--- a/src/gcc/fortran/trans-expr.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/trans-expr.c	(.../branches/gcc-9-branch)
@@ -10603,7 +10603,8 @@
       if (expr1->ts.deferred
 	  && gfc_expr_attr (expr1).allocatable
 	  && gfc_check_dependency (expr1, expr2, true))
-	rse.string_length = gfc_evaluate_now (rse.string_length, &rse.pre);
+	rse.string_length =
+	  gfc_evaluate_now_function_scope (rse.string_length, &rse.pre);
       string_length = rse.string_length;
     }
   else
Index: gcc/fortran/decl.c
===================================================================
--- a/src/gcc/fortran/decl.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/decl.c	(.../branches/gcc-9-branch)
@@ -1335,9 +1335,9 @@
 	}
 
       /* Trap declarations of attributes in encompassing scope.  The
-	 signature for this is that ts.kind is set.  Legitimate
-	 references only set ts.type.  */
-      if (sym->ts.kind != 0
+	 signature for this is that ts.kind is nonzero for no-CLASS
+	 entity.  For a CLASS entity, ts.kind is zero.  */
+      if ((sym->ts.kind != 0 || sym->ts.type == BT_CLASS)
 	  && !sym->attr.implicit_type
 	  && sym->attr.proc == 0
 	  && gfc_current_ns->parent != NULL
Index: gcc/fortran/ChangeLog
===================================================================
--- a/src/gcc/fortran/ChangeLog	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/ChangeLog	(.../branches/gcc-9-branch)
@@ -1,3 +1,95 @@
+2019-08-18  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91485
+	module.c (gfc_match_use): User defined operator cannot conflict with
+	a rename symbol.
+
+2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91471
+	* primary.c (gfc_variable_attr): Remove a gfc_internal_error(),
+	which cannot be reached by conforming Fortran code, but seems to
+	be reachable from nonconforming Fortran code.  Treat the AR_UNKNOWN
+	case as a no-op.
+
+2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78739
+	* match.c (gfc_match_st_function):  When matching a statement function,
+	need to check if the statement function name shadows the function
+	name.
+
+2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78719
+	* decl.c (get_proc_name): Check for a CLASS entity when trying to
+	add attributes to an entity that already has an explicit interface.
+
+2019-08-17  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/82992
+	* module.c (gfc_match_use):  When renaming a module entity, search
+	current namespace for conflicting symbol.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/87991
+	* resolve.c (check_data_variable): data-stmt-object with pointer
+	attribute requires a data-stmt-value with the target attribute.
+
+2013-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90563
+	* frontend-passes.c (insert_index): Suppress errors while
+	simplifying the resulting expression.
+ 
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88072
+	* misc.c (gfc_typename): Do not point to something that ought not to
+	be pointed at.
+
+2019-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90561
+	* trans.h (gfc_evaluate_now_function_scope): New function.
+	* trans.c (gfc_evaluate_now_function_scope): New function.
+	* trans-expr.c (gfc_trans_assignment): Use it.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/89647
+	resolve.c (resolve_typebound_procedure): Allow host associated
+	procedure to be a binding target.  While here, wrap long line.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/87993
+	* expr.c (gfc_simplify_expr): Simplifcation of an array with a kind
+	type inquiry suffix yields a constant expression.
+
+2019-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91424
+	* frontend-passes.c (do_subscript): Do not warn for an
+	expression a second time.  Do not warn about a zero-trip loop.
+	(doloop_warn): Also look at contained namespaces.
+
+2019-08-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91359
+	* trans-decl.c (gfc_generate_return): Ensure something is returned
+	from a function.
+
+2019-08-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/42546
+	* check.c(gfc_check_allocated): Add comment pointing to ...
+ 	* intrinsic.c(sort_actual): ... the checking done here.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
Index: gcc/fortran/expr.c
===================================================================
--- a/src/gcc/fortran/expr.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/expr.c	(.../branches/gcc-9-branch)
@@ -2220,6 +2220,11 @@
       if (!simplify_ref_chain (p->ref, type, &p))
 	return false;
 
+      /* If the following conditions hold, we found something like kind type
+	 inquiry of the form a(2)%kind while simplify the ref chain.  */
+      if (p->expr_type == EXPR_CONSTANT && !p->ref && !p->rank && !p->shape)
+	return true;
+
       if (!simplify_constructor (p->value.constructor, type))
 	return false;
 
Index: gcc/fortran/module.c
===================================================================
--- a/src/gcc/fortran/module.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/module.c	(.../branches/gcc-9-branch)
@@ -525,6 +525,8 @@
   gfc_intrinsic_op op;
   match m;
   gfc_use_list *use_list;
+  gfc_symtree *st;
+  locus loc;
 
   use_list = gfc_get_use_list ();
 
@@ -632,6 +634,8 @@
 	case INTERFACE_USER_OP:
 	case INTERFACE_GENERIC:
 	case INTERFACE_DTIO:
+	  loc = gfc_current_locus;
+
 	  m = gfc_match (" =>");
 
 	  if (type == INTERFACE_USER_OP && m == MATCH_YES
@@ -642,6 +646,18 @@
 	  if (type == INTERFACE_USER_OP)
 	    new_use->op = INTRINSIC_USER;
 
+	  st = gfc_find_symtree (gfc_current_ns->sym_root, name);
+	  if (st && type != INTERFACE_USER_OP)
+	    {
+	      if (m == MATCH_YES)
+		gfc_error ("Symbol %qs at %L conflicts with the rename symbol "
+			   "at %L", name, &st->n.sym->declared_at, &loc);
+	      else
+		gfc_error ("Symbol %qs at %L conflicts with the symbol "
+			   "at %L", name, &st->n.sym->declared_at, &loc);
+	      goto cleanup;
+	    }
+
 	  if (use_list->only_flag)
 	    {
 	      if (m != MATCH_YES)
Index: gcc/fortran/trans.c
===================================================================
--- a/src/gcc/fortran/trans.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/trans.c	(.../branches/gcc-9-branch)
@@ -118,7 +118,20 @@
   return gfc_evaluate_now_loc (input_location, expr, pblock);
 }
 
+/* Like gfc_evaluate_now, but add the created variable to the
+   function scope.  */
 
+tree
+gfc_evaluate_now_function_scope (tree expr, stmtblock_t * pblock)
+{
+  tree var;
+  var = gfc_create_var_np (TREE_TYPE (expr), NULL);
+  gfc_add_decl_to_function (var);
+  gfc_add_modify (pblock, var, expr);
+
+  return var;
+}
+
 /* Build a MODIFY_EXPR node and add it to a given statement block PBLOCK.
    A MODIFY_EXPR is an assignment:
    LHS <- RHS.  */
Index: gcc/fortran/trans.h
===================================================================
--- a/src/gcc/fortran/trans.h	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/trans.h	(.../branches/gcc-9-branch)
@@ -507,6 +507,7 @@
 /* If the value is not constant, Create a temporary and copy the value.  */
 tree gfc_evaluate_now_loc (location_t, tree, stmtblock_t *);
 tree gfc_evaluate_now (tree, stmtblock_t *);
+tree gfc_evaluate_now_function_scope (tree, stmtblock_t *);
 
 /* Find the appropriate variant of a math intrinsic.  */
 tree gfc_builtin_decl_for_float_kind (enum built_in_function, int);
Index: gcc/fortran/frontend-passes.c
===================================================================
--- a/src/gcc/fortran/frontend-passes.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/frontend-passes.c	(.../branches/gcc-9-branch)
@@ -2519,7 +2519,12 @@
   data.sym = sym;
   mpz_init_set (data.val, val);
   gfc_expr_walker (&n, callback_insert_index, (void *) &data);
+
+  /* Suppress errors here - we could get errors here such as an
+     out of bounds access for arrays, see PR 90563.  */
+  gfc_push_suppress_errors ();
   gfc_simplify_expr (n, 0);
+  gfc_pop_suppress_errors ();
 
   if (n->expr_type == EXPR_CONSTANT)
     {
@@ -2557,6 +2562,12 @@
   if (in_assoc_list)
     return 0;
 
+  /* We already warned about this.  */
+  if (v->do_not_warn)
+    return 0;
+
+  v->do_not_warn = 1;
+
   for (ref = v->ref; ref; ref = ref->next)
     {
       if (ref->type == REF_ARRAY && ref->u.ar.type == AR_ELEMENT)
@@ -2609,7 +2620,6 @@
 	      else
 		have_do_start = false;
 
-
 	      if (dl->ext.iterator->end->expr_type == EXPR_CONSTANT)
 		{
 		  have_do_end = true;
@@ -2621,6 +2631,17 @@
 	      if (!have_do_start && !have_do_end)
 		return 0;
 
+	      /* No warning inside a zero-trip loop.  */
+	      if (have_do_start && have_do_end)
+		{
+		  int sgn, cmp;
+
+		  sgn = mpz_cmp_ui (do_step, 0);
+		  cmp = mpz_cmp (do_end, do_start);
+		  if ((sgn > 0 && cmp < 0) || (sgn < 0 && cmp > 0))
+		    break;
+		}
+
 	      /* May have to correct the end value if the step does not equal
 		 one.  */
 	      if (have_do_start && have_do_end && mpz_cmp_ui (do_step, 1) != 0)
@@ -2762,6 +2783,12 @@
 doloop_warn (gfc_namespace *ns)
 {
   gfc_code_walker (&ns->code, doloop_code, do_function, NULL);
+
+  for (ns = ns->contained; ns; ns = ns->sibling)
+    {
+      if (ns->code == NULL || ns->code->op != EXEC_BLOCK)
+	doloop_warn (ns);
+    }
 }
 
 /* This selction deals with inlining calls to MATMUL.  */
Index: gcc/fortran/resolve.c
===================================================================
--- a/src/gcc/fortran/resolve.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/resolve.c	(.../branches/gcc-9-branch)
@@ -13539,6 +13539,25 @@
     }
   else
     {
+      /* If proc has not been resolved at this point, proc->name may 
+	 actually be a USE associated entity. See PR fortran/89647. */
+      if (!proc->resolved
+	  && proc->attr.function == 0 && proc->attr.subroutine == 0)
+	{
+	  gfc_symbol *tmp;
+	  gfc_find_symbol (proc->name, gfc_current_ns->parent, 1, &tmp);
+	  if (tmp && tmp->attr.use_assoc)
+	    {
+	      proc->module = tmp->module;
+	      proc->attr.proc = tmp->attr.proc;
+	      proc->attr.function = tmp->attr.function;
+	      proc->attr.subroutine = tmp->attr.subroutine;
+	      proc->attr.use_assoc = tmp->attr.use_assoc;
+	      proc->ts = tmp->ts;
+	      proc->result = tmp->result;
+	    }
+	}
+
       /* Check for F08:C465.  */
       if ((!proc->attr.subroutine && !proc->attr.function)
 	  || (proc->attr.proc != PROC_MODULE
@@ -13545,8 +13564,9 @@
 	      && proc->attr.if_source != IFSRC_IFBODY)
 	  || proc->attr.abstract)
 	{
-	  gfc_error ("%qs must be a module procedure or an external procedure with"
-		    " an explicit interface at %L", proc->name, &where);
+	  gfc_error ("%qs must be a module procedure or an external "
+		     "procedure with an explicit interface at %L",
+		     proc->name, &where);
 	  goto error;
 	}
     }
@@ -15662,8 +15682,6 @@
       return false;
     }
 
-  has_pointer = sym->attr.pointer;
-
   if (gfc_is_coindexed (e))
     {
       gfc_error ("DATA element %qs at %L cannot have a coindex", sym->name,
@@ -15671,19 +15689,30 @@
       return false;
     }
 
+  has_pointer = sym->attr.pointer;
+
   for (ref = e->ref; ref; ref = ref->next)
     {
       if (ref->type == REF_COMPONENT && ref->u.c.component->attr.pointer)
 	has_pointer = 1;
 
-      if (has_pointer
-	    && ref->type == REF_ARRAY
-	    && ref->u.ar.type != AR_FULL)
-	  {
-	    gfc_error ("DATA element %qs at %L is a pointer and so must "
-			"be a full array", sym->name, where);
-	    return false;
-	  }
+      if (has_pointer)
+	{
+	  if (ref->type == REF_ARRAY && ref->u.ar.type != AR_FULL)
+	    {
+	      gfc_error ("DATA element %qs at %L is a pointer and so must "
+			 "be a full array", sym->name, where);
+	      return false;
+	    }
+
+	  if (values.vnode->expr->expr_type == EXPR_CONSTANT)
+	    {
+	      gfc_error ("DATA object near %L has the pointer attribute "
+			 "and the corresponding DATA value is not a valid "
+			 "initial-data-target", where);
+	      return false;
+	    }
+	}
     }
 
   if (e->rank == 0 || has_pointer)
Index: gcc/fortran/match.c
===================================================================
--- a/src/gcc/fortran/match.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/match.c	(.../branches/gcc-9-branch)
@@ -5698,7 +5698,29 @@
   gfc_symbol *sym;
   gfc_expr *expr;
   match m;
+  char name[GFC_MAX_SYMBOL_LEN + 1];
+  locus old_locus;
+  bool fcn;
+  gfc_formal_arglist *ptr;
 
+  /* Read the possible statement function name, and then check to see if
+     a symbol is already present in the namespace.  Record if it is a
+     function and whether it has been referenced.  */
+  fcn = false;
+  ptr = NULL;
+  old_locus = gfc_current_locus;
+  m = gfc_match_name (name);
+  if (m == MATCH_YES)
+    {
+      gfc_find_symbol (name, NULL, 1, &sym);
+      if (sym && sym->attr.function && !sym->attr.referenced)
+	{
+	  fcn = true;
+	  ptr = sym->formal;
+	}
+    }
+
+  gfc_current_locus = old_locus;
   m = gfc_match_symbol (&sym, 0);
   if (m != MATCH_YES)
     return m;
@@ -5726,6 +5748,13 @@
       return MATCH_ERROR;
     }
 
+  if (fcn && ptr != sym->formal)
+    {
+      gfc_error ("Statement function %qs at %L conflicts with function name",
+		 sym->name, &expr->where);
+      return MATCH_ERROR;
+    }
+
   sym->value = expr;
 
   if ((gfc_current_state () == COMP_FUNCTION
Index: gcc/fortran/trans-decl.c
===================================================================
--- a/src/gcc/fortran/trans-decl.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/trans-decl.c	(.../branches/gcc-9-branch)
@@ -6440,6 +6440,20 @@
 				    TREE_TYPE (result), DECL_RESULT (fndecl),
 				    result);
 	}
+      else
+	{
+	  /* If the function does not have a result variable, result is
+	     NULL_TREE, and a 'return' is generated without a variable.
+	     The following generates a 'return __result_XXX' where XXX is
+	     the function name.  */
+	  if (sym == sym->result && sym->attr.function)
+	    {
+	      result = gfc_get_fake_result_decl (sym, 0);
+	      result = fold_build2_loc (input_location, MODIFY_EXPR,
+					TREE_TYPE (result),
+					DECL_RESULT (fndecl), result);
+	    }
+	}
     }
 
   return build1_v (RETURN_EXPR, result);
Index: gcc/fortran/check.c
===================================================================
--- a/src/gcc/fortran/check.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/check.c	(.../branches/gcc-9-branch)
@@ -924,6 +924,10 @@
 }
 
 
+/* Limited checking for ALLOCATED intrinsic.  Additional checking
+   is performed in intrinsic.c(sort_actual), because ALLOCATED
+   has two mutually exclusive non-optional arguments.  */
+
 bool
 gfc_check_allocated (gfc_expr *array)
 {
Index: gcc/fortran/primary.c
===================================================================
--- a/src/gcc/fortran/primary.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/primary.c	(.../branches/gcc-9-branch)
@@ -2559,12 +2559,10 @@
 	    break;
 
 	  case AR_UNKNOWN:
-	    /* If any of start, end or stride is not integer, there will
-	       already have been an error issued.  */
-	    int errors;
-	    gfc_get_errors (NULL, &errors);
-	    if (errors == 0)
-	      gfc_internal_error ("gfc_variable_attr(): Bad array reference");
+	    /* For standard conforming code, AR_UNKNOWN should not happen.
+	       For nonconforming code, gfortran can end up here.  Treat it 
+	       as a no-op.  */
+	    break;
 	  }
 
 	break;
Index: gcc/fortran/misc.c
===================================================================
--- a/src/gcc/fortran/misc.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/misc.c	(.../branches/gcc-9-branch)
@@ -125,6 +125,7 @@
   static char buffer2[GFC_MAX_SYMBOL_LEN + 7];
   static int flag = 0;
   char *buffer;
+  gfc_typespec *ts1;
 
   buffer = flag ? buffer1 : buffer2;
   flag = !flag;
@@ -156,9 +157,8 @@
       sprintf (buffer, "TYPE(%s)", ts->u.derived->name);
       break;
     case BT_CLASS:
-      if (ts->u.derived->components)
-	ts = &ts->u.derived->components->ts;
-      if (ts->u.derived->attr.unlimited_polymorphic)
+      ts1 = ts->u.derived->components ? &ts->u.derived->components->ts : NULL;
+      if (ts1 && ts1->u.derived && ts1->u.derived->attr.unlimited_polymorphic)
 	sprintf (buffer, "CLASS(*)");
       else
 	sprintf (buffer, "CLASS(%s)", ts->u.derived->name);
Index: gcc/BASE-VER
===================================================================
--- a/src/gcc/BASE-VER	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/BASE-VER	(.../branches/gcc-9-branch)
@@ -1 +1 @@
-9.2.0
+9.2.1
Index: gcc/tree-ssa-pre.c
===================================================================
--- a/src/gcc/tree-ssa-pre.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/tree-ssa-pre.c	(.../branches/gcc-9-branch)
@@ -1184,8 +1184,8 @@
 	  bitmap visited = NULL;
 	  /* Try to find a vuse that dominates this phi node by skipping
 	     non-clobbering statements.  */
-	  vuse = get_continuation_for_phi (phi, &ref, cnt, &visited, false,
-					   NULL, NULL);
+	  vuse = get_continuation_for_phi (phi, &ref, true,
+					   cnt, &visited, false, NULL, NULL);
 	  if (visited)
 	    BITMAP_FREE (visited);
 	}
Index: gcc/omp-simd-clone.c
===================================================================
--- a/src/gcc/omp-simd-clone.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/omp-simd-clone.c	(.../branches/gcc-9-branch)
@@ -498,7 +498,6 @@
   /* Adjust the function return type.  */
   if (orig_rettype == void_type_node)
     return NULL_TREE;
-  TREE_TYPE (fndecl) = build_distinct_type_copy (TREE_TYPE (fndecl));
   t = TREE_TYPE (TREE_TYPE (fndecl));
   if (INTEGRAL_TYPE_P (t) || POINTER_TYPE_P (t))
     veclen = node->simdclone->vecsize_int;
@@ -724,11 +723,7 @@
 	  else
 	    new_reversed = void_list_node;
 	}
-
-      tree new_type = build_distinct_type_copy (TREE_TYPE (node->decl));
-      TYPE_ARG_TYPES (new_type) = new_reversed;
-      TREE_TYPE (node->decl) = new_type;
-
+      TYPE_ARG_TYPES (TREE_TYPE (node->decl)) = new_reversed;
       adjustments.release ();
     }
   args.release ();
@@ -1164,6 +1159,7 @@
 {
   push_cfun (DECL_STRUCT_FUNCTION (node->decl));
 
+  TREE_TYPE (node->decl) = build_distinct_type_copy (TREE_TYPE (node->decl));
   targetm.simd_clone.adjust (node);
 
   tree retval = simd_clone_adjust_return_type (node);
@@ -1737,6 +1733,8 @@
 	    simd_clone_adjust (n);
 	  else
 	    {
+	      TREE_TYPE (n->decl)
+		= build_distinct_type_copy (TREE_TYPE (n->decl));
 	      targetm.simd_clone.adjust (n);
 	      simd_clone_adjust_return_type (n);
 	      simd_clone_adjust_argument_types (n);
Index: gcc/tree-ssa-scopedtables.c
===================================================================
--- a/src/gcc/tree-ssa-scopedtables.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/tree-ssa-scopedtables.c	(.../branches/gcc-9-branch)
@@ -298,7 +298,7 @@
 	    && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME
 	    && (ao_ref_init (&ref, gimple_assign_rhs1 (stmt)),
 		ref.base_alias_set = ref.ref_alias_set = tbaa_p ? -1 : 0, true)
-	    && walk_non_aliased_vuses (&ref, vuse2, vuse_eq, NULL, NULL,
+	    && walk_non_aliased_vuses (&ref, vuse2, true, vuse_eq, NULL, NULL,
 				       limit, vuse1) != NULL))
 	{
 	  if (insert)
Index: gcc/config/aarch64/aarch64.c
===================================================================
--- a/src/gcc/config/aarch64/aarch64.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/config/aarch64/aarch64.c	(.../branches/gcc-9-branch)
@@ -18162,19 +18162,21 @@
   /* Sort the operands.  */
   qsort (temp_operands, 4, 2 * sizeof (rtx *), aarch64_ldrstr_offset_compare);
 
+  /* Copy the memory operands so that if we have to bail for some
+     reason the original addresses are unchanged.  */
   if (load)
     {
-      mem_1 = temp_operands[1];
-      mem_2 = temp_operands[3];
-      mem_3 = temp_operands[5];
-      mem_4 = temp_operands[7];
+      mem_1 = copy_rtx (temp_operands[1]);
+      mem_2 = copy_rtx (temp_operands[3]);
+      mem_3 = copy_rtx (temp_operands[5]);
+      mem_4 = copy_rtx (temp_operands[7]);
     }
   else
     {
-      mem_1 = temp_operands[0];
-      mem_2 = temp_operands[2];
-      mem_3 = temp_operands[4];
-      mem_4 = temp_operands[6];
+      mem_1 = copy_rtx (temp_operands[0]);
+      mem_2 = copy_rtx (temp_operands[2]);
+      mem_3 = copy_rtx (temp_operands[4]);
+      mem_4 = copy_rtx (temp_operands[6]);
       gcc_assert (code == UNKNOWN);
     }
 
Index: libgfortran/intrinsics/random.c
===================================================================
--- a/src/libgfortran/intrinsics/random.c	(.../tags/gcc_9_2_0_release)
+++ b/src/libgfortran/intrinsics/random.c	(.../branches/gcc-9-branch)
@@ -275,31 +275,20 @@
 }
 
 
-/* Super-simple LCG generator used in getosrandom () if /dev/urandom
-   doesn't exist.  */
+/* Splitmix64 recommended by xorshift author for initializing.  After
+   getting one uint64_t value from the OS, this is used to fill in the
+   rest of the state.  */
 
-#define M 2147483647 /* 2^31 - 1 (A large prime number) */
-#define A 16807      /* Prime root of M, passes statistical tests and produces a full cycle */
-#define Q 127773 /* M / A (To avoid overflow on A * seed) */
-#define R 2836   /* M % A (To avoid overflow on A * seed) */
-
-__attribute__((unused)) static uint32_t
-lcg_parkmiller(uint32_t seed)
+static uint64_t
+splitmix64 (uint64_t x)
 {
-    uint32_t hi = seed / Q;
-    uint32_t lo = seed % Q;
-    int32_t test = A * lo - R * hi;
-    if (test <= 0)
-        test += M;
-    return test;
+  uint64_t z = (x += 0x9e3779b97f4a7c15);
+  z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;
+  z = (z ^ (z >> 27)) * 0x94d049bb133111eb;
+  return z ^ (z >> 31);
 }
 
-#undef M
-#undef A
-#undef Q
-#undef R
 
-
 /* Get some random bytes from the operating system in order to seed
    the PRNG.  */
 
@@ -315,7 +304,7 @@
 #else
 #ifdef HAVE_GETENTROPY
   if (getentropy (buf, buflen) == 0)
-    return 0;
+    return buflen;
 #endif
   int flags = O_RDONLY;
 #ifdef O_CLOEXEC
@@ -328,7 +317,7 @@
       close (fd);
       return res;
     }
-  uint32_t seed = 1234567890;
+  uint64_t seed = 0x047f7684e9fc949dULL;
   time_t secs;
   long usecs;
   if (gf_gettime (&secs, &usecs) == 0)
@@ -340,13 +329,9 @@
   pid_t pid = getpid();
   seed ^= pid;
 #endif
-  uint32_t* ub = buf;
-  for (size_t i = 0; i < buflen / sizeof (uint32_t); i++)
-    {
-      ub[i] = seed;
-      seed = lcg_parkmiller (seed);
-    }
-  return buflen;
+  size_t size = buflen < sizeof (uint64_t) ? buflen : sizeof (uint64_t);
+  memcpy (buf, &seed, size);
+  return size;
 #endif /* __MINGW64_VERSION_MAJOR  */
 }
 
@@ -361,7 +346,13 @@
     __gthread_mutex_lock (&random_lock);
   if (!master_init)
     {
-      getosrandom (master_state, sizeof (master_state));
+      uint64_t os_seed;
+      getosrandom (&os_seed, sizeof (os_seed));
+      for (uint64_t i = 0; i < sizeof (master_state) / sizeof (uint64_t); i++)
+	{
+	  os_seed = splitmix64 (os_seed);
+	  master_state[i] = os_seed;
+	}
       njumps = 0;
       master_init = true;
     }
Index: libgfortran/ChangeLog
===================================================================
--- a/src/libgfortran/ChangeLog	(.../tags/gcc_9_2_0_release)
+++ b/src/libgfortran/ChangeLog	(.../branches/gcc-9-branch)
@@ -1,3 +1,13 @@
+2019-08-13  Janne Blomqvist  <jb@gcc.gnu.org>
+
+	Partial backport from trunk
+	PR fortran/91414
+	* intrinsics/random.c (lcg_parkmiller): Replace with splitmix64.
+	(splitmix64): New function.
+	(getosrandom): Fix return value, simplify.
+	(init_rand_state): Use getosrandom only to get 8 bytes, splitmix64
+	to fill rest of state.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
