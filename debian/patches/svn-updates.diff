# DP: updates from the 9 branch upto 20190815 (r274526).

last_update()
{
	cat > ${dir}LAST_UPDATED <EOF
Thu Aug 15 13:09:17 CEST 2019
Thu Aug 15 11:09:17 UTC 2019 (revision 274526)
EOF
}

LANG=C svn diff svn://gcc.gnu.org/svn/gcc/tags/gcc_9_2_0_release svn://gcc.gnu.org/svn/gcc/branches/gcc-9-branch \
	| sed -r 's,^--- (\S+)\t(\S+)(.*)$,--- a/src/\1\t\2,;s,^\+\+\+ (\S+)\t(\S+)(.*)$,+++ b/src/\1\t\2,' \
	| awk '/^Index:.*\.(class|texi)/ {skip=1; next} /^Index:/ { skip=0 } skip==0'

Index: libgomp/ChangeLog
===================================================================
--- a/src/libgomp/ChangeLog	(.../tags/gcc_9_2_0_release)
+++ b/src/libgomp/ChangeLog	(.../branches/gcc-9-branch)
@@ -1,3 +1,10 @@
+2019-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91422
+	* testsuite/libgomp.oacc-fortran/routine-7.f90: Correct array
+	dimension.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
Index: libgomp/testsuite/libgomp.oacc-fortran/routine-7.f90
===================================================================
--- a/src/libgomp/testsuite/libgomp.oacc-fortran/routine-7.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/libgomp/testsuite/libgomp.oacc-fortran/routine-7.f90	(.../branches/gcc-9-branch)
@@ -109,7 +109,7 @@
 
 subroutine seq (a)
   !$acc routine seq
-  integer, intent (inout) :: a(M)
+  integer, intent (inout) :: a(N)
   integer :: i
 
   do i = 1, N
Index: libstdc++-v3/src/c++17/string-inst.cc
===================================================================
--- a/src/libstdc++-v3/src/c++17/string-inst.cc	(.../tags/gcc_9_2_0_release)
+++ b/src/libstdc++-v3/src/c++17/string-inst.cc	(.../branches/gcc-9-branch)
@@ -26,6 +26,12 @@
 // ISO C++ 14882:2017 24  Strings library
 //
 
+#ifndef _GLIBCXX_USE_CXX11_ABI
+// Instantiations in this file use the new SSO std::string ABI unless included
+// by another file which defines _GLIBCXX_USE_CXX11_ABI=0.
+# define _GLIBCXX_USE_CXX11_ABI 1
+#endif
+
 #include <string>
 
 namespace std _GLIBCXX_VISIBILITY(default)
Index: libstdc++-v3/ChangeLog
===================================================================
--- a/src/libstdc++-v3/ChangeLog	(.../tags/gcc_9_2_0_release)
+++ b/src/libstdc++-v3/ChangeLog	(.../branches/gcc-9-branch)
@@ -1,3 +1,11 @@
+2019-08-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-08-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90361
+	* src/c++17/string-inst.cc: Use _GLIBCXX_USE_CXX11_ABI=1 by default.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
Index: gcc/DATESTAMP
===================================================================
--- a/src/gcc/DATESTAMP	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/DATESTAMP	(.../branches/gcc-9-branch)
@@ -1 +1 @@
-20190812
+20190815
Index: gcc/tree.c
===================================================================
--- a/src/gcc/tree.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/tree.c	(.../branches/gcc-9-branch)
@@ -5514,8 +5514,7 @@
 	  free_lang_data_in_binfo (TYPE_BINFO (type));
 	  /* We need to preserve link to bases and virtual table for all
 	     polymorphic types to make devirtualization machinery working.  */
-	  if (!BINFO_VTABLE (TYPE_BINFO (type))
-	      || !flag_devirtualize)
+	  if (!BINFO_VTABLE (TYPE_BINFO (type)))
 	    TYPE_BINFO (type) = NULL;
 	}
     }
@@ -11357,6 +11356,73 @@
     }
 }
 
+/* Given an initializer INIT for a TYPE, return true if INIT is zero
+   so that it can be replaced by value initialization.  This function
+   distinguishes betwen empty strings as initializers for arrays and
+   for pointers (which make it return false).  */
+
+bool
+type_initializer_zero_p (tree type, tree init)
+{
+  if (type  == error_mark_node || init == error_mark_node)
+    return false;
+
+  STRIP_NOPS (init);
+
+  if (POINTER_TYPE_P (type))
+    return TREE_CODE (init) != STRING_CST && initializer_zerop (init);
+
+  if (TREE_CODE (init) != CONSTRUCTOR)
+    return initializer_zerop (init);
+
+  if (TREE_CODE (type) == ARRAY_TYPE)
+    {
+      tree elt_type = TREE_TYPE (type);
+      elt_type = TYPE_MAIN_VARIANT (elt_type);
+      if (elt_type == char_type_node)
+	return initializer_zerop (init);
+
+      tree elt_init;
+      unsigned HOST_WIDE_INT i;
+      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), i, elt_init)
+	if (!type_initializer_zero_p (elt_type, elt_init))
+	  return false;
+      return true;
+    }
+
+  if (TREE_CODE (type) != RECORD_TYPE)
+    return initializer_zerop (init);
+
+  tree fld = TYPE_FIELDS (type);
+
+  tree fld_init;
+  unsigned HOST_WIDE_INT i;
+  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), i, fld_init)
+    {
+      /* Advance to the next member, skipping over everything that
+	 canot be initialized (including unnamed bit-fields).  */
+      while (TREE_CODE (fld) != FIELD_DECL
+	     || DECL_ARTIFICIAL (fld)
+	     || (DECL_BIT_FIELD (fld) && !DECL_NAME (fld)))
+	{
+	  fld = DECL_CHAIN (fld);
+	  if (!fld)
+	    return true;
+	  continue;
+	}
+
+      tree fldtype = TREE_TYPE (fld);
+      if (!type_initializer_zero_p (fldtype, fld_init))
+	return false;
+
+      fld = DECL_CHAIN (fld);
+      if (!fld)
+	break;
+    }
+
+  return true;
+}
+
 /* Check if vector VEC consists of all the equal elements and
    that the number of elements corresponds to the type of VEC.
    The function returns first element of the vector
Index: gcc/tree.h
===================================================================
--- a/src/gcc/tree.h	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/tree.h	(.../branches/gcc-9-branch)
@@ -4525,6 +4525,12 @@
 extern bool initializer_zerop (const_tree, bool * = NULL);
 extern bool initializer_each_zero_or_onep (const_tree);
 
+/* Analogous to initializer_zerop but also examines the type for
+   which the initializer is being used.  Unlike initializer_zerop,
+   considers empty strings to be zero initializers for arrays and
+   non-zero for pointers.  */
+extern bool type_initializer_zero_p (tree, tree);
+
 extern wide_int vector_cst_int_elt (const_tree, unsigned int);
 extern tree vector_cst_elt (const_tree, unsigned int);
 
Index: gcc/ChangeLog
===================================================================
--- a/src/gcc/ChangeLog	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/ChangeLog	(.../branches/gcc-9-branch)
@@ -1,3 +1,46 @@
+2019-08-14  Martin Sebor  <msebor@redhat.com>
+
+	Backport from mainline
+
+	2019-08-01  Martin Sebor  <msebor@redhat.com>
+
+	PR c++/90947
+	* tree.c (type_initializer_zero_p): Define.
+	* tree.h (type_initializer_zero_p): New function.
+
+	2019-08-05  Martin Sebor  <msebor@redhat.com>
+
+	* doc/extend.texi (Common Variable Attributes): Document alias
+	attribute.
+
+2019-08-12  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-08-12  Richard Biener  <rguenther@suse.de>
+
+	PR lto/91375
+	* tree.c (free_lang_data_in_type): Do not free TYPE_BINFO dependent on
+	flag_devirtualize.
+
+	2019-08-12  Richard Biener  <rguenther@suse.de>
+
+	PR driver/91130
+	* lto-wrapper.c (get_options_from_collect_gcc_options): Remove
+	lang_mask option, always use CL_DRIVER.
+	(find_and_merge_options): Adjust.
+	(run_gcc): Likewise.
+
+	2019-08-07  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR driver/91130
+	* lto-wrapper.c (find_and_merge_options): Use CL_DRIVER when
+	processing COLLECT_GCC_OPTIONS.
+	(run_gcc): Likewise.
+
+2019-08-12  Jakub Jelinek  <jakub@redhat.com>
+
+	* BASE-VER: Set to 9.2.1.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
Index: gcc/testsuite/gfortran.dg/do_subscript_3.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/do_subscript_3.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/do_subscript_3.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,22 @@
+! { dg-do compile }
+! PR fortran/91424
+! Check that only one warning is issued inside blocks, and that
+! warnings are also issued for contained subroutines.
+
+program main
+  real :: a(5)
+  block
+    integer :: j
+    do j=0, 5  ! { dg-warning "out of bounds" }
+       a(j) = 2. ! { dg-warning "out of bounds" }
+    end do
+  end block
+  call x
+contains
+  subroutine x
+    integer :: i
+    do i=1,6 ! { dg-warning "out of bounds" }
+       a(i) = 2.  ! { dg-warning "out of bounds" }
+    end do
+  end subroutine x
+end program main
Index: gcc/testsuite/gfortran.dg/pr91359_2.f
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr91359_2.f	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr91359_2.f	(.../branches/gcc-9-branch)
@@ -0,0 +1,17 @@
+! { dg-do run }
+! PR fortran/91359
+! Orginal code contributed by Brian T. Carcich <briantcarcich at gmail dot com>
+!
+      logical function zero() result(a)
+         goto 2
+1        return
+2        a = .false.
+         if (.not.a) goto 1
+         return
+      end
+
+      program test_zero
+         logical zero
+         if (zero()) stop 'FAIL:  zero() returned .TRUE.'
+         stop 'OKAY:  zero() returned .FALSE.'
+      end
Index: gcc/testsuite/gfortran.dg/unlimited_polymorphic_28.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/unlimited_polymorphic_28.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/unlimited_polymorphic_28.f90	(.../branches/gcc-9-branch)
@@ -21,7 +21,7 @@
 
   type,abstract,extends(c_base) :: c_derived
   contains
-    procedure :: f_base => f_derived ! { dg-error "Type mismatch in function result \\(CLASS\\(\\*\\)/CLASS\\(c_base\\)\\)" }
+    procedure :: f_base => f_derived ! { dg-error "Type mismatch in function result" }
   end type c_derived
 
 contains
Index: gcc/testsuite/gfortran.dg/deferred_character_34.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/deferred_character_34.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/deferred_character_34.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,10 @@
+! { dg-do run }
+! PR fortran/90561
+! This used to ICE.
+! Original test case by Gerhard Steinmetz.
+program p
+   character(:), allocatable :: z(:)
+   z = [character(2):: 'ab', 'xy']
+   z = z(2)
+   if (any(z /= 'xy')) stop 1
+end
Index: gcc/testsuite/gfortran.dg/pr70754.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr70754.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr70754.f90	(.../branches/gcc-9-branch)
@@ -18,12 +18,13 @@
     integer (ii4), dimension(40,40) :: c
     integer  i, j
 
-    do i=1,20
-      b(i,j) = 123 * a(i,j) + 34 * a(i,j+1) &
-             + 34 * a(i,j-1) + a(i+1,j+1) &
-             + a(i+1,j-1) + a(i-1,j+1) &
-             + a(i-1,j-1)
-      c(i,j) = 123
+    j = 10
+    do i=11,30
+       b(i,j) = 123 * a(i,j) + 34 * a(i,j+1) &
+            + 34 * a(i,j-1) + a(i+1,j+1) &
+            + a(i+1,j-1) + a(i-1,j+1) &
+            + a(i-1,j-1)
+       c(i,j) = 123
     end do
 
     where ((xyz(:,:,2) /= 0) .and. (c /= 0))
Index: gcc/testsuite/gfortran.dg/pr87993.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr87993.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr87993.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,8 @@
+! { dg-do run }
+! Code contributed by Gerhard Steinmetz <gscfq at t-online dot de>
+program p
+   integer, parameter :: a(2) = 1
+   integer, parameter :: b = a%kind
+   if (any(a /= 1)) stop 1
+   if (b /= kind(a)) stop 2
+end
Index: gcc/testsuite/gfortran.dg/pr88072.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr88072.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr88072.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,30 @@
+! { dg-do compile }
+! PR fortran/88072
+! Original code contributed by Andrew Wood <andrew at fluidgravity dot co.uk>
+module m1
+
+   implicit none
+
+   type, abstract, public :: t1
+      integer, dimension(:), allocatable :: i
+      contains
+         procedure(f1), deferred :: f
+   end type t1
+
+   type, extends(t1), public :: t2 ! { dg-error "must be ABSTRACT because" }
+      contains
+         procedure :: f => f2    ! { dg-error "mismatch for the overriding" }
+   end type t2
+
+   abstract interface
+      function f1(this)          ! { dg-error "must be dummy, allocatable or" }
+         import
+         class(t1) :: this
+         class(t1) :: f1
+      end function f1
+   end interface
+   contains
+      type(t2) function f2(this)
+         class(t2) :: this
+      end function f2
+end module m1
Index: gcc/testsuite/gfortran.dg/do_subscript_5.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/do_subscript_5.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/do_subscript_5.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,20 @@
+! { dg-do compile }
+! { dg-additional-options "-Wdo-subscript" }
+! PR 90563 - this used to be rejected, wrongly
+! Original test case by Tobias Neumann
+program test
+      implicit none
+      integer, parameter :: swap(4) = [2,1,3,4]
+      real :: p(20)
+      integer :: j
+
+      p = 0.0
+
+      ! The following warnings are actually bogus, but we are not yet
+      ! clever enough to suppress them.
+      do j=1,6 ! { dg-warning "out of bounds" }
+          if (j<5) then
+              p(j) = p(swap(j)) ! { dg-warning "out of bounds" }
+          endif
+      enddo
+end program
Index: gcc/testsuite/gfortran.dg/pr89647.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr89647.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr89647.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,33 @@
+! { dg-do compile }
+! Code contributed by Ian Harvey  <ian_harvey at bigpond dot com>
+  MODULE m1
+    IMPLICIT NONE
+    PUBLIC :: False
+    PUBLIC :: True
+  CONTAINS
+    FUNCTION False() RESULT(b)
+      LOGICAL :: b
+      b = .FALSE.
+    END FUNCTION False
+    
+    FUNCTION True() RESULT(b)
+      LOGICAL :: b
+      b = .TRUE.
+    END FUNCTION True
+  END MODULE m1
+
+  MODULE m2
+    USE m1
+    IMPLICIT NONE
+    TYPE, ABSTRACT :: t_parent
+    CONTAINS
+      PROCEDURE(False), DEFERRED, NOPASS :: Binding
+    END TYPE t_parent
+  CONTAINS
+    SUBROUTINE s
+      TYPE, EXTENDS(t_parent) :: t_extension
+      CONTAINS
+        PROCEDURE, NOPASS :: Binding => True
+      END TYPE t_extension
+    END SUBROUTINE s
+  END MODULE m2
Index: gcc/testsuite/gfortran.dg/allocated_2.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/allocated_2.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/allocated_2.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,16 @@
+! { dg-do compile }
+program foo
+
+   implicit none
+
+   integer, allocatable :: x
+   integer, allocatable :: a(:)
+
+   logical a1, a2
+
+   a1 = allocated(scalar=a)   ! { dg-error "Scalar entity required" }
+   a2 = allocated(array=x)    ! { dg-error "Array entity required" }
+   a1 = allocated(scalar=x, array=a)   ! { dg-error "Too many arguments" }
+   a1 = allocated(array=a, scalar=x)   ! { dg-error "Too many arguments" }
+
+end program foo
Index: gcc/testsuite/gfortran.dg/pr87991.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr87991.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr87991.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! { dg-options "-w" }
+! PR fortran/87991
+program p
+   type t
+      character(:), pointer :: c
+   end type
+   type(t) :: x
+   allocate (character(3) :: x%c)
+   data x%c /'abc'/   ! { dg-error "has the pointer attribute" }
+end
Index: gcc/testsuite/gfortran.dg/do_subscript_4.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/do_subscript_4.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/do_subscript_4.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! PR 91424 - this used to warn although the DO loop is zero trip.
+program main
+  implicit none
+  integer :: i
+  real :: a(2)
+  do i=1,3,-1
+     a(i) = 2.
+  end do
+  print *,a
+end program main
Index: gcc/testsuite/gfortran.dg/pr91359_1.f
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/pr91359_1.f	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/pr91359_1.f	(.../branches/gcc-9-branch)
@@ -0,0 +1,17 @@
+! { dg-do run }
+! PR fortran/91359
+! Orginal code contributed by Brian T. Carcich <briantcarcich at gmail dot com>
+!
+      logical function zero()
+         goto 2
+1        return
+2        zero = .false.
+         if (.not.zero) goto 1
+         return
+      end
+
+      program test_zero
+         logical zero
+         if (zero()) stop 'FAIL:  zero() returned .TRUE.'
+         stop 'OKAY:  zero() returned .FALSE.'
+      end
Index: gcc/testsuite/gfortran.dg/allocated_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/allocated_1.f90	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/gfortran.dg/allocated_1.f90	(.../branches/gcc-9-branch)
@@ -0,0 +1,24 @@
+! { dg-do run }
+program foo
+
+   implicit none
+
+   integer, allocatable :: x
+   integer, allocatable :: a(:)
+
+   logical a1, a2
+
+   a1 = allocated(scalar=x)
+   if (a1 .neqv. .false.) stop 1
+   a2 = allocated(array=a)
+   if (a2 .neqv. .false.) stop 2
+
+   allocate(x)
+   allocate(a(2))
+
+   a1 = allocated(scalar=x)
+   if (a1 .neqv. .true.) stop 3
+   a2 = allocated(array=a)
+   if (a2 .neqv. .true.) stop 4
+
+end program foo
Index: gcc/testsuite/ChangeLog
===================================================================
--- a/src/gcc/testsuite/ChangeLog	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/ChangeLog	(.../branches/gcc-9-branch)
@@ -1,3 +1,86 @@
+2019-08-14  Martin Sebor  <msebor@redhat.com>
+
+	Backport from mainline
+
+	2019-08-01  Martin Sebor  <msebor@redhat.com>
+
+	PR c++/90947
+	* c-c++-common/array-1.c: New test.
+	* g++.dg/abi/mangle73.C: New test.
+	* g++.dg/cpp2a/nontype-class23.C: New test.
+	* g++.dg/init/array53.C: New test.
+
+2019-08-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/91436
+	* g++.dg/lookup/missing-std-include-5.C: Limit test to C++14 and up.
+	* g++.dg/lookup/missing-std-include-6.C: Don't check make_unique in
+	test that runs for C++11.
+	* g++.dg/lookup/missing-std-include-8.C: Check make_unique here.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/87991
+	* gfortran.dg/pr87991.f90: New test.
+
+2013-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90563
+	* gfortran.dg/do_subsript_5.f90: New test.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88072
+	* gfortran.dg/pr88072.f90: New test.
+	* gfortran.dg/unlimited_polymorphic_28.f90: Fix error message.
+
+2019-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90561
+	* gfortran.dg/deferred_character_34.f90: New test.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/89647
+	* gfortran.dg/pr89647.f90: New test.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/87993
+	* gfortran.dg/pr87993.f90: New test.
+
+2019-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91424
+	* gfortran.dg/do_subscript_3.f90: New test.
+	* gfortran.dg/do_subscript_4.f90: New test.
+	* gfortran.dg/pr70754.f90: Use indices that to not overflow.
+
+2019-08-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91359
+	* gfortran.dg/pr91359_1.f: New test.
+	* gfortran.dg/pr91359_2.f: Ditto.
+
+2019-08-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/42546
+	* gfortran.dg/allocated_1.f90: New test.
+	* gfortran.dg/allocated_2.f90: Ditto.
+
+2019-08-02  Tom Honermann  <tom@honermann.net>
+
+	PR c++/88095
+	* g++.dg/cpp2a/udlit-class-nttp-ctad.C: New test.
+	* g++.dg/cpp2a/udlit-class-nttp-ctad-neg.C: New test.
+	* g++.dg/cpp2a/udlit-class-nttp-ctad-neg2.C: New test.
+	* g++.dg/cpp2a/udlit-class-nttp.C: New test.
+	* g++.dg/cpp2a/udlit-class-nttp-neg.C: New test.
+	* g++.dg/cpp2a/udlit-class-nttp-neg2.C: New test.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
Index: gcc/testsuite/g++.dg/lookup/missing-std-include-8.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/lookup/missing-std-include-8.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/lookup/missing-std-include-8.C	(.../branches/gcc-9-branch)
@@ -13,6 +13,15 @@
   // { dg-error "expected primary-expression before '\\)' token" "" { target *-*-* } .-3 }
 }
 
+template<class T>
+void test_make_unique ()
+{
+  std::make_unique<T>(); // { dg-error "'make_unique' is not a member of 'std'" }
+  // { dg-message "'std::make_unique' is only available from C\\+\\+14 onwards" "" { target *-*-* } .-1 }
+  // { dg-error "expected primary-expression before '>' token" "" { target *-*-* } .-2 }
+  // { dg-error "expected primary-expression before '\\)' token" "" { target *-*-* } .-3 }
+}
+
 void test_array ()
 {
   std::array a; // { dg-error "'array' is not a member of 'std'" }
Index: gcc/testsuite/g++.dg/lookup/missing-std-include-5.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/lookup/missing-std-include-5.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/lookup/missing-std-include-5.C	(.../branches/gcc-9-branch)
@@ -1,2 +1,3 @@
+// { dg-do compile { target c++14 } }
 using namespace std::complex_literals; // { dg-error "" }
 // { dg-message "#include <complex>" "" { target *-*-* } .-1 }
Index: gcc/testsuite/g++.dg/lookup/missing-std-include-6.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/lookup/missing-std-include-6.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/lookup/missing-std-include-6.C	(.../branches/gcc-9-branch)
@@ -11,15 +11,6 @@
   // { dg-error "expected primary-expression before '\\)' token" "" { target *-*-* } .-3 }
 }
 
-template<class T>
-void test_make_unique ()
-{
-  auto p = std::make_unique<T>(); // { dg-error "'make_unique' is not a member of 'std'" }
-  // { dg-message "'#include <memory>'" "" { target *-*-* } .-1 }
-  // { dg-error "expected primary-expression before '>' token" "" { target *-*-* } .-2 }
-  // { dg-error "expected primary-expression before '\\)' token" "" { target *-*-* } .-3 }
-}
-
 std::shared_ptr<int> test_shared_ptr; // { dg-error "'shared_ptr' in namespace 'std' does not name a template type" }
 // { dg-message "'#include <memory>'" "" { target *-*-* } .-1 }
 
Index: gcc/testsuite/g++.dg/cpp0x/lambda/lambda-variadic9.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-variadic9.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-variadic9.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,16 @@
+// PR c++/90538
+// { dg-do compile { target c++11 } }
+
+template <class... Ts>
+void f(Ts... ts)
+{
+  [=]{
+    f(ts...);
+    f(ts...);
+  }();
+}
+
+void g()
+{
+  f(1);
+}
Index: gcc/testsuite/g++.dg/cpp0x/range-for19.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/range-for19.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/range-for19.C	(.../branches/gcc-9-branch)
@@ -5,6 +5,6 @@
 int main()
 {
   auto a;        // { dg-error "no initializer" }
-  for(auto i: a) // { dg-error "deduce" }
+  for(auto i: a)
     ;
 }
Index: gcc/testsuite/g++.dg/cpp1y/lambda-init16.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/lambda-init16.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/lambda-init16.C	(.../branches/gcc-9-branch)
@@ -3,7 +3,7 @@
 
 template < class T = int > void f (T)
 {
-  auto g = [&a = f] () {};  // { dg-error "invalid initialization" }
+  auto g = [&a = f] () {};  // { dg-error "auto" }
 }
 
 int main ()
Index: gcc/testsuite/g++.dg/cpp1y/auto-fn56.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp1y/auto-fn56.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp1y/auto-fn56.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,19 @@
+// PR c++/91378
+// { dg-do compile { target c++14 } }
+
+struct B
+{
+  int i;
+};
+
+struct C
+{
+  template <class T> static auto
+  g(B b) noexcept(noexcept(b.i)) { }
+};
+
+template <class T>
+void h(T t)
+{
+  C::g<int>({});
+}
Index: gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-neg2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-neg2.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-neg2.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,13 @@
+// PR c++/88095
+// Test class non-type template parameters for literal operator templates.
+// Validate that non-literal class types are rejected.
+// { dg-do compile { target c++2a } }
+
+struct non_literal_class {
+  constexpr non_literal_class(...) { }
+  ~non_literal_class() {}
+  // auto operator<=> (const non_literal_fixed_string&) = default;
+};
+
+template <non_literal_class> // { dg-error "11:is not a valid type for a template non-type parameter because it is not literal" }
+int operator"" _udl();       // { dg-error "literal operator template .int operator\"\"_udl\\(\\). has invalid parameter list" }
Index: gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,24 @@
+// PR c++/88095
+// Test class non-type template parameters for literal operator templates.
+// Validate support for class template argument deduction.
+// { dg-do compile { target c++2a } }
+
+namespace std {
+using size_t = decltype(sizeof(int));
+}
+
+template <typename CharT, std::size_t N>
+struct fixed_string {
+  constexpr static std::size_t length = N;
+  constexpr fixed_string(...) { }
+  // auto operator<=> (const fixed_string&) = default;
+};
+template <typename CharT, std::size_t N>
+fixed_string(const CharT (&str)[N]) -> fixed_string<CharT, N>;
+
+template <fixed_string fs>
+constexpr std::size_t operator"" _udl() {
+  return decltype(fs)::length;
+}
+
+static_assert("test"_udl == 5);
Index: gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,16 @@
+// PR c++/88095
+// Test class non-type template parameters for literal operator templates.
+// Validate basic support.
+// { dg-do compile { target c++2a } }
+
+struct literal_class {
+  constexpr literal_class(...) { }
+  // auto operator<=> (const fixed_string&) = default;
+};
+
+template <literal_class>
+constexpr int operator"" _udl() {
+  return 1;
+}
+
+static_assert("test"_udl == 1);
Index: gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad-neg2.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad-neg2.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad-neg2.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,20 @@
+// PR c++/88095
+// Test class non-type template parameters for literal operator templates.
+// Validate rejection of class template parameter packs.
+// { dg-do compile { target c++2a } }
+
+namespace std {
+using size_t = decltype(sizeof(int));
+}
+
+template <typename CharT, std::size_t N>
+struct fixed_string {
+  constexpr static std::size_t length = N;
+  constexpr fixed_string(...) { }
+  // auto operator<=> (const fixed_string&) = default;
+};
+template <typename CharT, std::size_t N>
+fixed_string(const CharT (&str)[N]) -> fixed_string<CharT, N>;
+
+template <fixed_string...>
+int operator"" _udl();     // { dg-error "literal operator template .int operator\"\"_udl\\(\\). has invalid parameter list" }
Index: gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-neg.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-neg.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-neg.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,12 @@
+// PR c++/88095
+// Test class non-type template parameters for literal operator templates.
+// Validate that parameter packs are rejected.
+// { dg-do compile { target c++2a } }
+
+struct literal_class {
+  constexpr literal_class(...) { }
+  // auto operator<=> (const fixed_string&) = default;
+};
+
+template <literal_class...>
+int operator"" _udl();      // { dg-error "literal operator template .int operator\"\"_udl\\(\\). has invalid parameter list" }
Index: gcc/testsuite/g++.dg/cpp2a/nontype-class23.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp2a/nontype-class23.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp2a/nontype-class23.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,102 @@
+// PR c++/90947 - Simple lookup table of array of strings is miscompiled
+// Test to verify that the same specializations on non-type template
+// parameters of class types are in fact treated as the same.  Unlike
+// nontype-class15.C which involves only one-dimensional arrays this
+// test involves arrays of arrays and arrays of structs.
+// { dg-do compile { target c++2a } }
+
+struct AA3
+{
+  const char a[2][2][2];
+};
+
+template <AA3> struct BAA3 { };
+
+// Redeclare the same variable using different initialization forms
+// of the same constant to verify that they are in fact all recognized
+// as the same.
+extern BAA3<AA3{{{ "", "" }, { "", "" }}}>       baa3;
+extern BAA3<AA3{{{ "", "" }, { "", { 0, 0 } }}}> baa3;
+extern BAA3<AA3{{{ "", "" }, { "", { 0 } }}}>    baa3;
+extern BAA3<AA3{{{ "", "" }, { "", {} }}}>       baa3;
+extern BAA3<AA3{{{ "", "" }, { "" }}}>           baa3;
+extern BAA3<AA3{{{ "", "" }, { { 0, 0 } }}}>     baa3;
+extern BAA3<AA3{{{ "", "" }, { { 0 } }}}>        baa3;
+extern BAA3<AA3{{{ "", "" }, { {} }}}>           baa3;
+extern BAA3<AA3{{{ "", "" }, { }}}>              baa3;
+extern BAA3<AA3{{{ "", "" }}}>                   baa3;
+extern BAA3<AA3{{{ "", { 0, 0 } }}}>             baa3;
+extern BAA3<AA3{{{ "", { 0 } }}}>                baa3;
+extern BAA3<AA3{{{ "", {} }}}>                   baa3;
+extern BAA3<AA3{{{ "" }}}>                       baa3;
+extern BAA3<AA3{{{ { 0, 0 } }}}>                 baa3;
+extern BAA3<AA3{{{ { 0 } }}}>                    baa3;
+extern BAA3<AA3{{{ {} }}}>                       baa3;
+extern BAA3<AA3{{{ }}}>                          baa3;
+extern BAA3<AA3{{ }}>                            baa3;
+extern BAA3<AA3{ }>                              baa3;
+
+extern BAA3<AA3{{{ "", "" }, { "", "1" }}}>        baa3_1;
+extern BAA3<AA3{{{ "", "" }, { "", { '1', 0 } }}}> baa3_1;
+extern BAA3<AA3{{{ "", "" }, { "", { '1' } }}}>    baa3_1;
+
+extern BAA3<AA3{{{ "", "" }, { "1", {} }}}>        baa3_2;
+extern BAA3<AA3{{{ "", "" }, { "1" }}}>            baa3_2;
+extern BAA3<AA3{{{ "", "" }, { { '1', 0 } }}}>     baa3_2;
+extern BAA3<AA3{{{ "", "" }, { { '1' } }}}>        baa3_2;
+
+extern BAA3<AA3{{{ "", "1" }}}>                    baa3_3;
+extern BAA3<AA3{{{ "", { '1', 0 } }}}>             baa3_3;
+extern BAA3<AA3{{{ "", { '1' } }}}>                baa3_3;
+
+extern BAA3<AA3{{{ "1" }}}>                        baa3_4;
+extern BAA3<AA3{{{ { '1', 0 } }}}>                 baa3_4;
+extern BAA3<AA3{{{ { '1' } }}}>                    baa3_4;
+
+struct AS2
+{
+  struct S { const char a[2], *p; } a[2];
+};
+
+template <AS2> struct BAS2 { };
+
+extern BAS2<AS2{{{ "", 0 }, { "", 0 }}}> bas2;
+extern BAS2<AS2{{{ "", 0 }, { {}, 0 }}}> bas2;
+extern BAS2<AS2{{{ "", 0 }, { "" }}}>    bas2;
+extern BAS2<AS2{{{ "", 0 }, { {} }}}>    bas2;
+extern BAS2<AS2{{{ "", 0 }, { }}}>       bas2;
+extern BAS2<AS2{{{ "", 0 }}}>            bas2;
+extern BAS2<AS2{{{ {}, 0 }}}>            bas2;
+extern BAS2<AS2{{{ "" }}}>               bas2;
+extern BAS2<AS2{{{ {} }}}>               bas2;
+extern BAS2<AS2{{{ }}}>                  bas2;
+extern BAS2<AS2{{ }}>                    bas2;
+extern BAS2<AS2{ }>                      bas2;
+
+struct AS2_2
+{
+  struct S { const char a[2], *p; } a[2][2];
+};
+
+template <AS2_2> struct BAS2_2 { };
+
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { "", 0 }, { "", 0 }}}}> b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { "", 0 }, { "" }}}}>    b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { "", 0 }, { {} }}}}>    b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { "", 0 }, { }}}}>       b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { "", 0 } }}}>           b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { "" } }}}>              b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { {} } }}}>              b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { { }}}}>                  b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 } }, { }}}>                     b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "", 0 }}}}>                           b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { "" }}}}>                              b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { {} }}}}>                              b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }, { }}}}>                                 b2_2;
+extern BAS2_2<AS2_2{{{{ "", 0 }}}}>                                      b2_2;
+extern BAS2_2<AS2_2{{{{ "" }}}}>                                         b2_2;
+extern BAS2_2<AS2_2{{{{ {} }}}}>                                         b2_2;
+extern BAS2_2<AS2_2{{{{ }}}}>                                            b2_2;
+extern BAS2_2<AS2_2{{{ }}}>                                              b2_2;
+extern BAS2_2<AS2_2{{ }}>                                                b2_2;
+extern BAS2_2<AS2_2{ }>                                                  b2_2;
Index: gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad-neg.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad-neg.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/cpp2a/udlit-class-nttp-ctad-neg.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,24 @@
+// PR c++/88095
+// Test class non-type template parameters for literal operator templates.
+// Validate handling of failed class template argument deduction.
+// { dg-do compile { target c++2a } }
+
+namespace std {
+using size_t = decltype(sizeof(int));
+}
+
+template <typename CharT, std::size_t N>
+struct fixed_string {
+  constexpr static std::size_t length = N;
+  constexpr fixed_string(...) { }
+  // auto operator<=> (const fixed_string&) = default;
+};
+// Missing deduction guide.
+
+template <fixed_string fs>
+constexpr std::size_t operator"" _udl() {
+  return decltype(fs)::length;
+}
+
+static_assert("test"_udl == 5); // { dg-error "15:no matching function for call to" }
+                                // { dg-error "15:class template argument deduction failed" "" { target *-*-* } .-1 }
Index: gcc/testsuite/g++.dg/abi/mangle73.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/abi/mangle73.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/abi/mangle73.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,96 @@
+// { dg-do compile { target c++2a } }
+
+struct A
+{
+  char a[2][2];
+};
+
+template <A> struct B { };
+
+typedef B<A{ { { 0, 0 }, { 0, 0 } } }> AZZZZ;
+typedef B<A{ { { 0, 0 }, { 0 } } }>    AZZZ_;
+typedef B<A{ { { 0, 0 } } }>           AZZ__;
+typedef B<A{ { { 0 } } }>              AZ___;
+typedef B<A{ { { } } }>                A____;
+
+typedef B<A{ { { "" }, { "" } } }>     AS_S_;
+typedef B<A{ { { "" }, { 0, 0 } } }>   AS_ZZ;
+typedef B<A{ { { "" }, { 0 } } }>      AS_Z_;
+typedef B<A{ { { "" } } }>             AS___;
+
+
+// Verify that the types mangle the same.
+void a_zzzz (AZZZZ) { }
+// { dg-final { scan-assembler "_Z6a_zzzz1BIXtl1AEEE" } }
+
+void a_zzz_ (AZZZ_) { }
+// { dg-final { scan-assembler "_Z6a_zzz_1BIXtl1AEEE" } }
+
+void a_zz__ (AZZ__) { }
+// { dg-final { scan-assembler "_Z6a_zz__1BIXtl1AEEE" } }
+
+void a_z___ (AZ___) { }
+// { dg-final { scan-assembler "_Z6a_z___1BIXtl1AEEE" } }
+
+void a_____ (A____) { }
+// { dg-final { scan-assembler "_Z6a_____1BIXtl1AEEE" } }
+
+void a_s_s_ (AS_S_) { }
+// { dg-final { scan-assembler "_Z6a_s_s_1BIXtl1AEEE" } }
+
+void a_s_zz (AS_ZZ) { }
+// { dg-final { scan-assembler "_Z6a_s_zz1BIXtl1AEEE" } }
+
+void a_s_z_ (AS_Z_) { }
+// { dg-final { scan-assembler "_Z6a_s_z_1BIXtl1AEEE" } }
+
+void a_s___ (AS___) { }
+// { dg-final { scan-assembler "_Z6a_s___1BIXtl1AEEE" } }
+
+
+struct C
+{
+  struct { const char a[2][2], *p; } a[2];
+};
+
+template <C> struct D { };
+
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }, {{{ 0, 0 }, { 0, 0 }}, 0 }}}> DZZZZZZZZZZ;
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }, {{{ 0, 0 }, { 0, 0 }}}}}> DZZZZZZZZZ_;
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }, {{{ 0, 0 }, { 0 }}}}}>    DZZZZZZZZ__;
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }, {{{ 0, 0 } }}}}>          DZZZZZZZ___;
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }, {{{ 0 } }}}}>             DZZZZZZ____;
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}, 0 }}}>                         DZZZZZ_____;
+typedef D<C{{{{{ 0, 0 }, { 0, 0 }}}}}>                             DZZZZ______;
+typedef D<C{{{{{ 0, 0 }, { 0 }}}}}>                                DZZZ_______;
+typedef D<C{{{{{ 0, 0 }}}}}>                                       DZZ________;
+typedef D<C{{{{{ 0 }}}}}>                                          DZ_________;
+typedef D<C{ }>                                                    D__________;
+
+typedef D<C{{{{{ "" }, { "" }}, 0 }, {{{ "" }, { "" }}, 0 }}}>     DS_S_ZS_S_Z;
+
+void d_zzzzzzzzzz (DZZZZZZZZZZ) { }
+// { dg-final { scan-assembler "_Z12d_zzzzzzzzzz1DIXtl1CEEE" } }
+void d_zzzzzzzzz_ (DZZZZZZZZZ_) { }
+// { dg-final { scan-assembler "_Z12d_zzzzzzzzz_1DIXtl1CEEE" } }
+void d_zzzzzzzz__ (DZZZZZZZZ__) { }
+// { dg-final { scan-assembler "_Z12d_zzzzzzzz__1DIXtl1CEEE" } }
+void d_zzzzzzz___ (DZZZZZZZ___) { }
+// { dg-final { scan-assembler "_Z12d_zzzzzzz___1DIXtl1CEEE" } }
+void d_zzzzzz____ (DZZZZZZ____) { }
+// { dg-final { scan-assembler "_Z12d_zzzzzz____1DIXtl1CEEE" } }
+void d_zzzzz_____ (DZZZZZ_____) { }
+// { dg-final { scan-assembler "_Z12d_zzzzz_____1DIXtl1CEEE" } }
+void d_zzzz______ (DZZZZ______) { }
+// { dg-final { scan-assembler "_Z12d_zzzz______1DIXtl1CEEE" } }
+void d_zzz_______ (DZZZ_______) { }
+// { dg-final { scan-assembler "_Z12d_zzz_______1DIXtl1CEEE" } }
+void d_zz________ (DZZ________) { }
+// { dg-final { scan-assembler "_Z12d_zz________1DIXtl1CEEE" } }
+void d_z_________ (DZ_________) { }
+// { dg-final { scan-assembler "_Z12d_z_________1DIXtl1CEEE" } }
+void d___________ (D__________) { }
+// { dg-final { scan-assembler "_Z12d___________1DIXtl1CEEE" } }
+
+void d_s_s_zs_s_z (DS_S_ZS_S_Z) { }
+// { dg-final { scan-assembler "_Z12d_s_s_zs_s_z1DIXtl1CEEE" } }
Index: gcc/testsuite/g++.dg/init/array53.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/init/array53.C	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/g++.dg/init/array53.C	(.../branches/gcc-9-branch)
@@ -0,0 +1,33 @@
+// PR c++/90947 - Simple lookup table of array of strings is miscompiled
+// Verify that initializers for arrays of elements of a class type with
+// "unusual" data members are correctly recognized as non-zero.
+// { dg-do compile }
+// { dg-options "-O1 -fdump-tree-optimized" }
+
+struct S
+{
+  const char *p;
+  static int i;
+  enum { e };
+  typedef int X;
+  int: 1, b:1;
+  union {
+    int c;
+  };
+  const char *q;
+};
+
+void f (void)
+{
+  const struct S a[2] =
+    {
+     { /* .p = */ "", /* .b = */ 0, /* .c = */ 0, /* .q = */ "" },
+     { /* .p = */ "", /* .b = */ 0, /* .c = */ 0, /* .q = */ "" }
+    };
+
+  if (!a[0].p || *a[0].p || !a[0].q || *a[0].q
+      || !a[1].p || *a[1].p || !a[1].q || *a[1].q)
+    __builtin_abort ();
+}
+
+// { dg-final { scan-tree-dump-not "abort" "optimized" } }
Index: gcc/testsuite/c-c++-common/array-1.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/array-1.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/testsuite/c-c++-common/array-1.c	(.../branches/gcc-9-branch)
@@ -0,0 +1,247 @@
+// PR c++/90947 - Simple lookup table of array of strings is miscompiled
+// { dg-do compile }
+// { dg-options "-O1 -fdump-tree-optimized" }
+
+#define assert(expr) ((expr) ? (void)0 : __builtin_abort ())
+
+void pr90947 (void)
+{
+  int vecsize = 4;
+  int index = 0;
+  static const char *a[4][4] =
+    {
+     { ".x", ".y", ".z", ".w" },
+     { ".xy", ".yz", ".zw", 0 },
+     { ".xyz", ".yzw", 0, 0 },
+     { "", 0, 0, 0 },
+    };
+
+  assert (vecsize >= 1 && vecsize <= 4);
+  assert (index >= 0 && index < 4);
+  assert (a[vecsize - 1][index]);
+}
+
+void f_a1_1 (void)
+{
+  {
+    const char* a[1][1] = { { 0 } };
+    assert (0 == a[0][0]);
+  }
+  {
+    const char* a[1][1] = { { "" } };
+    assert ('\0' == *a[0][0]);
+  }
+}
+
+void f_a2_1 (void)
+{
+  {
+    const char* a[2][1] = { { "" }, { "" } };
+    assert ('\0' == *a[0][0] && '\0' == *a[1][0]);
+  }
+  {
+    const char* a[2][1] = { { 0 }, { "" } };
+    assert (0 == a[0][0] && '\0' == *a[1][0]);
+  }
+  {
+    const char* a[2][1] = { { }, { "" } };
+    assert (0 == a[0][0] && '\0' == *a[1][0]);
+  }
+}
+
+void f_a2_2 (void)
+{
+  {
+    const char* a[2][2] = { { "", "" }, { "", "" } };
+    assert ('\0' == *a[0][0] && '\0' == *a[0][1]);
+    assert ('\0' == *a[1][0] && '\0' == *a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { "", "" }, { "", 0 } };
+    assert ('\0' == *a[0][0] && '\0' == *a[0][1]);
+    assert ('\0' == *a[1][0] && 0 == a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { "", "" }, { "" } };
+    assert ('\0' == *a[0][0] && '\0' == *a[0][1]);
+    assert ('\0' == *a[1][0] && 0 == a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { "", "" }, { 0, "" } };
+    assert ('\0' == *a[0][0] && '\0' == *a[0][1]);
+    assert (0 == a[1][0] && '\0' == *a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { "", 0 }, { 0, "" } };
+    assert ('\0' == *a[0][0] && 0 == a[0][1]);
+    assert (0 == a[1][0] && '\0' == *a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { 0, 0 }, { 0, "" } };
+    assert (0 == a[0][0] && 0 == a[0][1]);
+    assert (0 == a[1][0] && '\0' == *a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { 0 }, { 0, "" } };
+    assert (0 == a[0][0] && 0 == a[0][1]);
+    assert (0 == a[1][0] && '\0' == *a[1][1]);
+  }
+  {
+    const char* a[2][2] = { { }, { 0, "" } };
+    assert (0 == a[0][0] && 0 == a[0][1]);
+    assert (0 == a[1][0] && '\0' == *a[1][1]);
+  }
+}
+
+void f_a2_2_2 (void)
+{
+  {
+    const char* a[2][2][2] =
+      { { { "", "" }, { "", "" } }, { { "", "" }, { "", "" } } };
+
+    assert ('\0' == *a[0][0][0] && '\0' == *a[0][0][1]);
+    assert ('\0' == *a[0][1][0] && '\0' == *a[0][1][1]);
+    assert ('\0' == *a[1][0][0] && '\0' == *a[1][0][1]);
+    assert ('\0' == *a[1][1][0] && '\0' == *a[1][1][1]);
+  }
+
+  {
+    const char* a[2][2][2] =
+      { { { "", "" }, { "", "" } }, { { "", "" }, { 0, "" } } };
+
+    assert ('\0' == *a[0][0][0] && '\0' == *a[0][0][1]);
+    assert ('\0' == *a[0][1][0] && '\0' == *a[0][1][1]);
+    assert ('\0' == *a[1][0][0] && '\0' == *a[1][0][1]);
+    assert (0 == a[1][1][0] && '\0' == *a[1][1][1]);
+  }
+
+  {
+    const char* a[2][2][2] =
+      { { { "", "" }, { "", "" } }, { { 0, 0 }, { 0, "" } } };
+
+    assert ('\0' == *a[0][0][0] && '\0' == *a[0][0][1]);
+    assert ('\0' == *a[0][1][0] && '\0' == *a[0][1][1]);
+    assert (0 == a[1][0][0] && 0 == a[1][0][1]);
+    assert (0 == a[1][1][0] && '\0' == *a[1][1][1]);
+  }
+
+  {
+    const char* a[2][2][2] =
+      { { { "", "" }, { 0, 0 } }, { { 0, 0 }, { 0, "" } } };
+
+    assert ('\0' == *a[0][0][0] && '\0' == *a[0][0][1]);
+    assert (0 == a[0][1][0] && 0 == a[0][1][1]);
+    assert (0 == a[1][0][0] && 0 == a[1][0][1]);
+    assert (0 == a[1][1][0] && '\0' == *a[1][1][1]);
+  }
+
+  {
+    const char* a[2][2][2] =
+      { { { 0, 0 }, { 0, 0 } }, { { 0, 0 }, { 0, "" } } };
+
+    assert (0 == a[0][0][0] && 0 == a[0][0][1]);
+    assert (0 == a[0][1][0] && 0 == a[0][1][1]);
+    assert (0 == a[1][0][0] && 0 == a[1][0][1]);
+    assert (0 == a[1][1][0] && '\0' == *a[1][1][1]);
+  }
+
+  {
+    const char* a[2][2][2] =
+      { { { }, { } }, { { }, { 0, "" } } };
+
+    assert (0 == a[0][0][0] && 0 == a[0][0][1]);
+    assert (0 == a[0][1][0] && 0 == a[0][1][1]);
+    assert (0 == a[1][0][0] && 0 == a[1][0][1]);
+    assert (0 == a[1][1][0] && '\0' == *a[1][1][1]);
+  }
+}
+
+void f_sa2_2_2 (void)
+{
+  struct S { const char a[2], *s, c; };
+
+  {
+    const struct S a[2][2][2] = {
+      { },
+      {
+        { { }, { "", "" } },
+        { }
+      }
+    };
+
+    assert ('\0' == *a[0][0][0].a && 0 == a[0][0][0].s && 0 == a[0][0][0].c);
+    assert ('\0' == *a[0][0][1].a && 0 == a[0][0][1].s && 0 == a[0][0][1].c);
+    assert ('\0' == *a[0][1][0].a && 0 == a[0][1][0].s && 0 == a[0][1][0].c);
+    assert ('\0' == *a[0][1][1].a && 0 == a[0][1][1].s && 0 == a[0][1][1].c);
+
+    assert ('\0' == *a[1][0][0].a && 0 == a[1][0][0].s && 0 == a[1][0][0].c);
+    assert ('\0' == *a[1][0][1].a && '\0' == *a[1][0][1].s && 0 == a[1][0][1].c);
+    assert ('\0' == *a[1][1][0].a && 0 == a[1][1][0].s && 0 == a[1][1][0].c);
+    assert ('\0' == *a[1][1][1].a && 0 == a[1][1][1].s && 0 == a[1][1][1].c);
+  }
+
+  {
+    const struct S a[2][2][2] = {
+      { },
+      {
+        { { } },
+        { { "", "" } }
+      }
+    };
+
+    assert ('\0' == *a[0][0][0].a && 0 == a[0][0][0].s);
+    assert ('\0' == *a[0][0][1].a && 0 == a[0][0][1].s);
+    assert ('\0' == *a[0][1][0].a && 0 == a[0][1][0].s);
+    assert ('\0' == *a[0][1][1].a && 0 == a[0][1][1].s);
+
+    assert ('\0' == *a[1][0][0].a && 0 == a[1][0][0].s);
+    assert ('\0' == *a[1][0][1].a && 0 == a[1][0][1].s);
+    assert ('\0' == *a[1][1][0].a && '\0' == *a[1][1][0].s);
+    assert ('\0' == *a[1][1][1].a && 0 == a[1][1][1].s);
+  }
+
+  {
+    const struct S a[2][2][2] = {
+      { },
+      {
+        { { }, { } },
+        { { }, { "", "", 0 } }
+      }
+    };
+
+    assert ('\0' == *a[0][0][0].a && 0 == a[0][0][0].s);
+    assert ('\0' == *a[0][0][1].a && 0 == a[0][0][1].s);
+    assert ('\0' == *a[0][1][0].a && 0 == a[0][1][0].s);
+    assert ('\0' == *a[0][1][1].a && 0 == a[0][1][1].s);
+
+    assert ('\0' == *a[1][0][0].a && 0 == a[1][0][0].s);
+    assert ('\0' == *a[1][0][1].a && 0 == a[1][0][1].s);
+    assert ('\0' == *a[1][1][0].a && 0 == a[1][1][0].s);
+    assert ('\0' == *a[1][1][1].a && '\0' == *a[1][1][1].s);
+  }
+
+  {
+    const struct S a[2][2][2] = {
+      {
+       { { { 0 }, 0, 0 }, { { 0 } , 0, 0 } },
+       { { { 0 }, 0, 0 }, { { 0 } , 0, 0 } },
+      },
+      {
+       { { { 0 }, 0, 0 }, { { 0 } , 0, 0 } },
+       { { }, { "", "", 0 } }
+      }
+    };
+
+    assert ('\0' == *a[0][0][0].a && 0 == a[0][0][0].s);
+    assert ('\0' == *a[0][0][1].a && 0 == a[0][0][1].s);
+    assert ('\0' == *a[0][1][0].a && 0 == a[0][1][0].s);
+    assert ('\0' == *a[0][1][1].a && 0 == a[0][1][1].s);
+
+    assert ('\0' == *a[1][0][0].a && 0 == a[1][0][0].s);
+    assert ('\0' == *a[1][0][1].a && 0 == a[1][0][1].s);
+    assert ('\0' == *a[1][1][0].a && 0 == a[1][1][0].s);
+    assert ('\0' == *a[1][1][1].a && '\0' == *a[1][1][1].s);
+  }
+}
+
+// { dg-final { scan-tree-dump-not "abort" "optimized" } }
Index: gcc/cp/decl.c
===================================================================
--- a/src/gcc/cp/decl.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/cp/decl.c	(.../branches/gcc-9-branch)
@@ -5836,9 +5836,10 @@
       /* Pointers initialized to strings must be treated as non-zero
 	 even if the string is empty.  */
       tree init_type = TREE_TYPE (elt_init);
-      if ((POINTER_TYPE_P (elt_type) != POINTER_TYPE_P (init_type))
-	  || !initializer_zerop (elt_init))
+      if ((POINTER_TYPE_P (elt_type) != POINTER_TYPE_P (init_type)))
 	last_nonzero = index;
+      else if (!type_initializer_zero_p (elt_type, elt_init))
+	last_nonzero = index;
 
       /* This can happen with an invalid initializer (c++/54501).  */
       if (d->cur == old_cur && !sized_array_p)
Index: gcc/cp/ChangeLog
===================================================================
--- a/src/gcc/cp/ChangeLog	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/cp/ChangeLog	(.../branches/gcc-9-branch)
@@ -1,3 +1,40 @@
+2019-08-14  Martin Sebor  <msebor@redhat.com>
+
+	2019-08-01  Martin Sebor  <msebor@redhat.com>
+
+	PR c++/90947
+	* decl.c (reshape_init_array_1): Avoid truncating initializer
+	lists containing string literals.
+
+2019-08-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/91436
+	* name-lookup.c (get_std_name_hint): Fix min_dialect field for
+	complex_literals and make_unique entries.
+
+2019-08-12  Tom Honermann  <tom@honermann.net>
+
+	* parser.c (cp_parser_template_declaration_after_parameters): Enable
+	class template argument deduction for non-type template parameters
+	in literal operator templates.
+
+2019-08-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/91378 - ICE with noexcept and auto return type.
+	* pt.c (maybe_instantiate_noexcept): push_to_top_level.
+
+	PR c++/90538 - multiple expansions of capture packs
+	* cp-tree.h (DECLTYPE_FOR_INIT_CAPTURE): Remove.
+	* lambda.c (add_capture): Copy parameter packs from init.
+	(lambda_capture_field_type): Always use auto for init-capture.
+	* pt.c (uses_parameter_packs): Return tree.
+	(tsubst) [DECLTYPE_TYPE]: Remove init-capture handling.
+	(gen_elem_of_pack_expansion_instantiation): Don't push
+	local_specialization_stack.
+	(prepend_one_capture): New.
+	(tsubst_lambda_expr): Use it.  Don't touch local_specializations.
+	(do_auto_deduction): Avoid redundant error.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
@@ -16,7 +53,7 @@
 
 	Backported from mainline
 	2019-08-02  Marek Polacek  <polacek@redhat.com>
-	
+
 	PR c++/91230 - wrong error with __PRETTY_FUNCTION__ and generic lambda.
 	* pt.c (value_dependent_expression_p): Consider __PRETTY_FUNCTION__
 	inside a template function value-dependent.
Index: gcc/cp/pt.c
===================================================================
--- a/src/gcc/cp/pt.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/cp/pt.c	(.../branches/gcc-9-branch)
@@ -3875,7 +3875,7 @@
 }
 
 /* Determines if the expression or type T uses any parameter packs.  */
-bool
+tree
 uses_parameter_packs (tree t)
 {
   tree parameter_packs = NULL_TREE;
@@ -3885,7 +3885,7 @@
   ppd.type_pack_expansion_p = false;
   cp_walk_tree (&t, &find_parameter_packs_r, &ppd, ppd.visited);
   delete ppd.visited;
-  return parameter_packs != NULL_TREE;
+  return parameter_packs;
 }
 
 /* Turn ARG, which may be an expression, type, or a TREE_LIST
@@ -11757,10 +11757,6 @@
       ARGUMENT_PACK_SELECT_INDEX (aps) = index;
     }
 
-  // Any local specialization bindings arising from this substitution
-  // cannot be reused for a different INDEX.
-  local_specialization_stack lss (lss_copy);
-
   /* Substitute into the PATTERN with the (possibly altered)
      arguments.  */
   if (pattern == in_decl)
@@ -15130,24 +15126,12 @@
 				      /*function_p*/false,
 				      /*integral_constant_expression*/false);
 
-	if (DECLTYPE_FOR_INIT_CAPTURE (t))
-	  {
-	    if (type == NULL_TREE)
-	      {
-		if (complain & tf_error)
-		  error ("empty initializer in lambda init-capture");
-		type = error_mark_node;
-	      }
-	    else if (TREE_CODE (type) == TREE_LIST)
-	      type = build_x_compound_expr_from_list (type, ELK_INIT, complain);
-	  }
-
 	--cp_unevaluated_operand;
 	--c_inhibit_evaluation_warnings;
 
 	if (DECLTYPE_FOR_LAMBDA_CAPTURE (t))
 	  type = lambda_capture_field_type (type,
-					    DECLTYPE_FOR_INIT_CAPTURE (t),
+					    false /*explicit_init*/,
 					    DECLTYPE_FOR_REF_CAPTURE (t));
 	else if (DECLTYPE_FOR_LAMBDA_PROXY (t))
 	  type = lambda_proxy_type (type);
@@ -18014,6 +17998,33 @@
   return t;
 }
 
+/* Subroutine of tsubst_lambda_expr: add the FIELD/INIT capture pair to the
+   LAMBDA_EXPR_CAPTURE_LIST passed in LIST.  Do deduction for a previously
+   dependent init-capture.  */
+
+static void
+prepend_one_capture (tree field, tree init, tree &list,
+		     tsubst_flags_t complain)
+{
+  if (tree auto_node = type_uses_auto (TREE_TYPE (field)))
+    {
+      tree type = NULL_TREE;
+      if (!init)
+	{
+	  if (complain & tf_error)
+	    error ("empty initializer in lambda init-capture");
+	  init = error_mark_node;
+	}
+      else if (TREE_CODE (init) == TREE_LIST)
+	init = build_x_compound_expr_from_list (init, ELK_INIT, complain);
+      if (!type)
+	type = do_auto_deduction (TREE_TYPE (field), init, auto_node, complain);
+      TREE_TYPE (field) = type;
+      cp_apply_type_quals_to_decl (cp_type_quals (type), field);
+    }
+  list = tree_cons (field, init, list);
+}
+
 /* T is a LAMBDA_EXPR.  Generate a new LAMBDA_EXPR for the current
    instantiation context.  Instantiating a pack expansion containing a lambda
    might result in multiple lambdas all based on the same lambda in the
@@ -18025,17 +18036,8 @@
   tree oldfn = lambda_function (t);
   in_decl = oldfn;
 
-  /* If we have already specialized this lambda expr, reuse it.  See
-     PR c++/87322.  */
-  if (local_specializations)
-    if (tree r = retrieve_local_specialization (t))
-      return r;
-
   tree r = build_lambda_expr ();
 
-  if (local_specializations)
-    register_local_specialization (r, t);
-
   LAMBDA_EXPR_LOCATION (r)
     = LAMBDA_EXPR_LOCATION (t);
   LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (r)
@@ -18088,15 +18090,15 @@
 	  gcc_assert (TREE_CODE (init) == TREE_VEC
 		      && TREE_VEC_LENGTH (init) == len);
 	  for (int i = 0; i < len; ++i)
-	    LAMBDA_EXPR_CAPTURE_LIST (r)
-	      = tree_cons (TREE_VEC_ELT (field, i),
-			   TREE_VEC_ELT (init, i),
-			   LAMBDA_EXPR_CAPTURE_LIST (r));
+	    prepend_one_capture (TREE_VEC_ELT (field, i),
+				 TREE_VEC_ELT (init, i),
+				 LAMBDA_EXPR_CAPTURE_LIST (r),
+				 complain);
 	}
       else
 	{
-	  LAMBDA_EXPR_CAPTURE_LIST (r)
-	    = tree_cons (field, init, LAMBDA_EXPR_CAPTURE_LIST (r));
+	  prepend_one_capture (field, init, LAMBDA_EXPR_CAPTURE_LIST (r),
+			       complain);
 
 	  if (id_equal (DECL_NAME (field), "__this"))
 	    LAMBDA_EXPR_THIS_CAPTURE (r) = field;
@@ -24321,12 +24323,11 @@
 	}
       else if (push_tinst_level (fn))
 	{
+	  push_to_top_level ();
 	  push_access_scope (fn);
 	  push_deferring_access_checks (dk_no_deferred);
 	  input_location = DECL_SOURCE_LOCATION (fn);
 
-	  tree save_ccp = current_class_ptr;
-	  tree save_ccr = current_class_ref;
 	  /* If needed, set current_class_ptr for the benefit of
 	     tsubst_copy/PARM_DECL.  */
 	  tree tdecl = DECL_TEMPLATE_RESULT (DECL_TI_TEMPLATE (fn));
@@ -24352,9 +24353,6 @@
 					/*function_p=*/false,
 					/*i_c_e_p=*/true);
 
-	  current_class_ptr = save_ccp;
-	  current_class_ref = save_ccr;
-
 	  /* Build up the noexcept-specification.  */
 	  spec = build_noexcept_spec (noex, tf_warning_or_error);
 
@@ -24364,6 +24362,7 @@
 	  pop_deferring_access_checks ();
 	  pop_access_scope (fn);
 	  pop_tinst_level ();
+	  pop_from_top_level ();
 	}
       else
 	spec = noexcept_false_spec;
@@ -27615,6 +27614,9 @@
     }
   else
     {
+      if (error_operand_p (init))
+	return error_mark_node;
+
       tree parms = build_tree_list (NULL_TREE, type);
       tree tparms;
 
Index: gcc/cp/parser.c
===================================================================
--- a/src/gcc/cp/parser.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/cp/parser.c	(.../branches/gcc-9-branch)
@@ -27911,7 +27911,10 @@
 	    {
 	      tree parm_list = TREE_VEC_ELT (parameter_list, 0);
 	      tree parm = INNERMOST_TEMPLATE_PARMS (parm_list);
-	      if (CLASS_TYPE_P (TREE_TYPE (parm)))
+	      if (TREE_CODE (parm) != PARM_DECL)
+		ok = false;
+	      else if (MAYBE_CLASS_TYPE_P (TREE_TYPE (parm))
+		       && !TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm)))
 		/* OK, C++20 string literal operator template.  We don't need
 		   to warn in lower dialects here because we will have already
 		   warned about the template parameter.  */;
@@ -27925,7 +27928,7 @@
 	      tree type = INNERMOST_TEMPLATE_PARMS (parm_type);
 	      tree parm_list = TREE_VEC_ELT (parameter_list, 1);
 	      tree parm = INNERMOST_TEMPLATE_PARMS (parm_list);
-	      if (parm == error_mark_node
+	      if (TREE_CODE (parm) != PARM_DECL
 		  || TREE_TYPE (parm) != TREE_TYPE (type)
 		  || !TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm)))
 		ok = false;
Index: gcc/cp/lambda.c
===================================================================
--- a/src/gcc/cp/lambda.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/cp/lambda.c	(.../branches/gcc-9-branch)
@@ -220,17 +220,8 @@
   tree type;
   bool is_this = is_this_parameter (tree_strip_nop_conversions (expr));
 
-  if (!is_this && type_dependent_expression_p (expr))
+  if (!is_this && explicit_init_p)
     {
-      type = cxx_make_type (DECLTYPE_TYPE);
-      DECLTYPE_TYPE_EXPR (type) = expr;
-      DECLTYPE_FOR_LAMBDA_CAPTURE (type) = true;
-      DECLTYPE_FOR_INIT_CAPTURE (type) = explicit_init_p;
-      DECLTYPE_FOR_REF_CAPTURE (type) = by_reference_p;
-      SET_TYPE_STRUCTURAL_EQUALITY (type);
-    }
-  else if (!is_this && explicit_init_p)
-    {
       tree auto_node = make_auto ();
       
       type = auto_node;
@@ -240,6 +231,14 @@
 	type = build_reference_type (type);
       type = do_auto_deduction (type, expr, auto_node);
     }
+  else if (!is_this && type_dependent_expression_p (expr))
+    {
+      type = cxx_make_type (DECLTYPE_TYPE);
+      DECLTYPE_TYPE_EXPR (type) = expr;
+      DECLTYPE_FOR_LAMBDA_CAPTURE (type) = true;
+      DECLTYPE_FOR_REF_CAPTURE (type) = by_reference_p;
+      SET_TYPE_STRUCTURAL_EQUALITY (type);
+    }
   else
     {
       type = non_reference (unlowered_expr_type (expr));
@@ -602,7 +601,16 @@
   name = get_identifier (buf);
 
   if (variadic)
-    type = make_pack_expansion (type);
+    {
+      type = make_pack_expansion (type);
+      if (explicit_init_p)
+	/* With an explicit initializer 'type' is auto, which isn't really a
+	   parameter pack in this context.  We will want as many fields as we
+	   have elements in the expansion of the initializer, so use its packs
+	   instead.  */
+	PACK_EXPANSION_PARAMETER_PACKS (type)
+	  = uses_parameter_packs (initializer);
+    }
 
   /* Make member variable.  */
   member = build_decl (input_location, FIELD_DECL, name, type);
Index: gcc/cp/cp-tree.h
===================================================================
--- a/src/gcc/cp/cp-tree.h	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/cp/cp-tree.h	(.../branches/gcc-9-branch)
@@ -423,7 +423,6 @@
       LAMBDA_EXPR_MUTABLE_P (in LAMBDA_EXPR)
       DECL_FINAL_P (in FUNCTION_DECL)
       QUALIFIED_NAME_IS_TEMPLATE (in SCOPE_REF)
-      DECLTYPE_FOR_INIT_CAPTURE (in DECLTYPE_TYPE)
       CONSTRUCTOR_IS_DEPENDENT (in CONSTRUCTOR)
       TINFO_USED_TEMPLATE_ID (in TEMPLATE_INFO)
       PACK_EXPANSION_SIZEOF_P (in *_PACK_EXPANSION)
@@ -4471,12 +4470,10 @@
   (DECLTYPE_TYPE_CHECK (NODE))->type_common.string_flag
 
 /* These flags indicate that we want different semantics from normal
-   decltype: lambda capture just drops references, init capture
-   uses auto semantics, lambda proxies look through implicit dereference.  */
+   decltype: lambda capture just drops references,
+   lambda proxies look through implicit dereference.  */
 #define DECLTYPE_FOR_LAMBDA_CAPTURE(NODE) \
   TREE_LANG_FLAG_0 (DECLTYPE_TYPE_CHECK (NODE))
-#define DECLTYPE_FOR_INIT_CAPTURE(NODE) \
-  TREE_LANG_FLAG_1 (DECLTYPE_TYPE_CHECK (NODE))
 #define DECLTYPE_FOR_LAMBDA_PROXY(NODE) \
   TREE_LANG_FLAG_2 (DECLTYPE_TYPE_CHECK (NODE))
 #define DECLTYPE_FOR_REF_CAPTURE(NODE) \
@@ -6779,7 +6776,7 @@
 extern tree instantiate_decl			(tree, bool, bool);
 extern int comp_template_parms			(const_tree, const_tree);
 extern bool builtin_pack_fn_p			(tree);
-extern bool uses_parameter_packs                (tree);
+extern tree uses_parameter_packs                (tree);
 extern bool template_parameter_pack_p           (const_tree);
 extern bool function_parameter_pack_p		(const_tree);
 extern bool function_parameter_expanded_from_pack_p (tree, tree);
Index: gcc/cp/name-lookup.c
===================================================================
--- a/src/gcc/cp/name-lookup.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/cp/name-lookup.c	(.../branches/gcc-9-branch)
@@ -5656,7 +5656,7 @@
     {"bitset", "<bitset>", cxx11},
     /* <complex>.  */
     {"complex", "<complex>", cxx98},
-    {"complex_literals", "<complex>", cxx98},
+    {"complex_literals", "<complex>", cxx14},
     /* <condition_variable>. */
     {"condition_variable", "<condition_variable>", cxx11},
     {"condition_variable_any", "<condition_variable>", cxx11},
@@ -5718,7 +5718,7 @@
     {"multimap", "<map>", cxx98},
     /* <memory>.  */
     {"make_shared", "<memory>", cxx11},
-    {"make_unique", "<memory>", cxx11},
+    {"make_unique", "<memory>", cxx14},
     {"shared_ptr", "<memory>", cxx11},
     {"unique_ptr", "<memory>", cxx11},
     {"weak_ptr", "<memory>", cxx11},
Index: gcc/lto-wrapper.c
===================================================================
--- a/src/gcc/lto-wrapper.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/lto-wrapper.c	(.../branches/gcc-9-branch)
@@ -128,12 +128,11 @@
 #define DUMPBASE_SUFFIX ".ltrans18446744073709551615"
 
 /* Create decoded options from the COLLECT_GCC and COLLECT_GCC_OPTIONS
-   environment according to LANG_MASK.  */
+   environment.  */
 
 static void
 get_options_from_collect_gcc_options (const char *collect_gcc,
 				      const char *collect_gcc_options,
-				      unsigned int lang_mask,
 				      struct cl_decoded_option **decoded_options,
 				      unsigned int *decoded_options_count)
 {
@@ -175,8 +174,7 @@
   argc = obstack_object_size (&argv_obstack) / sizeof (void *) - 1;
   argv = XOBFINISH (&argv_obstack, const char **);
 
-  decode_cmdline_options_to_array (argc, (const char **)argv,
-				   lang_mask,
+  decode_cmdline_options_to_array (argc, (const char **)argv, CL_DRIVER,
 				   decoded_options, decoded_options_count);
   obstack_free (&argv_obstack, NULL);
 }
@@ -1008,8 +1006,7 @@
     {
       struct cl_decoded_option *f2decoded_options;
       unsigned int f2decoded_options_count;
-      get_options_from_collect_gcc_options (collect_gcc,
-					    fopts, CL_LANG_ALL,
+      get_options_from_collect_gcc_options (collect_gcc, fopts,
 					    &f2decoded_options,
 					    &f2decoded_options_count);
       if (!fdecoded_options)
@@ -1150,7 +1147,6 @@
     fatal_error (input_location,
 		 "environment variable COLLECT_GCC_OPTIONS must be set");
   get_options_from_collect_gcc_options (collect_gcc, collect_gcc_options,
-					CL_LANG_ALL,
 					&decoded_options,
 					&decoded_options_count);
 
Index: gcc/fortran/intrinsic.c
===================================================================
--- a/src/gcc/fortran/intrinsic.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/intrinsic.c	(.../branches/gcc-9-branch)
@@ -4180,6 +4180,40 @@
   if (f == NULL && a == NULL)	/* No arguments */
     return true;
 
+  /* ALLOCATED has two mutually exclusive keywords, but only one
+     can be present at time and neither is optional. */
+  if (strcmp (name, "allocated") == 0 && a->name)
+    {
+      if (strcmp (a->name, "scalar") == 0)
+	{
+          if (a->next)
+	    goto whoops;
+	  if (a->expr->rank != 0)
+	    {
+	      gfc_error ("Scalar entity required at %L", &a->expr->where);
+	      return false;
+	    }
+          return true;
+	}
+      else if (strcmp (a->name, "array") == 0)
+	{
+          if (a->next)
+	    goto whoops;
+	  if (a->expr->rank == 0)
+	    {
+	      gfc_error ("Array entity required at %L", &a->expr->where);
+	      return false;
+	    }
+          return true;
+	}
+      else
+	{
+	  gfc_error ("Invalid keyword %qs in %qs intrinsic function at %L",
+		     a->name, name, &a->expr->where);
+	  return false;
+	}
+    }
+
   for (;;)
     {		/* Put the nonkeyword arguments in a 1:1 correspondence */
       if (f == NULL)
@@ -4199,6 +4233,7 @@
   if (a == NULL)
     goto do_sort;
 
+whoops:
   gfc_error ("Too many arguments in call to %qs at %L", name, where);
   return false;
 
Index: gcc/fortran/trans-expr.c
===================================================================
--- a/src/gcc/fortran/trans-expr.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/trans-expr.c	(.../branches/gcc-9-branch)
@@ -10603,7 +10603,8 @@
       if (expr1->ts.deferred
 	  && gfc_expr_attr (expr1).allocatable
 	  && gfc_check_dependency (expr1, expr2, true))
-	rse.string_length = gfc_evaluate_now (rse.string_length, &rse.pre);
+	rse.string_length =
+	  gfc_evaluate_now_function_scope (rse.string_length, &rse.pre);
       string_length = rse.string_length;
     }
   else
Index: gcc/fortran/ChangeLog
===================================================================
--- a/src/gcc/fortran/ChangeLog	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/ChangeLog	(.../branches/gcc-9-branch)
@@ -1,3 +1,62 @@
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/87991
+	* resolve.c (check_data_variable): data-stmt-object with pointer
+	attribute requires a data-stmt-value with the target attribute.
+
+2013-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90563
+	* frontend-passes.c (insert_index): Suppress errors while
+	simplifying the resulting expression.
+ 
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/88072
+	* misc.c (gfc_typename): Do not point to something that ought not to
+	be pointed at.
+
+2019-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90561
+	* trans.h (gfc_evaluate_now_function_scope): New function.
+	* trans.c (gfc_evaluate_now_function_scope): New function.
+	* trans-expr.c (gfc_trans_assignment): Use it.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/89647
+	resolve.c (resolve_typebound_procedure): Allow host associated
+	procedure to be a binding target.  While here, wrap long line.
+
+2019-08-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/87993
+	* expr.c (gfc_simplify_expr): Simplifcation of an array with a kind
+	type inquiry suffix yields a constant expression.
+
+2019-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91424
+	* frontend-passes.c (do_subscript): Do not warn for an
+	expression a second time.  Do not warn about a zero-trip loop.
+	(doloop_warn): Also look at contained namespaces.
+
+2019-08-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91359
+	* trans-decl.c (gfc_generate_return): Ensure something is returned
+	from a function.
+
+2019-08-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/42546
+	* check.c(gfc_check_allocated): Add comment pointing to ...
+ 	* intrinsic.c(sort_actual): ... the checking done here.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
Index: gcc/fortran/expr.c
===================================================================
--- a/src/gcc/fortran/expr.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/expr.c	(.../branches/gcc-9-branch)
@@ -2220,6 +2220,11 @@
       if (!simplify_ref_chain (p->ref, type, &p))
 	return false;
 
+      /* If the following conditions hold, we found something like kind type
+	 inquiry of the form a(2)%kind while simplify the ref chain.  */
+      if (p->expr_type == EXPR_CONSTANT && !p->ref && !p->rank && !p->shape)
+	return true;
+
       if (!simplify_constructor (p->value.constructor, type))
 	return false;
 
Index: gcc/fortran/trans.c
===================================================================
--- a/src/gcc/fortran/trans.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/trans.c	(.../branches/gcc-9-branch)
@@ -118,7 +118,20 @@
   return gfc_evaluate_now_loc (input_location, expr, pblock);
 }
 
+/* Like gfc_evaluate_now, but add the created variable to the
+   function scope.  */
 
+tree
+gfc_evaluate_now_function_scope (tree expr, stmtblock_t * pblock)
+{
+  tree var;
+  var = gfc_create_var_np (TREE_TYPE (expr), NULL);
+  gfc_add_decl_to_function (var);
+  gfc_add_modify (pblock, var, expr);
+
+  return var;
+}
+
 /* Build a MODIFY_EXPR node and add it to a given statement block PBLOCK.
    A MODIFY_EXPR is an assignment:
    LHS <- RHS.  */
Index: gcc/fortran/trans.h
===================================================================
--- a/src/gcc/fortran/trans.h	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/trans.h	(.../branches/gcc-9-branch)
@@ -507,6 +507,7 @@
 /* If the value is not constant, Create a temporary and copy the value.  */
 tree gfc_evaluate_now_loc (location_t, tree, stmtblock_t *);
 tree gfc_evaluate_now (tree, stmtblock_t *);
+tree gfc_evaluate_now_function_scope (tree, stmtblock_t *);
 
 /* Find the appropriate variant of a math intrinsic.  */
 tree gfc_builtin_decl_for_float_kind (enum built_in_function, int);
Index: gcc/fortran/frontend-passes.c
===================================================================
--- a/src/gcc/fortran/frontend-passes.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/frontend-passes.c	(.../branches/gcc-9-branch)
@@ -2519,7 +2519,12 @@
   data.sym = sym;
   mpz_init_set (data.val, val);
   gfc_expr_walker (&n, callback_insert_index, (void *) &data);
+
+  /* Suppress errors here - we could get errors here such as an
+     out of bounds access for arrays, see PR 90563.  */
+  gfc_push_suppress_errors ();
   gfc_simplify_expr (n, 0);
+  gfc_pop_suppress_errors ();
 
   if (n->expr_type == EXPR_CONSTANT)
     {
@@ -2557,6 +2562,12 @@
   if (in_assoc_list)
     return 0;
 
+  /* We already warned about this.  */
+  if (v->do_not_warn)
+    return 0;
+
+  v->do_not_warn = 1;
+
   for (ref = v->ref; ref; ref = ref->next)
     {
       if (ref->type == REF_ARRAY && ref->u.ar.type == AR_ELEMENT)
@@ -2609,7 +2620,6 @@
 	      else
 		have_do_start = false;
 
-
 	      if (dl->ext.iterator->end->expr_type == EXPR_CONSTANT)
 		{
 		  have_do_end = true;
@@ -2621,6 +2631,17 @@
 	      if (!have_do_start && !have_do_end)
 		return 0;
 
+	      /* No warning inside a zero-trip loop.  */
+	      if (have_do_start && have_do_end)
+		{
+		  int sgn, cmp;
+
+		  sgn = mpz_cmp_ui (do_step, 0);
+		  cmp = mpz_cmp (do_end, do_start);
+		  if ((sgn > 0 && cmp < 0) || (sgn < 0 && cmp > 0))
+		    break;
+		}
+
 	      /* May have to correct the end value if the step does not equal
 		 one.  */
 	      if (have_do_start && have_do_end && mpz_cmp_ui (do_step, 1) != 0)
@@ -2762,6 +2783,12 @@
 doloop_warn (gfc_namespace *ns)
 {
   gfc_code_walker (&ns->code, doloop_code, do_function, NULL);
+
+  for (ns = ns->contained; ns; ns = ns->sibling)
+    {
+      if (ns->code == NULL || ns->code->op != EXEC_BLOCK)
+	doloop_warn (ns);
+    }
 }
 
 /* This selction deals with inlining calls to MATMUL.  */
Index: gcc/fortran/resolve.c
===================================================================
--- a/src/gcc/fortran/resolve.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/resolve.c	(.../branches/gcc-9-branch)
@@ -13539,6 +13539,25 @@
     }
   else
     {
+      /* If proc has not been resolved at this point, proc->name may 
+	 actually be a USE associated entity. See PR fortran/89647. */
+      if (!proc->resolved
+	  && proc->attr.function == 0 && proc->attr.subroutine == 0)
+	{
+	  gfc_symbol *tmp;
+	  gfc_find_symbol (proc->name, gfc_current_ns->parent, 1, &tmp);
+	  if (tmp && tmp->attr.use_assoc)
+	    {
+	      proc->module = tmp->module;
+	      proc->attr.proc = tmp->attr.proc;
+	      proc->attr.function = tmp->attr.function;
+	      proc->attr.subroutine = tmp->attr.subroutine;
+	      proc->attr.use_assoc = tmp->attr.use_assoc;
+	      proc->ts = tmp->ts;
+	      proc->result = tmp->result;
+	    }
+	}
+
       /* Check for F08:C465.  */
       if ((!proc->attr.subroutine && !proc->attr.function)
 	  || (proc->attr.proc != PROC_MODULE
@@ -13545,8 +13564,9 @@
 	      && proc->attr.if_source != IFSRC_IFBODY)
 	  || proc->attr.abstract)
 	{
-	  gfc_error ("%qs must be a module procedure or an external procedure with"
-		    " an explicit interface at %L", proc->name, &where);
+	  gfc_error ("%qs must be a module procedure or an external "
+		     "procedure with an explicit interface at %L",
+		     proc->name, &where);
 	  goto error;
 	}
     }
@@ -15662,8 +15682,6 @@
       return false;
     }
 
-  has_pointer = sym->attr.pointer;
-
   if (gfc_is_coindexed (e))
     {
       gfc_error ("DATA element %qs at %L cannot have a coindex", sym->name,
@@ -15671,19 +15689,30 @@
       return false;
     }
 
+  has_pointer = sym->attr.pointer;
+
   for (ref = e->ref; ref; ref = ref->next)
     {
       if (ref->type == REF_COMPONENT && ref->u.c.component->attr.pointer)
 	has_pointer = 1;
 
-      if (has_pointer
-	    && ref->type == REF_ARRAY
-	    && ref->u.ar.type != AR_FULL)
-	  {
-	    gfc_error ("DATA element %qs at %L is a pointer and so must "
-			"be a full array", sym->name, where);
-	    return false;
-	  }
+      if (has_pointer)
+	{
+	  if (ref->type == REF_ARRAY && ref->u.ar.type != AR_FULL)
+	    {
+	      gfc_error ("DATA element %qs at %L is a pointer and so must "
+			 "be a full array", sym->name, where);
+	      return false;
+	    }
+
+	  if (values.vnode->expr->expr_type == EXPR_CONSTANT)
+	    {
+	      gfc_error ("DATA object near %L has the pointer attribute "
+			 "and the corresponding DATA value is not a valid "
+			 "initial-data-target", where);
+	      return false;
+	    }
+	}
     }
 
   if (e->rank == 0 || has_pointer)
Index: gcc/fortran/trans-decl.c
===================================================================
--- a/src/gcc/fortran/trans-decl.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/trans-decl.c	(.../branches/gcc-9-branch)
@@ -6440,6 +6440,20 @@
 				    TREE_TYPE (result), DECL_RESULT (fndecl),
 				    result);
 	}
+      else
+	{
+	  /* If the function does not have a result variable, result is
+	     NULL_TREE, and a 'return' is generated without a variable.
+	     The following generates a 'return __result_XXX' where XXX is
+	     the function name.  */
+	  if (sym == sym->result && sym->attr.function)
+	    {
+	      result = gfc_get_fake_result_decl (sym, 0);
+	      result = fold_build2_loc (input_location, MODIFY_EXPR,
+					TREE_TYPE (result),
+					DECL_RESULT (fndecl), result);
+	    }
+	}
     }
 
   return build1_v (RETURN_EXPR, result);
Index: gcc/fortran/check.c
===================================================================
--- a/src/gcc/fortran/check.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/check.c	(.../branches/gcc-9-branch)
@@ -924,6 +924,10 @@
 }
 
 
+/* Limited checking for ALLOCATED intrinsic.  Additional checking
+   is performed in intrinsic.c(sort_actual), because ALLOCATED
+   has two mutually exclusive non-optional arguments.  */
+
 bool
 gfc_check_allocated (gfc_expr *array)
 {
Index: gcc/fortran/misc.c
===================================================================
--- a/src/gcc/fortran/misc.c	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/fortran/misc.c	(.../branches/gcc-9-branch)
@@ -125,6 +125,7 @@
   static char buffer2[GFC_MAX_SYMBOL_LEN + 7];
   static int flag = 0;
   char *buffer;
+  gfc_typespec *ts1;
 
   buffer = flag ? buffer1 : buffer2;
   flag = !flag;
@@ -156,9 +157,8 @@
       sprintf (buffer, "TYPE(%s)", ts->u.derived->name);
       break;
     case BT_CLASS:
-      if (ts->u.derived->components)
-	ts = &ts->u.derived->components->ts;
-      if (ts->u.derived->attr.unlimited_polymorphic)
+      ts1 = ts->u.derived->components ? &ts->u.derived->components->ts : NULL;
+      if (ts1 && ts1->u.derived && ts1->u.derived->attr.unlimited_polymorphic)
 	sprintf (buffer, "CLASS(*)");
       else
 	sprintf (buffer, "CLASS(%s)", ts->u.derived->name);
Index: gcc/BASE-VER
===================================================================
--- a/src/gcc/BASE-VER	(.../tags/gcc_9_2_0_release)
+++ b/src/gcc/BASE-VER	(.../branches/gcc-9-branch)
@@ -1 +1 @@
-9.2.0
+9.2.1
Index: libgfortran/intrinsics/random.c
===================================================================
--- a/src/libgfortran/intrinsics/random.c	(.../tags/gcc_9_2_0_release)
+++ b/src/libgfortran/intrinsics/random.c	(.../branches/gcc-9-branch)
@@ -275,31 +275,20 @@
 }
 
 
-/* Super-simple LCG generator used in getosrandom () if /dev/urandom
-   doesn't exist.  */
+/* Splitmix64 recommended by xorshift author for initializing.  After
+   getting one uint64_t value from the OS, this is used to fill in the
+   rest of the state.  */
 
-#define M 2147483647 /* 2^31 - 1 (A large prime number) */
-#define A 16807      /* Prime root of M, passes statistical tests and produces a full cycle */
-#define Q 127773 /* M / A (To avoid overflow on A * seed) */
-#define R 2836   /* M % A (To avoid overflow on A * seed) */
-
-__attribute__((unused)) static uint32_t
-lcg_parkmiller(uint32_t seed)
+static uint64_t
+splitmix64 (uint64_t x)
 {
-    uint32_t hi = seed / Q;
-    uint32_t lo = seed % Q;
-    int32_t test = A * lo - R * hi;
-    if (test <= 0)
-        test += M;
-    return test;
+  uint64_t z = (x += 0x9e3779b97f4a7c15);
+  z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;
+  z = (z ^ (z >> 27)) * 0x94d049bb133111eb;
+  return z ^ (z >> 31);
 }
 
-#undef M
-#undef A
-#undef Q
-#undef R
 
-
 /* Get some random bytes from the operating system in order to seed
    the PRNG.  */
 
@@ -315,7 +304,7 @@
 #else
 #ifdef HAVE_GETENTROPY
   if (getentropy (buf, buflen) == 0)
-    return 0;
+    return buflen;
 #endif
   int flags = O_RDONLY;
 #ifdef O_CLOEXEC
@@ -328,7 +317,7 @@
       close (fd);
       return res;
     }
-  uint32_t seed = 1234567890;
+  uint64_t seed = 0x047f7684e9fc949dULL;
   time_t secs;
   long usecs;
   if (gf_gettime (&secs, &usecs) == 0)
@@ -340,13 +329,9 @@
   pid_t pid = getpid();
   seed ^= pid;
 #endif
-  uint32_t* ub = buf;
-  for (size_t i = 0; i < buflen / sizeof (uint32_t); i++)
-    {
-      ub[i] = seed;
-      seed = lcg_parkmiller (seed);
-    }
-  return buflen;
+  size_t size = buflen < sizeof (uint64_t) ? buflen : sizeof (uint64_t);
+  memcpy (buf, &seed, size);
+  return size;
 #endif /* __MINGW64_VERSION_MAJOR  */
 }
 
@@ -361,7 +346,13 @@
     __gthread_mutex_lock (&random_lock);
   if (!master_init)
     {
-      getosrandom (master_state, sizeof (master_state));
+      uint64_t os_seed;
+      getosrandom (&os_seed, sizeof (os_seed));
+      for (uint64_t i = 0; i < sizeof (master_state) / sizeof (uint64_t); i++)
+	{
+	  os_seed = splitmix64 (os_seed);
+	  master_state[i] = os_seed;
+	}
       njumps = 0;
       master_init = true;
     }
Index: libgfortran/ChangeLog
===================================================================
--- a/src/libgfortran/ChangeLog	(.../tags/gcc_9_2_0_release)
+++ b/src/libgfortran/ChangeLog	(.../branches/gcc-9-branch)
@@ -1,3 +1,13 @@
+2019-08-13  Janne Blomqvist  <jb@gcc.gnu.org>
+
+	Partial backport from trunk
+	PR fortran/91414
+	* intrinsics/random.c (lcg_parkmiller): Replace with splitmix64.
+	(splitmix64): New function.
+	(getosrandom): Fix return value, simplify.
+	(init_rand_state): Use getosrandom only to get 8 bytes, splitmix64
+	to fill rest of state.
+
 2019-08-12  Release Manager
 
 	* GCC 9.2.0 released.
