--- a/src/gcc/config/arm/arm.c	2012-08-07 18:13:10 +0000
+++ b/src/gcc/config/arm/arm.c	2012-07-01 01:50:29 +0000
@@ -258,7 +258,6 @@
 					unsigned HOST_WIDE_INT);
 static enum machine_mode arm_preferred_simd_mode (enum machine_mode);
 static bool arm_class_likely_spilled_p (reg_class_t);
-static HOST_WIDE_INT arm_vector_alignment (const_tree type);
 static bool arm_vector_alignment_reachable (const_tree type, bool is_packed);
 static bool arm_builtin_support_vector_misalignment (enum machine_mode mode,
 						     const_tree type,
@@ -613,9 +612,6 @@
 #undef TARGET_CLASS_LIKELY_SPILLED_P
 #define TARGET_CLASS_LIKELY_SPILLED_P arm_class_likely_spilled_p
 
-#undef TARGET_VECTOR_ALIGNMENT
-#define TARGET_VECTOR_ALIGNMENT arm_vector_alignment
-
 #undef TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE
 #define TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE \
   arm_vector_alignment_reachable
@@ -24815,18 +24811,6 @@
     }
 }
 
-/* The AAPCS sets the maximum alignment of a vector to 64 bits.  */
-static HOST_WIDE_INT
-arm_vector_alignment (const_tree type)
-{
-  HOST_WIDE_INT align = tree_low_cst (TYPE_SIZE (type), 0);
-
-  if (TARGET_AAPCS_BASED)
-    align = MIN (align, 64);
-
-  return align;
-}
-
 static unsigned int
 arm_autovectorize_vector_sizes (void)
 {
--- a/src/gcc/stor-layout.c	2012-08-07 18:13:10 +0000
+++ b/src/gcc/stor-layout.c	2012-04-02 11:35:45 +0000
@@ -1955,17 +1955,9 @@
 	TYPE_SIZE (type) = int_const_binop (MULT_EXPR, TYPE_SIZE (innertype),
 					    bitsize_int (nunits), 0);
 
-	/* For vector types, we do not default to the mode's alignment.
-	   Instead, query a target hook, defaulting to natural alignment.
-	   This prevents ABI changes depending on whether or not native
-	   vector modes are supported.  */
-	TYPE_ALIGN (type) = targetm.vector_alignment (type);
-
-	/* However, if the underlying mode requires a bigger alignment than
-	   what the target hook provides, we cannot use the mode.  For now,
-	   simply reject that case.  */
-	gcc_assert (TYPE_ALIGN (type)
-		    >= GET_MODE_ALIGNMENT (TYPE_MODE (type)));
+	/* Always naturally align vectors.  This prevents ABI changes
+	   depending on whether or not native vector modes are supported.  */
+	TYPE_ALIGN (type) = tree_low_cst (TYPE_SIZE (type), 0);
         break;
       }
 
--- a/src/gcc/target.def	2012-08-07 18:13:10 +0000
+++ b/src/gcc/target.def	2011-07-01 09:19:21 +0000
@@ -1618,16 +1618,6 @@
  bool, (enum machine_mode mode),
  hook_bool_mode_false)
 
-DEFHOOK
-(vector_alignment,
- "This hook can be used to define the alignment for a vector of type\n\
-@var{type}, in order to comply with a platform ABI.  The default is to\n\
-require natural alignment for vector types.  The alignment returned by\n\
-this hook must be a power-of-two multiple of the default alignment of\n\
-the vector element type.",
- HOST_WIDE_INT, (const_tree type),
- default_vector_alignment)
-
 /* True if we should try to use a scalar mode to represent an array,
    overriding the usual MAX_FIXED_MODE limit.  */
 DEFHOOK
--- a/src/gcc/targhooks.c	2012-08-07 18:13:10 +0000
+++ b/src/gcc/targhooks.c	2012-04-02 11:35:45 +0000
@@ -979,13 +979,6 @@
    return id;
 }
 
-/* Default to natural alignment for vector types.  */
-HOST_WIDE_INT
-default_vector_alignment (const_tree type)
-{
-  return tree_low_cst (TYPE_SIZE (type), 0);
-}
-
 bool
 default_builtin_vector_alignment_reachable (const_tree type, bool is_packed)
 {
--- a/src/gcc/targhooks.h	2012-08-07 18:13:10 +0000
+++ b/src/gcc/targhooks.h	2011-05-03 15:17:25 +0000
@@ -85,8 +85,6 @@
 
 extern tree default_builtin_reciprocal (unsigned int, bool, bool);
 
-extern HOST_WIDE_INT default_vector_alignment (const_tree);
-
 extern bool default_builtin_vector_alignment_reachable (const_tree, bool);
 extern bool
 default_builtin_support_vector_misalignment (enum machine_mode mode,
--- a/src/gcc/testsuite/gcc.dg/align-2.c	2012-08-07 18:13:10 +0000
+++ b/src/gcc/testsuite/gcc.dg/align-2.c	2004-10-19 18:21:41 +0000
@@ -1,5 +1,5 @@
 /* PR 17962 */
-/* { dg-do compile { target vect_natural_alignment } } */
+/* { dg-do compile } */
 /* { dg-options "" } */
 
 typedef float v4 __attribute__((vector_size(sizeof(float)*4)));
--- a/src/gcc/testsuite/gcc.dg/vect/slp-25.c	2012-08-07 18:13:10 +0000
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-25.c	2011-09-19 07:44:24 +0000
@@ -56,5 +56,5 @@
 
 /* { dg-final { scan-tree-dump-times "vectorized 2 loops" 1 "vect"  } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 0 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail { vect_no_align || { ! vect_natural_alignment } } } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 2 "vect" { xfail { vect_no_align } } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-peel-1.c	2012-08-09 14:38:28 +0000
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-peel-1.c	2011-09-19 07:44:24 +0000
@@ -48,6 +48,6 @@
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target { { vect_element_align } && { vect_aligned_arrays } } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target vect_element_align } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-peel-2.c	2012-08-09 14:38:28 +0000
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-peel-2.c	2011-09-19 07:44:24 +0000
@@ -49,6 +49,6 @@
 }
 
 /* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
-/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target { { vect_element_align } && { vect_aligned_arrays } } } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target { { vect_element_align } && { vect_aligned_arrays } } } } } */
+/* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect" { target vect_element_align } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { target vect_element_align } } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-peel-3.c	2012-08-09 14:38:28 +0000
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-peel-3.c	2010-11-22 13:59:45 +0000
@@ -4,7 +4,9 @@
 #include "tree-vect.h"
 
 #define N 128
-#define RES 21640 
+#define RES 21888 
+
+/* unaligned store.  */
 
 int ib[N+10];
 int ia[N+10];
@@ -16,11 +18,11 @@
   int i, suma = 0, sumb = 0, sumc = 0;
 
   /* ib and ic have same misalignment, we peel to align them.  */
-  for (i = 0; i <= N; i++)
+  for (i = 1; i <= N; i++)
     {
       suma += ia[i];
-      sumb += ib[i+5];
-      sumc += ic[i+1];
+      sumb += ib[i+6];
+      sumc += ic[i+2];
     }
 
   /* check results:  */
@@ -47,7 +49,7 @@
   return main1 ();
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect"  { xfail vect_no_align } } } */
-/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 1 "vect" } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/gcc.dg/vect/vect-peel-4.c	2012-08-09 14:38:28 +0000
+++ b/src/gcc/testsuite/gcc.dg/vect/vect-peel-4.c	2011-09-19 07:44:24 +0000
@@ -16,13 +16,13 @@
   /* Don't peel keeping one load and the store aligned.  */
   for (i = 0; i <= N; i++)
     {
-      ia[i] = ib[i] + ib[i+5];
+      ia[i] = ib[i] + ib[i+6];
     }
 
   /* check results:  */
   for (i = 1; i <= N; i++)
     {
-      if (ia[i] != ib[i] + ib[i+5])
+      if (ia[i] != ib[i] + ib[i+6])
         abort ();
     }
 
@@ -44,7 +44,7 @@
   return main1 ();
 }
 
-/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" { xfail vect_no_align } } } */
+/* { dg-final { scan-tree-dump-times "vectorized 1 loops" 1 "vect" } } */
 /* { dg-final { scan-tree-dump-times "Vectorizing an unaligned access" 1 "vect"  { xfail vect_no_align } } } */
 /* { dg-final { scan-tree-dump-times "Alignment of access forced using peeling" 0 "vect" } } */
 /* { dg-final { cleanup-tree-dump "vect" } } */
--- a/src/gcc/testsuite/lib/target-supports.exp	2012-08-07 18:13:10 +0000
+++ b/src/gcc/testsuite/lib/target-supports.exp	2012-03-02 13:53:14 +0000
@@ -3117,26 +3117,6 @@
     return $et_natural_alignment_64_saved
 }
 
-# Return 1 if all vector types are naturally aligned (aligned to their
-# type-size), 0 otherwise.
-#
-# This won't change for different subtargets so cache the result.
-
-proc check_effective_target_vect_natural_alignment { } {
-    global et_vect_natural_alignment
-
-    if [info exists et_vect_natural_alignment_saved] {
-        verbose "check_effective_target_vect_natural_alignment: using cached result" 2
-    } else {
-        set et_vect_natural_alignment_saved 1
-        if { [check_effective_target_arm_eabi] } {
-            set et_vect_natural_alignment_saved 0
-        }
-    }
-    verbose "check_effective_target_vect_natural_alignment: returning $et_vect_natural_alignment_saved" 2
-    return $et_vect_natural_alignment_saved
-}
-
 # Return 1 if vector alignment (for types of size 32 bit or less) is reachable, 0 otherwise.
 #
 # This won't change for different subtargets so cache the result.
--- a/src/gcc/tree-vect-data-refs.c	2012-08-07 18:13:10 +0000
+++ b/src/gcc/tree-vect-data-refs.c	2012-06-26 09:29:30 +0000
@@ -1041,7 +1041,7 @@
       int misal = DR_MISALIGNMENT (dr);
       tree vectype = STMT_VINFO_VECTYPE (stmt_info);
       misal += negative ? -npeel * dr_size : npeel * dr_size;
-      misal &= (TYPE_ALIGN (vectype) / BITS_PER_UNIT) - 1;
+      misal &= GET_MODE_SIZE (TYPE_MODE (vectype)) - 1;
       SET_DR_MISALIGNMENT (dr, misal);
       return;
     }
--- a/src/gcc/tree-vect-loop-manip.c	2012-08-07 18:13:10 +0000
+++ b/src/gcc/tree-vect-loop-manip.c	2011-07-04 11:13:51 +0000
@@ -1972,7 +1972,7 @@
    If the misalignment of DR is known at compile time:
      addr_mis = int mis = DR_MISALIGNMENT (dr);
    Else, compute address misalignment in bytes:
-     addr_mis = addr & (vectype_align - 1)
+     addr_mis = addr & (vectype_size - 1)
 
    prolog_niters = min (LOOP_NITERS, ((VF - addr_mis/elem_size)&(VF-1))/step)
 
@@ -2029,10 +2029,9 @@
       tree ptr_type = TREE_TYPE (start_addr);
       tree size = TYPE_SIZE (ptr_type);
       tree type = lang_hooks.types.type_for_size (tree_low_cst (size, 1), 1);
-      tree vectype_align_minus_1 = build_int_cst (type, vectype_align - 1);
-      HOST_WIDE_INT elem_size =
-		int_cst_value (TYPE_SIZE_UNIT (TREE_TYPE (vectype)));
-      tree elem_size_log = build_int_cst (type, exact_log2 (elem_size));
+      tree vectype_size_minus_1 = build_int_cst (type, vectype_align - 1);
+      tree elem_size_log =
+        build_int_cst (type, exact_log2 (vectype_align/nelements));
       tree nelements_minus_1 = build_int_cst (type, nelements - 1);
       tree nelements_tree = build_int_cst (type, nelements);
       tree byte_misalign;
@@ -2041,10 +2040,10 @@
       new_bb = gsi_insert_seq_on_edge_immediate (pe, new_stmts);
       gcc_assert (!new_bb);
 
-      /* Create:  byte_misalign = addr & (vectype_align - 1)  */
+      /* Create:  byte_misalign = addr & (vectype_size - 1)  */
       byte_misalign =
         fold_build2 (BIT_AND_EXPR, type, fold_convert (type, start_addr), 
-                     vectype_align_minus_1);
+                     vectype_size_minus_1);
 
       /* Create:  elem_misalign = byte_misalign / element_size  */
       elem_misalign =
